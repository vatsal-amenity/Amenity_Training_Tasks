/**
 * Format a table as a JavaScript Object Notation (JSON) string.
 * @param {import('../table/Table.js').Table} table The table to format.
 * @param {JSONFormatOptions} options The formatting options.
 * @return {string} A JSON string.
 */
export function toJSON(table: import("../table/Table.js").Table, { type, columns: cols, format, limit, offset }?: JSONFormatOptions): string;
/**
 * Options for JSON formatting.
 */
export type JSONFormatOptions = {
    /**
     * The format type.
     * One of `'columns'` (for an object with named column arrays)`, 'rows'` (for
     * an array for row objects), or `'ndjson'` for [newline-delimited JSON][1]
     * rows. For `'ndjson'`, each line of text will contain a JSON row object
     * (with no trailing comma) and string properties will be stripped of any
     * newline characters. If no format type is specified, defaults to `'rows'`.
     *
     * [1]: https://github.com/ndjson/ndjson-spec
     */
    type?: "columns" | "rows" | "ndjson" | null;
    /**
     * The maximum number of rows to print.
     */
    limit?: number;
    /**
     * The row offset indicating how many initial
     * rows to skip.
     */
    offset?: number;
    /**
     * Ordered list
     * of column names to include. If function-valued, the function should
     * accept a table as input and return an array of column name strings.
     */
    columns?: import("./types.js").ColumnSelectOptions;
    /**
     * Object of column
     * format options. The object keys should be column names. The object values
     * should be formatting functions to invoke to transform column values prior
     * to output. If specified, these override automatically inferred options.
     */
    format?: {
        [x: string]: (value: any) => any;
    };
};
