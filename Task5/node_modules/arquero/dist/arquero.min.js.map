{"version":3,"file":"arquero.min.js","sources":["../src/table/BitSet.js","../src/util/is-date.js","../src/util/is-regexp.js","../src/util/is-object.js","../src/op/functions/equal.js","../src/op/functions/sequence.js","../src/util/null.js","../src/util/is-array.js","../src/util/is-typed-array.js","../src/util/is-array-type.js","../src/util/is-string.js","../src/util/is-valid.js","../src/op/functions/array.js","../src/util/pad.js","../src/util/format-date.js","../src/util/is-iso-date-string.js","../src/op/functions/date.js","../src/util/parse-iso-date.js","../src/op/functions/json.js","../src/util/random.js","../src/op/functions/math.js","../src/util/is-map.js","../src/util/is-map-or-set.js","../src/util/is-set.js","../src/op/functions/object.js","../src/op/functions/string.js","../src/op/functions/index.js","../src/op/functions/bin.js","../src/op/functions/recode.js","../src/util/to-array.js","../src/util/is-bigint.js","../src/util/to-string.js","../src/op/op-api.js","../src/util/error.js","../src/util/is-function.js","../src/util/repeat.js","../src/util/key-function.js","../src/util/no-op.js","../src/op/aggregate-functions.js","../src/util/distinct-map.js","../src/util/product.js","../src/util/bins.js","../src/op/window-functions.js","../src/op/index.js","../src/util/concat.js","../src/util/unroll.js","../src/util/ascending.js","../src/util/to-numeric.js","../src/util/value-list.js","../src/util/min.js","../src/util/max.js","../src/util/quantile.js","../src/verbs/reduce/reducer.js","../src/verbs/reduce/field-reducer.js","../src/verbs/reduce/util.js","../src/util/entries.js","../src/expression/ast/constants.js","../src/expression/ast/walk.js","../src/expression/ast/clean.js","../src/expression/ast/util.js","../src/expression/codegen.js","../src/expression/compile.js","../src/expression/rewrite.js","../src/expression/row-object.js","../src/expression/parse-escape.js","../src/util/to-function.js","../node_modules/acorn/dist/acorn.mjs","../src/expression/constants.js","../src/util/is-number.js","../src/expression/parse-expression.js","../src/expression/parse.js","../src/helpers/wrap.js","../src/helpers/field.js","../src/util/assign.js","../src/util/escape-regexp.js","../src/helpers/selection.js","../src/verbs/util/parse.js","../src/verbs/groupby.js","../src/table/ColumnSet.js","../src/verbs/rollup.js","../src/verbs/select.js","../src/table/regroup.js","../src/util/unique-name.js","../src/table/Table.js","../src/util/array-type.js","../src/verbs/concat.js","../src/verbs/relocate.js","../src/util/bisector.js","../src/verbs/window/window-state.js","../src/verbs/window/window.js","../src/verbs/derive.js","../src/verbs/filter.js","../src/verbs/dedupe.js","../src/verbs/join/lookup.js","../src/verbs/util/parse-key.js","../src/verbs/util/join-keys.js","../src/util/intersect.js","../src/verbs/join-filter.js","../src/verbs/unroll.js","../src/verbs/fold.js","../src/verbs/ungroup.js","../src/verbs/impute.js","../src/verbs/join.js","../src/verbs/lookup.js","../src/expression/compare.js","../src/verbs/orderby.js","../src/verbs/pivot.js","../src/util/sample.js","../src/verbs/sample.js","../src/util/shuffle.js","../src/helpers/slice.js","../src/verbs/slice.js","../src/verbs/spread.js","../node_modules/@uwdata/flechette/src/constants.js","../node_modules/@uwdata/flechette/src/util/arrays.js","../node_modules/@uwdata/flechette/src/util/objects.js","../node_modules/@uwdata/flechette/src/data-types.js","../node_modules/@uwdata/flechette/src/util/numbers.js","../node_modules/@uwdata/flechette/src/util/strings.js","../node_modules/@uwdata/flechette/src/util/read.js","../node_modules/@uwdata/flechette/src/util/struct.js","../node_modules/@uwdata/flechette/src/batch.js","../node_modules/@uwdata/flechette/src/column.js","../node_modules/@uwdata/flechette/src/table.js","../node_modules/@uwdata/flechette/src/batch-type.js","../node_modules/@uwdata/flechette/src/decode/block.js","../node_modules/@uwdata/flechette/src/decode/record-batch.js","../node_modules/@uwdata/flechette/src/decode/dictionary-batch.js","../node_modules/@uwdata/flechette/src/decode/data-type.js","../node_modules/@uwdata/flechette/src/decode/metadata.js","../node_modules/@uwdata/flechette/src/decode/schema.js","../node_modules/@uwdata/flechette/src/decode/message.js","../node_modules/@uwdata/flechette/src/decode/decode-ipc.js","../node_modules/@uwdata/flechette/src/decode/table-from-ipc.js","../node_modules/@uwdata/flechette/src/encode/builder.js","../node_modules/@uwdata/flechette/src/encode/record-batch.js","../node_modules/@uwdata/flechette/src/encode/dictionary-batch.js","../node_modules/@uwdata/flechette/src/encode/metadata.js","../node_modules/@uwdata/flechette/src/encode/data-type.js","../node_modules/@uwdata/flechette/src/encode/schema.js","../node_modules/@uwdata/flechette/src/encode/footer.js","../node_modules/@uwdata/flechette/src/encode/message.js","../node_modules/@uwdata/flechette/src/encode/sink.js","../node_modules/@uwdata/flechette/src/encode/encode-ipc.js","../node_modules/@uwdata/flechette/src/encode/table-to-ipc.js","../node_modules/@uwdata/flechette/src/build/buffer.js","../node_modules/@uwdata/flechette/src/build/builders/batch.js","../node_modules/@uwdata/flechette/src/build/builders/validity.js","../node_modules/@uwdata/flechette/src/build/builders/dictionary.js","../node_modules/@uwdata/flechette/src/build/infer-type.js","../node_modules/@uwdata/flechette/src/build/builders/binary.js","../node_modules/@uwdata/flechette/src/build/builders/bool.js","../node_modules/@uwdata/flechette/src/build/builders/decimal.js","../node_modules/@uwdata/flechette/src/build/builders/fixed-size-binary.js","../node_modules/@uwdata/flechette/src/build/builders/fixed-size-list.js","../node_modules/@uwdata/flechette/src/build/builders/interval.js","../node_modules/@uwdata/flechette/src/build/builders/list.js","../node_modules/@uwdata/flechette/src/build/builders/struct.js","../node_modules/@uwdata/flechette/src/build/builders/map.js","../node_modules/@uwdata/flechette/src/build/builders/run-end-encoded.js","../node_modules/@uwdata/flechette/src/build/builders/union.js","../node_modules/@uwdata/flechette/src/build/builders/utf8.js","../node_modules/@uwdata/flechette/src/build/builders/values.js","../node_modules/@uwdata/flechette/src/build/builder.js","../node_modules/@uwdata/flechette/src/build/column-from-values.js","../node_modules/@uwdata/flechette/src/build/column-from-array.js","../src/format/util/columns.js","../src/format/to-arrow.js","../node_modules/@uwdata/flechette/src/build/table-from-columns.js","../src/format/to-arrow-ipc.js","../src/util/identity.js","../src/format/util/scan.js","../src/format/to-csv.js","../src/format/util/formats.js","../src/format/util/infer.js","../src/format/util/format-value.js","../src/format/to-html.js","../src/util/map-object.js","../src/format/stream/constants.js","../src/format/to-json.js","../src/format/to-markdown.js","../src/table/ColumnTable.js","../src/verbs/assign.js","../src/verbs/rename.js","../src/verbs/reduce.js","../src/verbs/unorder.js","../src/verbs/union.js","../src/verbs/intersect.js","../src/verbs/except.js","../src/format/stream/compression-type.js","../src/format/stream/byte-stream-web.js","../src/format/stream/stream-iterator.js","../src/format/stream/collect.js","../src/util/is-readable-stream.js","../src/format/from-arrow.js","../src/format/stream/delimited-text-stream.js","../src/format/stream/line-filter-stream.js","../src/util/parse-values.js","../src/format/stream/pipeline.js","../src/format/stream/parse-text-rows.js","../src/format/stream/text-stream.js","../src/format/from-csv.js","../src/format/stream/fixed-text-stream.js","../src/format/stream/text-line-stream.js","../src/format/from-fixed.js","../src/util/is-digit-string.js","../src/format/stream/parse-json-rows.js","../src/format/from-json.js","../src/op/register.js","../src/table/columns-from.js","../src/verbs/helpers/agg.js","../src/helpers/bin.js","../src/helpers/collate.js","../src/helpers/desc.js","../src/helpers/escape.js","../src/helpers/frac.js","../src/table/index.js","../src/helpers/names.js","../src/helpers/rolling.js"],"sourcesContent":["const ONE = 0x80000000;\nconst ALL = 0xFFFFFFFF;\n\n/**\n * Represent an indexable set of bits.\n */\nexport class BitSet {\n  /**\n   * Instantiate a new BitSet instance.\n   * @param {number} size The number of bits.\n   */\n  constructor(size) {\n    this._size = size;\n    this._bits = new Uint32Array(Math.ceil(size / 32));\n  }\n\n  /**\n   * The number of bits.\n   * @return {number}\n   */\n  get length() {\n    return this._size;\n  }\n\n  /**\n   * The number of bits set to one.\n   * https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\n   * @return {number}\n   */\n  count() {\n    const n = this._bits.length;\n    let count = 0;\n    for (let i = 0; i < n; ++i) {\n      for (let b = this._bits[i]; b; ++count) {\n        b &= b - 1;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get the bit at a given index.\n   * @param {number} i The bit index.\n   */\n  get(i) {\n    return this._bits[i >> 5] & (ONE >>> i);\n  }\n\n  /**\n   * Set the bit at a given index to one.\n   * @param {number} i The bit index.\n   */\n  set(i) {\n    this._bits[i >> 5] |= (ONE >>> i);\n  }\n\n  /**\n   * Clear the bit at a given index to zero.\n   * @param {number} i The bit index.\n   */\n  clear(i) {\n    this._bits[i >> 5] &= ~(ONE >>> i);\n  }\n\n  /**\n   * Scan the bits, invoking a callback function with the index of\n   * each non-zero bit.\n   * @param {(i: number) => void} fn A callback function.\n   */\n  scan(fn) {\n    for (let i = this.next(0); i >= 0; i = this.next(i + 1)) {\n      fn(i);\n    }\n  }\n\n  /**\n   * Get the next non-zero bit starting from a given index.\n   * @param {number} i The bit index.\n   */\n  next(i) {\n    const bits = this._bits;\n    const n = bits.length;\n\n    let index = i >> 5;\n    let curr = bits[index] & (ALL >>> i);\n\n    for (; index < n; curr = bits[++index]) {\n      if (curr !== 0) {\n        return (index << 5) + Math.clz32(curr);\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Return the index of the nth non-zero bit.\n   * @param {number} n The number of non-zero bits to advance.\n   * @return {number} The index of the nth non-zero bit.\n   */\n  nth(n) {\n    let i = this.next(0);\n    while (n-- && i >= 0) i = this.next(i + 1);\n    return i;\n  }\n\n  /**\n   * Negate all bits in this bitset.\n   * Modifies this BitSet in place.\n   * @return {this}\n   */\n  not() {\n    const bits = this._bits;\n    const n = bits.length;\n\n    // invert all bits\n    for (let i = 0; i < n; ++i) {\n      bits[i] = ~bits[i];\n    }\n\n    // unset extraneous trailing bits\n    const tail = this._size % 32;\n    if (tail) {\n      bits[n - 1] &= ONE >> (tail - 1);\n    }\n\n    return this;\n  }\n\n  /**\n   * Compute the logical AND of this BitSet and another.\n   * @param {BitSet} bitset The BitSet to combine with.\n   * @return {BitSet} This BitSet updated with the logical AND.\n   */\n  and(bitset) {\n    if (bitset) {\n      const a = this._bits;\n      const b = bitset._bits;\n      const n = a.length;\n\n      for (let i = 0; i < n; ++i) {\n        a[i] &= b[i];\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Compute the logical OR of this BitSet and another.\n   * @param {BitSet} bitset The BitSet to combine with.\n   * @return {BitSet} This BitSet updated with the logical OR.\n   */\n  or(bitset) {\n    if (bitset) {\n      const a = this._bits;\n      const b = bitset._bits;\n      const n = a.length;\n\n      for (let i = 0; i < n; ++i) {\n        a[i] |= b[i];\n      }\n    }\n    return this;\n  }\n}\n","/**\n * @param {*} value\n * @returns {value is Date}\n */\nexport function isDate(value) {\n  return value instanceof Date;\n}\n","/**\n * @param {*} value\n * @returns {value is RegExp}\n */\nexport function isRegExp(value) {\n  return value instanceof RegExp;\n}\n","export function isObject(value) {\n  return value === Object(value);\n}\n","import { isDate } from '../../util/is-date.js';\nimport { isRegExp } from '../../util/is-regexp.js';\nimport { isObject } from '../../util/is-object.js';\n\n/**\n * Compare two values for equality, using join semantics in which null\n * !== null. If the inputs are object-valued, a deep equality check\n * of array entries or object key-value pairs is performed.\n * @param {*} a The first input.\n * @param {*} b The second input.\n * @return {boolean} True if equal, false if not.\n */\nexport function equal(a, b) {\n  return (a == null || b == null || a !== a || b !== b) ? false\n    : a === b ? true\n    : (isDate(a) || isDate(b)) ? +a === +b\n    : (isRegExp(a) && isRegExp(b)) ? a + '' === b + ''\n    : (isObject(a) && isObject(b)) ? deepEqual(a, b)\n    : false;\n}\n\nfunction deepEqual(a, b) {\n  if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) {\n    return false;\n  }\n\n  if (a.length || b.length) {\n    return arrayEqual(a, b);\n  }\n\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  keysA.sort();\n  keysB.sort();\n\n  if (!arrayEqual(keysA, keysB, (a, b) => a === b)) {\n    return false;\n  }\n\n  const n = keysA.length;\n  for (let i = 0; i < n; ++i) {\n    const k = keysA[i];\n    if (!equal(a[k], b[k])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction arrayEqual(a, b, test = equal) {\n  const n = a.length;\n  if (n !== b.length) return false;\n\n  for (let i = 0; i < n; ++i) {\n    if (!test(a[i], b[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/**\n * Returns an array containing an arithmetic sequence from the start value\n * to the stop value, in step increments. If step is positive, the last\n * element is the largest start + i * step less than stop; if step is\n * negative, the last element is the smallest start + i * step greater\n * than stop. If the returned array would contain an infinite number of\n * values, an empty range is returned.\n * @param {number} [start=0] The starting value of the sequence.\n * @param {number} [stop] The stopping value of the sequence.\n *  The stop value is exclusive; it is not included in the result.\n * @param {number} [step=1] The step increment between sequence values.\n * @return {number[]} The generated sequence.\n */\nexport function sequence(start, stop, step) {\n  let n = arguments.length;\n  start = +start;\n  stop = +stop;\n  step = n < 2\n    ? (stop = start, start = 0, 1)\n    : n < 3 ? 1 : +step;\n\n  n = Math.max(0, Math.ceil((stop - start) / step)) | 0;\n  const seq = new Array(n);\n\n  for (let i = 0; i < n; ++i) {\n    seq[i] = start + i * step;\n  }\n\n  return seq;\n}\n","/**\n * Default NULL (missing) value to use.\n */\nexport const NULL = undefined;\n","/**\n * @param {*} value\n * @returns {value is Array}\n */\nexport function isArray(value) {\n  return Array.isArray(value);\n}\n","const TypedArray = Object.getPrototypeOf(Int8Array);\n\n/**\n * @param {*} value\n * @return {value is import(\"../table/types.js\").TypedArray}\n */\nexport function isTypedArray(value) {\n  return value instanceof TypedArray;\n}\n","import { isArray } from './is-array.js';\nimport { isTypedArray } from './is-typed-array.js';\n\n/**\n * @param {*} value\n * @return {value is (any[] | import('../table/types.js').TypedArray)}\n */\nexport function isArrayType(value) {\n  return isArray(value) || isTypedArray(value);\n}\n","/**\n * @param {*} value\n * @return {value is String}\n */\nexport function isString(value) {\n  return typeof value === 'string';\n}\n","export function isValid(value) {\n  return value != null && value === value;\n}\n","import { NULL } from '../../util/null.js';\nimport { isArrayType } from '../../util/is-array-type.js';\nimport { isString } from '../../util/is-string.js';\nimport { isValid } from '../../util/is-valid.js';\n\nconst isSeq = (seq) => isArrayType(seq) || isString(seq);\n\n/**\n * Returns a new compacted array with invalid values\n * (`null`, `undefined`, `NaN`) removed.\n * @template T\n * @param {T[]} array The input array.\n * @return {T[]} A compacted array.\n */\nexport function compact(array) {\n  return isArrayType(array)\n    ? array.filter(v => isValid(v))\n    : array;\n}\n\n/**\n * Merges two or more arrays in sequence, returning a new array.\n * @template T\n * @param {...(T|T[])} values The arrays to merge.\n * @return {T[]} The merged array.\n */\nexport function concat(...values) {\n  return [].concat(...values);\n}\n\n/**\n * Determines whether an *array* includes a certain *value* among its\n * entries, returning `true` or `false` as appropriate.\n * @template T\n * @param {T[]} sequence The input array value.\n * @param {T} value The value to search for.\n * @param {number} [index=0] The integer index to start searching\n *  from (default `0`).\n * @return {boolean} True if the value is included, false otherwise.\n */\nexport function includes(sequence, value, index) {\n  return isSeq(sequence)\n    ? sequence.includes(value, index)\n    : false;\n}\n\n/**\n * Returns the first index at which a given *value* can be found in the\n * *sequence* (array or string), or -1 if it is not present.\n * @template T\n * @param {T[]|string} sequence The input array or string value.\n * @param {T} value The value to search for.\n * @return {number} The index of the value, or -1 if not present.\n */\nexport function indexof(sequence, value) {\n  return isSeq(sequence)\n    // @ts-ignore\n    ? sequence.indexOf(value)\n    : -1;\n}\n\n/**\n * Creates and returns a new string by concatenating all of the elements\n * in an *array* (or an array-like object), separated by commas or a\n * specified *delimiter* string. If the *array* has only one item, then\n * that item will be returned without using the delimiter.\n * @template T\n * @param {T[]} array The input array value.\n * @param {string} delim The delimiter string (default `','`).\n * @return {string} The joined string.\n */\nexport function join(array, delim) {\n  return isArrayType(array) ? array.join(delim) : NULL;\n}\n\n/**\n * Returns the last index at which a given *value* can be found in the\n * *sequence* (array or string), or -1 if it is not present.\n * @template T\n * @param {T[]|string} sequence The input array or string value.\n * @param {T} value The value to search for.\n * @return {number} The last index of the value, or -1 if not present.\n */\nexport function lastindexof(sequence, value) {\n  return isSeq(sequence)\n    // @ts-ignore\n    ? sequence.lastIndexOf(value)\n    : -1;\n}\n\n/**\n * Returns the length of the input *sequence* (array or string).\n * @param {Array|string} sequence The input array or string value.\n * @return {number} The length of the sequence.\n */\nexport function length(sequence) {\n  return isSeq(sequence) ? sequence.length : 0;\n}\n\n/**\n * Returns a new array in which the given *property* has been extracted\n * for each element in the input *array*.\n * @param {Array} array The input array value.\n * @param {string} property The property name string to extract. Nested\n *  properties are not supported: the input `\"a.b\"` will indicates a\n *  property with that exact name, *not* a nested property `\"b\"` of\n *  the object `\"a\"`.\n * @return {Array} An array of plucked properties.\n */\nexport function pluck(array, property) {\n  return isArrayType(array)\n    ? array.map(v => isValid(v) ? v[property] : NULL)\n    : NULL;\n}\n\n/**\n * Returns a new array or string with the element order reversed: the first\n * *sequence* element becomes the last, and the last *sequence* element\n * becomes the first. The input *sequence* is unchanged.\n * @template T\n * @param {T[]|string} sequence The input array or string value.\n * @return {T[]|string} The reversed sequence.\n */\nexport function reverse(sequence) {\n  return isArrayType(sequence) ? sequence.slice().reverse()\n    : isString(sequence) ? sequence.split('').reverse().join('')\n    : NULL;\n}\n\n/**\n * Returns a copy of a portion of the input *sequence* (array or string)\n * selected from *start* to *end* (*end* not included) where *start* and\n * *end* represent the index of items in the sequence.\n * @template T\n * @param {T[]|string} sequence The input array or string value.\n * @param {number} [start=0] The starting integer index to copy from\n *  (inclusive, default `0`).\n * @param {number} [end] The ending integer index to copy from (exclusive,\n *  default `sequence.length`).\n * @return {T[]|string} The sliced sequence.\n */\nexport function slice(sequence, start, end) {\n  return isSeq(sequence)\n    ? sequence.slice(start, end)\n    : NULL;\n}\n","export function pad(value, width, char = '0') {\n  const s = value + '';\n  const len = s.length;\n  return len < width ? Array(width - len + 1).join(char) + s : s;\n}\n","import { pad } from './pad.js';\n\nconst pad2 = v => (v < 10 ? '0' : '') + v;\n\nconst formatYear = year => year < 0 ? '-' + pad(-year, 6)\n  : year > 9999 ? '+' + pad(year, 6)\n  : pad(year, 4);\n\nexport function formatISO(year, month, date, hours, min, sec, ms, utc, short) {\n  const suffix = utc ? 'Z' : '';\n  return formatYear(year) + '-' + pad2(month + 1) + '-' + pad2(date) + (\n    !short || ms ? 'T' + pad2(hours) + ':' + pad2(min) + ':' + pad2(sec) + '.' + pad(ms, 3) + suffix\n    : sec ? 'T' + pad2(hours) + ':' + pad2(min) + ':' + pad2(sec) + suffix\n    : min || hours || !utc ? 'T' + pad2(hours) + ':' + pad2(min) + suffix\n    : ''\n  );\n}\n\nexport function formatDate(d, short) {\n  return isNaN(d)\n    ? 'Invalid Date'\n    : formatISO(\n      d.getFullYear(),\n      d.getMonth(),\n      d.getDate(),\n      d.getHours(),\n      d.getMinutes(),\n      d.getSeconds(),\n      d.getMilliseconds(),\n      false, short\n    );\n}\n\nexport function formatUTCDate(d, short) {\n  return isNaN(d)\n    ? 'Invalid Date'\n    : formatISO(\n      d.getUTCFullYear(),\n      d.getUTCMonth(),\n      d.getUTCDate(),\n      d.getUTCHours(),\n      d.getUTCMinutes(),\n      d.getUTCSeconds(),\n      d.getUTCMilliseconds(),\n      true, short\n    );\n}\n","const iso_re = /^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/;\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nexport function isISODateString(value) {\n  return value.match(iso_re) && !isNaN(Date.parse(value));\n}\n","import { formatDate, formatUTCDate } from '../../util/format-date.js';\nimport { parseISODate } from '../../util/parse-iso-date.js';\n\nconst msMinute = 6e4;\nconst msDay = 864e5;\nconst msWeek = 6048e5;\n\nconst t0 = new Date();\nconst t1 = new Date();\nconst t = d => (\n  t0.setTime(typeof d === 'string' ? parseISODate(d) : d),\n  t0\n);\n\n/**\n * Returns an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted\n * string for the given *date* in local timezone. The resulting string is\n * compatible with *parse_date* and JavaScript's built-in *Date.parse*.\n * @param {Date | number} date The input Date or timestamp value.\n * @param {boolean} [shorten=false] A boolean flag (default `false`)\n *  indicating if the formatted string should be shortened if possible.\n *  For example, the local date `2001-01-01` will shorten from\n *  `\"2001-01-01T00:00:00.000\"` to `\"2001-01-01T00:00\"`.\n * @return {string} The formatted date string in local time.\n */\nexport function format_date(date, shorten) {\n  return formatDate(t(date), !shorten);\n}\n\n/**\n * Returns an [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted\n * string for the given *date* in Coordinated Universal Time (UTC). The\n * resulting string is compatible with *parse_date* and JavaScript's\n * built-in *Date.parse*.\n * @param {Date | number} date The input Date or timestamp value.\n * @param {boolean} [shorten=false] A boolean flag (default `false`)\n *  indicating if the formatted string should be shortened if possible.\n *  For example, the the UTC date `2001-01-01` will shorten from\n *  `\"2001-01-01T00:00:00.000Z\"` to `\"2001-01-01\"`\n * @return {string} The formatted date string in UTC time.\n */\nexport function format_utcdate(date, shorten){\n  return formatUTCDate(t(date), !shorten);\n}\n\n/**\n * Returns the number of milliseconds elapsed since midnight, January 1,\n * 1970 Universal Coordinated Time (UTC).\n * @return {number} The timestamp for now.\n */\nexport function now() {\n  return Date.now();\n}\n\n/**\n * Returns the timestamp for a *date* as the number of milliseconds elapsed\n * since January 1, 1970 00:00:00 UTC.\n * @param {Date | number} date The input Date value.\n * @return {number} The timestamp value.\n */\nexport function timestamp(date) {\n  return +t(date);\n}\n\n/**\n * Creates and returns a new Date value. If no arguments are provided,\n * the current date and time are used.\n * @param {number} [year] The year.\n * @param {number} [month=0] The (zero-based) month.\n * @param {number} [date=1] The date within the month.\n * @param {number} [hours=0] The hour within the day.\n * @param {number} [minutes=0] The minute within the hour.\n * @param {number} [seconds=0] The second within the minute.\n * @param {number} [milliseconds=0] The milliseconds within the second.\n * @return {Date} The Date value.\n */\nexport function datetime(year, month, date, hours, minutes, seconds, milliseconds) {\n  return !arguments.length\n    ? new Date(Date.now())\n    : new Date(\n        year,\n        month || 0,\n        date == null ? 1 : date,\n        hours || 0,\n        minutes || 0,\n        seconds || 0,\n        milliseconds || 0\n      );\n}\n\n/**\n * Returns the year of the specified *date* according to local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The year value in local time.\n */\nexport function year(date) {\n  return t(date).getFullYear();\n}\n\n/**\n * Returns the zero-based quarter of the specified *date* according to\n * local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The quarter value in local time.\n */\nexport function quarter(date) {\n  return Math.floor(t(date).getMonth() / 3);\n}\n\n/**\n * Returns the zero-based month of the specified *date* according to local\n * time. A value of `0` indicates January, `1` indicates February, and so on.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The month value in local time.\n */\nexport function month(date) {\n  return t(date).getMonth();\n}\n\n/**\n * Returns the week number of the year (0-53) for the specified *date*\n * according to local time. By default, Sunday is used as the first day\n * of the week. All days in a new year preceding the first Sunday are\n * considered to be in week 0.\n * @param {Date | number} date The input Date or timestamp value.\n * @param {number} firstday The number of first day of the week (default\n *  `0` for Sunday, `1` for Monday and so on).\n * @return {number} The week of the year in local time.\n */\nexport function week(date, firstday) {\n  const i = firstday || 0;\n  t1.setTime(+date);\n  t1.setDate(t1.getDate() - (t1.getDay() + 7 - i) % 7);\n  t1.setHours(0, 0, 0, 0);\n  t0.setTime(+date);\n  t0.setMonth(0);\n  t0.setDate(1);\n  t0.setDate(1 - (t0.getDay() + 7 - i) % 7);\n  t0.setHours(0, 0, 0, 0);\n  const tz = (t1.getTimezoneOffset() - t0.getTimezoneOffset()) * msMinute;\n  return Math.floor((1 + (+t1 - +t0) - tz) / msWeek);\n}\n\n/**\n * Returns the date (day of month) of the specified *date* according\n * to local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The date (day of month) value.\n */\nexport function date(date) {\n  return t(date).getDate();\n}\n\n/**\n * Returns the day of the year (1-366) of the specified *date* according\n * to local time.\n * @param {Date | number} date A date or timestamp.\n * @return {number} The day of the year in local time.\n */\nexport function dayofyear(date) {\n  t1.setTime(+date);\n  t1.setHours(0, 0, 0, 0);\n  t0.setTime(+t1);\n  t0.setMonth(0);\n  t0.setDate(1);\n  const tz = (t1.getTimezoneOffset() - t0.getTimezoneOffset()) * msMinute;\n  return Math.floor(1 + ((+t1 - +t0) - tz) / msDay);\n}\n\n/**\n * Returns the Sunday-based day of the week (0-6) of the specified *date*\n * according to local time. A value of `0` indicates Sunday, `1` indicates\n * Monday, and so on.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The day of the week value in local time.\n */\nexport function dayofweek(date) {\n  return t(date).getDay();\n}\n\n/**\n * Returns the hour of the day for the specified *date* according\n * to local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The hour value in local time.\n */\nexport function hours(date) {\n  return t(date).getHours();\n}\n\n/**\n * Returns the minute of the hour for the specified *date* according\n * to local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The minutes value in local time.\n */\nexport function minutes(date) {\n  return t(date).getMinutes();\n}\n\n/**\n * Returns the seconds of the minute for the specified *date* according\n * to local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The seconds value in local time.\n */\nexport function seconds(date) {\n  return t(date).getSeconds();\n}\n\n/**\n * Returns the milliseconds of the second for the specified *date* according\n * to local time.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The milliseconds value in local time.\n */\nexport function milliseconds(date) {\n  return t(date).getMilliseconds();\n}\n\n/**\n * Creates and returns a new Date value using Coordinated Universal Time\n * (UTC). If no arguments are provided, the current date and time are used.\n * @param {number} [year] The year.\n * @param {number} [month=0] The (zero-based) month.\n * @param {number} [date=1] The date within the month.\n * @param {number} [hours=0] The hour within the day.\n * @param {number} [minutes=0] The minute within the hour.\n * @param {number} [seconds=0] The second within the minute.\n * @param {number} [milliseconds=0] The milliseconds within the second.\n * @return {Date} The Date value.\n */\nexport function utcdatetime(year, month, date, hours, minutes, seconds, milliseconds) {\n  return !arguments.length\n    ? new Date(Date.now())\n    : new Date(Date.UTC(\n        year,\n        month || 0,\n        date == null ? 1 : date,\n        hours || 0,\n        minutes || 0,\n        seconds || 0,\n        milliseconds || 0\n      ));\n}\n\n/**\n * Returns the year of the specified *date* according to Coordinated\n * Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The year value in UTC time.\n */\nexport function utcyear(date) {\n  return t(date).getUTCFullYear();\n}\n\n/**\n * Returns the zero-based quarter of the specified *date* according to\n * Coordinated Universal Time (UTC)\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The quarter value in UTC time.\n */\nexport function utcquarter(date) {\n  return Math.floor(t(date).getUTCMonth() / 3);\n}\n\n/**\n * Returns the zero-based month of the specified *date* according to\n * Coordinated Universal Time (UTC). A value of `0` indicates January,\n * `1` indicates February, and so on.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The month value in UTC time.\n */\nexport function utcmonth(date) {\n  return t(date).getUTCMonth();\n}\n\n/**\n * Returns the week number of the year (0-53) for the specified *date*\n * according to Coordinated Universal Time (UTC). By default, Sunday is\n * used as the first day of the week. All days in a new year preceding the\n * first Sunday are considered to be in week 0.\n * @param {Date | number} date The input Date or timestamp value.\n * @param {number} firstday The number of first day of the week (default\n *  `0` for Sunday, `1` for Monday and so on).\n * @return {number} The week of the year in UTC time.\n */\nexport function utcweek(date, firstday) {\n  const i = firstday || 0;\n  t1.setTime(+date);\n  t1.setUTCDate(t1.getUTCDate() - (t1.getUTCDay() + 7 - i) % 7);\n  t1.setUTCHours(0, 0, 0, 0);\n  t0.setTime(+date);\n  t0.setUTCMonth(0);\n  t0.setUTCDate(1);\n  t0.setUTCDate(1 - (t0.getUTCDay() + 7 - i) % 7);\n  t0.setUTCHours(0, 0, 0, 0);\n  return Math.floor((1 + (+t1 - +t0)) / msWeek);\n}\n\n/**\n * Returns the date (day of month) of the specified *date* according to\n * Coordinated Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The date (day of month) value in UTC time.\n */\nexport function utcdate(date) {\n  return t(date).getUTCDate();\n}\n\n/**\n * Returns the day of the year (1-366) of the specified *date* according\n * to Coordinated Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The day of the year in UTC time.\n */\nexport function utcdayofyear(date) {\n  t1.setTime(+date);\n  t1.setUTCHours(0, 0, 0, 0);\n  const t0 = Date.UTC(t1.getUTCFullYear(), 0, 1);\n  return Math.floor(1 + (+t1 - t0) / msDay);\n}\n\n/**\n * Returns the Sunday-based day of the week (0-6) of the specified *date*\n * according to Coordinated Universal Time (UTC). A value of `0` indicates\n * Sunday, `1` indicates Monday, and so on.\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The day of the week in UTC time.\n */\nexport function utcdayofweek(date) {\n  return t(date).getUTCDay();\n}\n\n/**\n * Returns the hour of the day for the specified *date* according to\n * Coordinated Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The hours value in UTC time.\n */\nexport function utchours(date) {\n  return t(date).getUTCHours();\n}\n\n/**\n * Returns the minute of the hour for the specified *date* according to\n * Coordinated Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The minutes value in UTC time.\n */\nexport function utcminutes(date) {\n  return t(date).getUTCMinutes();\n}\n\n/**\n * Returns the seconds of the minute for the specified *date* according to\n * Coordinated Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The seconds value in UTC time.\n */\nexport function utcseconds(date) {\n  return t(date).getUTCSeconds();\n}\n\n/**\n * Returns the milliseconds of the second for the specified *date* according to\n * Coordinated Universal Time (UTC).\n * @param {Date | number} date The input Date or timestamp value.\n * @return {number} The milliseconds value in UTC time.\n */\nexport function utcmilliseconds(date) {\n  return t(date).getUTCMilliseconds();\n}\n","import { isISODateString } from './is-iso-date-string.js';\n\nexport function parseISODate(value, parse = Date.parse) {\n  return isISODateString(value) ? parse(value) : value;\n}\n","/**\n * Parses a string *value* in JSON format, constructing the JavaScript\n * value or object described by the string.\n * @param {string} value The input string value.\n * @return {any} The parsed JSON.\n */\nexport function parse_json(value) {\n  return JSON.parse(value);\n}\n\n/**\n * Converts a JavaScript object or value to a JSON string.\n * @param {*} value The value to convert to a JSON string.\n * @return {string} The JSON string.\n */\nexport function to_json(value) {\n  return JSON.stringify(value);\n}\n","import { isValid } from './is-valid.js';\n\nlet source = Math.random;\n\nexport function random() {\n  return source();\n}\n\n/**\n * Set a seed value for random number generation.\n * If the seed is a valid number, a 32-bit linear congruential generator\n * with the given seed will be used to generate random values.\n * If the seed is null, undefined, or not a valid number, the random\n * number generator will revert to Math.random.\n * @param {number} seed The random seed value. Should either be an\n *  integer or a fraction between 0 and 1.\n */\nexport function seed(seed) {\n  source = isValid(seed) && isFinite(seed = +seed) ? lcg(seed) : Math.random;\n}\n\nfunction lcg(seed) {\n  const a = 0x19660D;\n  const c = 0x3C6EF35F;\n  const m = 1 / 0x100000000;\n  seed = (0 <= seed && seed < 1 ? seed / m : Math.abs(seed)) | 0;\n\n  // Random numbers using a Linear Congruential Generator with seed value\n  // https://en.wikipedia.org/wiki/Linear_congruential_generator\n  return () => (seed = a * seed + c | 0, m * (seed >>> 0));\n}\n","import { random as _random } from '../../util/random.js';\n\n/**\n * Return a random floating point number between 0 (inclusive) and 1\n * (exclusive). By default uses *Math.random*. Use the *seed* method\n * to instead use a seeded random number generator.\n * @return {number} A pseudorandom number between 0 and 1.\n */\nexport function random() {\n  return _random();\n}\n\n/**\n * Tests if the input *value* is not a number (`NaN`); equivalent\n * to *Number.isNaN*.\n * @param {*} value The value to test.\n * @return {boolean} True if the value is not a number, false otherwise.\n */\nexport function is_nan(value) {\n  return Number.isNaN(value);\n}\n\n/**\n * Tests if the input *value* is finite; equivalent to *Number.isFinite*.\n * @param {*} value The value to test.\n * @return {boolean} True if the value is finite, false otherwise.\n */\nexport function is_finite(value) {\n  return Number.isFinite(value);\n}\n\n/**\n * Returns the absolute value of the input *value*; equivalent to *Math.abs*.\n * @param {number} value The input number value.\n * @return {number} The absolute value.\n */\nexport function abs(value) {\n  return Math.abs(value);\n}\n\n/**\n * Returns the cube root value of the input *value*; equivalent to\n * *Math.cbrt*.\n * @param {number} value The input number value.\n * @return {number} The cube root value.\n */\nexport function cbrt(value) {\n  return Math.cbrt(value);\n}\n\n/**\n * Returns the ceiling of the input *value*, the nearest integer equal to\n * or greater than the input; equivalent to *Math.ceil*.\n * @param {number} value The input number value.\n * @return {number} The ceiling value.\n */\nexport function ceil(value) {\n  return Math.ceil(value);\n}\n\n/**\n * Returns the number of leading zero bits in the 32-bit binary\n * representation of a number *value*; equivalent to *Math.clz32*.\n * @param {number} value The input number value.\n * @return {number} The leading zero bits value.\n */\nexport function clz32(value) {\n  return Math.clz32(value);\n}\n\n/**\n * Returns *e<sup>value</sup>*, where *e* is Euler's number, the base of the\n * natural logarithm; equivalent to *Math.exp*.\n * @param {number} value The input number value.\n * @return {number} The base-e exponentiated value.\n */\nexport function exp(value) {\n  return Math.exp(value);\n}\n\n/**\n * Returns *e<sup>value</sup> - 1*, where *e* is Euler's number, the base of\n * the natural logarithm; equivalent to *Math.expm1*.\n * @param {number} value The input number value.\n * @return {number} The base-e exponentiated value minus 1.\n */\nexport function expm1(value) {\n  return Math.expm1(value);\n}\n\n/**\n * Returns the floor of the input *value*, the nearest integer equal to or\n * less than the input; equivalent to *Math.floor*.\n * @param {number} value The input number value.\n * @return {number} The floor value.\n */\nexport function floor(value) {\n  return Math.floor(value);\n}\n\n/**\n * Returns the nearest 32-bit single precision float representation of the\n * input number *value*; equivalent to *Math.fround*. Useful for translating\n * between 64-bit `Number` values and values from a `Float32Array`.\n * @param {number} value The input number value.\n * @return {number} The rounded value.\n */\nexport function fround(value) {\n  return Math.fround(value);\n}\n\n/**\n * Returns the greatest (maximum) value among the input *values*; equivalent\n * to *Math.max*. This is _not_ an aggregate function, see *op.max* to\n * compute a maximum value across multiple rows.\n * @param {...number} values The input number values.\n * @return {number} The greatest (maximum) value among the inputs.\n */\nexport function greatest(...values) {\n  return Math.max(...values);\n}\n\n/**\n * Returns the least (minimum) value among the input *values*; equivalent\n * to *Math.min*. This is _not_ an aggregate function, see *op.min* to\n * compute a minimum value across multiple rows.\n * @param {...number} values The input number values.\n * @return {number} The least (minimum) value among the inputs.\n */\nexport function least(...values) {\n  return Math.min(...values);\n}\n\n/**\n * Returns the natural logarithm (base *e*) of a number *value*; equivalent\n * to *Math.log*.\n * @param {number} value The input number value.\n * @return {number} The base-e log value.\n */\nexport function log(value) {\n  return Math.log(value);\n}\n\n/**\n * Returns the base 10 logarithm of a number *value*; equivalent\n * to *Math.log10*.\n * @param {number} value The input number value.\n * @return {number} The base-10 log value.\n */\nexport function log10(value) {\n  return Math.log10(value);\n}\n\n/**\n * Returns the natural logarithm (base *e*) of 1 + a number *value*;\n * equivalent to *Math.log1p*.\n * @param {number} value The input number value.\n * @return {number} The base-e log of value + 1.\n */\nexport function log1p(value) {\n  return Math.log1p(value);\n}\n\n/**\n * Returns the base 2 logarithm of a number *value*; equivalent\n * to *Math.log2*.\n * @param {number} value The input number value.\n * @return {number} The base-2 log value.\n */\nexport function log2(value) {\n  return Math.log2(value);\n}\n\n/**\n * Returns the *base* raised to the *exponent* power, that is,\n * *base*<sup>*exponent*</sup>; equivalent to *Math.pow*.\n * @param {number} base The base number value.\n * @param {number} exponent The exponent number value.\n * @return {number} The exponentiated value.\n */\nexport function pow(base, exponent) {\n  return Math.pow(base, exponent);\n}\n\n/**\n * Returns the value of a number rounded to the nearest integer;\n * equivalent to *Math.round*.\n * @param {number} value The input number value.\n * @return {number} The rounded value.\n */\nexport function round(value) {\n  return Math.round(value);\n}\n\n/**\n * Returns either a positive or negative +/- 1, indicating the sign of the\n * input *value*; equivalent to *Math.sign*.\n * @param {number} value The input number value.\n * @return {number} The sign of the value.\n */\nexport function sign(value) {\n  return Math.sign(value);\n}\n\n/**\n * Returns the square root of the input *value*; equivalent to *Math.sqrt*.\n * @param {number} value The input number value.\n * @return {number} The square root value.\n */\nexport function sqrt(value) {\n  return Math.sqrt(value);\n}\n\n/**\n * Returns the integer part of a number by removing any fractional digits;\n * equivalent to *Math.trunc*.\n * @param {number} value The input number value.\n * @return {number} The truncated value.\n */\nexport function trunc(value) {\n  return Math.trunc(value);\n}\n\n/**\n * Converts the input *radians* value to degrees.\n * @param {number} radians The input radians value.\n * @return {number} The value in degrees\n */\nexport function degrees(radians) {\n  return 180 * radians / Math.PI;\n}\n\n/**\n * Converts the input *degrees* value to radians.\n * @param {number} degrees The input degrees value.\n * @return {number} The value in radians.\n */\nexport function radians(degrees) {\n  return Math.PI * degrees / 180;\n}\n\n/**\n * Returns the arc-cosine (in radians) of a number *value*;\n * equivalent to *Math.acos*.\n * @param {number} value The input number value.\n * @return {number} The arc-cosine value.\n */\nexport function acos(value) {\n  return Math.acos(value);\n}\n\n/**\n * Returns the hyperbolic arc-cosine of a number *value*;\n * equivalent to *Math.acosh*.\n * @param {number} value The input number value.\n * @return {number} The hyperbolic arc-cosine value.\n */\nexport function acosh(value) {\n  return Math.acosh(value);\n}\n\n/**\n * Returns the arc-sine (in radians) of a number *value*;\n * equivalent to *Math.asin*.\n * @param {number} value The input number value.\n * @return {number} The arc-sine value.\n */\nexport function asin(value) {\n  return Math.asin(value);\n}\n\n/**\n * Returns the hyperbolic arc-sine of a number *value*;\n * equivalent to *Math.asinh*.\n * @param {number} value The input number value.\n * @return {number} The hyperbolic arc-sine value.\n */\nexport function asinh(value) {\n  return Math.asinh(value);\n}\n\n/**\n * Returns the arc-tangent (in radians) of a number *value*;\n * equivalent to *Math.atan*.\n * @param {number} value The input number value.\n * @return {number} The arc-tangent value.\n */\nexport function atan(value) {\n  return Math.atan(value);\n}\n\n/**\n * Returns the angle in the plane (in radians) between the positive x-axis\n * and the ray from (0, 0) to the point (*x*, *y*);\n * equivalent to *Math.atan2*.\n * @param {number} y The y coordinate of the point.\n * @param {number} x The x coordinate of the point.\n * @return {number} The arc-tangent angle.\n */\nexport function atan2(y, x) {\n  return Math.atan2(y, x);\n}\n\n/**\n * Returns the hyperbolic arc-tangent of a number *value*;\n * equivalent to *Math.atanh*.\n * @param {number} value The input number value.\n * @return {number} The hyperbolic arc-tangent value.\n */\nexport function atanh(value) {\n  return Math.atanh(value);\n}\n\n/**\n * Returns the cosine (in radians) of a number *value*;\n * equivalent to *Math.cos*.\n * @param {number} value The input number value.\n * @return {number} The cosine value.\n */\nexport function cos(value) {\n  return Math.cos(value);\n}\n\n/**\n * Returns the hyperbolic cosine (in radians) of a number *value*;\n * equivalent to *Math.cosh*.\n * @param {number} value The input number value.\n * @return {number} The hyperbolic cosine value.\n */\nexport function cosh(value) {\n  return Math.cosh(value);\n}\n\n/**\n * Returns the sine (in radians) of a number *value*;\n * equivalent to *Math.sin*.\n * @param {number} value The input number value.\n * @return {number} The sine value.\n */\nexport function sin(value) {\n  return Math.sin(value);\n}\n\n/**\n * Returns the hyperbolic sine (in radians) of a number *value*;\n * equivalent to *Math.sinh*.\n * @param {number} value The input number value.\n * @return {number} The hyperbolic sine value.\n */\nexport function sinh(value) {\n  return Math.sinh(value);\n}\n\n/**\n * Returns the tangent (in radians) of a number *value*;\n * equivalent to *Math.tan*.\n * @param {number} value The input number value.\n * @return {number} The tangent value.\n */\nexport function tan(value) {\n  return Math.tan(value);\n}\n\n/**\n * Returns the hyperbolic tangent (in radians) of a number *value*;\n * equivalent to *Math.tanh*.\n * @param {number} value The input number value.\n * @return {number} The hyperbolic tangent value.\n */\nexport function tanh(value) {\n  return Math.tanh(value);\n}\n","/**\n * @param {*} value\n * @return {value is Map}\n */\nexport function isMap(value) {\n  return value instanceof Map;\n}\n","import { isMap } from './is-map.js';\nimport { isSet } from './is-set.js';\n\n/**\n * @param {*} value\n * @return {value is Map | Set}\n */\nexport function isMapOrSet(value) {\n  return isMap(value) || isSet(value);\n}\n","/**\n * @param {*} value\n * @return {value is Set}\n */\nexport function isSet(value) {\n  return value instanceof Set;\n}\n","import { NULL } from '../../util/null.js';\nimport { isMap } from '../../util/is-map.js';\nimport { isMapOrSet } from '../../util/is-map-or-set.js';\n\nfunction array(iter) {\n  return Array.from(iter);\n}\n\n/**\n * Returns a boolean indicating whether the *object* has the specified *key*\n * as its own property (as opposed to inheriting it). If the *object* is a\n * *Map* or *Set* instance, the *has* method will be invoked directly on the\n * object, otherwise *Object.hasOwnProperty* is used.\n * @template {string | number} K\n * @template V\n * @param {Map<K, V>|Set<K>|Record<K, V>} object The object, Map, or Set to\n *  test for property membership.\n * @param {K} key The property key to test for.\n * @return {boolean} True if the object has the given key, false otherwise.\n */\nexport function has(object, key) {\n  return isMapOrSet(object) ? object.has(key)\n    : object != null ? Object.hasOwn(object, `${key}`)\n    : false;\n}\n\n/**\n * Returns an array of a given *object*'s own enumerable property names. If\n * the *object* is a *Map* instance, the *keys* method will be invoked\n * directly on the object, otherwise *Object.keys* is used.\n * @template {string | number} K\n * @template V\n * @param {Map<K, V>|Record<K, V>} object The input object or Map value.\n * @return {K[]} An array of property key name strings.\n */\nexport function keys(object) {\n  return isMap(object) ? array(object.keys())\n    : object != null ? /** @type {K[]} */(Object.keys(object))\n    : [];\n}\n\n/**\n * Returns an array of a given *object*'s own enumerable property values. If\n * the *object* is a *Map* or *Set* instance, the *values* method will be\n * invoked directly on the object, otherwise *Object.values* is used.\n * @template {string | number} K\n * @template V\n * @param {Map<K, V> | Set<V> | Record<K, V>} object The input object, Map,\n *  or Set value.\n * @return {V[]} An array of property values.\n */\nexport function values(object) {\n  return isMapOrSet(object) ? array(object.values())\n    : object != null ? Object.values(object)\n    : [];\n}\n\n/**\n * Returns an array of a given *object*'s own enumerable keyed property\n * `[key, value]` pairs. If the *object* is a *Map* or *Set* instance, the\n * *entries* method will be invoked directly on the object, otherwise\n * *Object.entries* is used.\n * @template {string | number} K\n * @template V\n * @param {Map<K, V> | Set<V> | Record<K, V>} object The input object, Map,\n *  or Set value.\n * @return {[K, V][]} An array of property values.\n */\nexport function entries(object) {\n  return isMapOrSet(object) ? array(object.entries())\n    : object != null ? /** @type {[K, V][]} */(Object.entries(object))\n    : [];\n}\n\n/**\n * Returns a new object given iterable *entries* of `[key, value]` pairs.\n * This method is Arquero's version of the *Object.fromEntries* method.\n * @template {string | number} K\n * @template V\n * @param {Iterable<[K, V]>} entries An iterable collection of `[key, value]`\n *  pairs, such as an array of two-element arrays or a *Map*.\n * @return {Record<K, V>} An object of consolidated key-value pairs.\n */\nexport function object(entries) {\n  return entries\n    ? /** @type {Record<K, V>} */(Object.fromEntries(entries))\n    : NULL;\n}\n","/**\n * Parses a string *value* and returns a Date instance. Beware: this method\n * uses JavaScript's *Date.parse()* functionality, which is inconsistently\n * implemented across browsers. That said,\n * [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted strings such\n * as those produced by *op.format_date* and *op.format_utcdate* should be\n * supported across platforms. Note that \"bare\" ISO date strings such as\n * `\"2001-01-01\"` are interpreted by JavaScript as indicating midnight of\n * that day in Coordinated Universal Time (UTC), *not* local time. To\n * indicate the local timezone, an ISO string can include additional time\n * components and no `Z` suffix: `\"2001-01-01T00:00\"`.\n * @param {*} value The input value.\n * @return {Date} The parsed date value.\n */\nexport function parse_date(value) {\n  return value == null ? value : new Date(value);\n}\n\n/**\n * Parses a string *value* and returns a floating point number.\n * @param {*} value The input value.\n * @return {number} The parsed number value.\n */\nexport function parse_float(value) {\n  return value == null ? value : Number.parseFloat(value);\n}\n\n/**\n * Parses a string *value* and returns an integer of the specified radix\n * (the base in mathematical numeral systems).\n * @param {*} value The input value.\n * @param {number} [radix] An integer between 2 and 36 that represents the\n *  radix (the base in mathematical numeral systems) of the string. Be\n *  careful: this does not default to 10! If *radix* is `undefined`, `0`,\n *  or unspecified, JavaScript assumes the following: If the input string\n *  begins with `\"0x\"` or `\"0X\"` (a zero, followed by lowercase or\n *  uppercase X), the radix is assumed to be 16 and the rest of the string\n *  is parsed as a hexidecimal number. If the input string begins with `\"0\"`\n *  (a zero), the radix is assumed to be 8 (octal) or 10 (decimal). Exactly\n *  which radix is chosen is implementation-dependent.  If the input string\n *  begins with any other value, the radix is 10 (decimal).\n * @return {number} The parsed integer value.\n */\nexport function parse_int(value, radix) {\n  return value == null ? value : Number.parseInt(value, radix);\n}\n\n/**\n * Determines whether a string *value* ends with the characters of a\n * specified *search* string, returning `true` or `false` as appropriate.\n * @param {any} value The input string value.\n * @param {string} search The search string to test for.\n * @param {number} [length] If provided, used as the length of *value*\n *  (default `value.length`).\n * @return {boolean} True if the value ends with the search string,\n *  false otherwise.\n */\nexport function endswith(value, search, length) {\n  return value == null ? false : String(value).endsWith(search, length);\n}\n\n/**\n * Retrieves the result of matching a string *value* against a regular\n * expression *regexp*. If no *index* is specified, returns an array\n * whose contents depend on the presence or absence of the regular\n * expression global (`g`) flag, or `null` if no matches are found. If the\n * `g` flag is used, all results matching the complete regular expression\n * will be returned, but capturing groups will not. If the `g` flag is not\n * used, only the first complete match and its related capturing groups are\n * returned.\n *\n * If specified, the *index* looks up a value of the resulting match. If\n * *index* is a number, the corresponding index of the result array is\n * returned. If *index* is a string, the value of the corresponding\n * named capture group is returned, or `null` if there is no such group.\n * @param {*} value The input string value.\n * @param {*} regexp The regular expression to match against.\n * @param {number|string} index The index into the match result array\n *  or capture group.\n * @return {string|string[]} The match result.\n */\nexport function match(value, regexp, index) {\n  const m = value == null ? value : String(value).match(regexp);\n  return index == null || m == null ? m\n    : typeof index === 'number' ? m[index]\n    : m.groups ? m.groups[index]\n    : null;\n}\n\n/**\n * Returns the Unicode normalization form of the string *value*.\n * @param {*} value The input value to normalize.\n * @param {string} form The Unicode normalization form, one of\n *  `'NFC'` (default, canonical decomposition, followed by canonical\n *  composition), `'NFD'` (canonical decomposition), `'NFKC'` (compatibility\n *  decomposition, followed by canonical composition),\n *  or `'NFKD'` (compatibility decomposition).\n * @return {string} The normalized string value.\n */\nexport function normalize(value, form) {\n  return value == null ? value : String(value).normalize(form);\n}\n\n/**\n * Pad a string *value* with a given *fill* string (applied from the end of\n * *value* and repeated, if needed) so that the resulting string reaches a\n * given *length*.\n * @param {*} value The input value to pad.\n * @param {number} length The length of the resulting string once the\n *  *value* string has been padded. If the length is lower than\n *  `value.length`, the *value* string will be returned as-is.\n * @param {string} [fill] The string to pad the *value* string with\n *  (default `''`). If *fill* is too long to stay within the target\n *  *length*, it will be truncated: for left-to-right languages the\n *  left-most part and for right-to-left languages the right-most will\n *  be applied.\n * @return {string} The padded string.\n */\nexport function padend(value, length, fill) {\n  return value == null ? value : String(value).padEnd(length, fill);\n}\n\n/**\n * Pad a string *value* with a given *fill* string (applied from the start\n * of *value* and repeated, if needed) so that the resulting string reaches\n * a given *length*.\n * @param {*} value The input value to pad.\n * @param {number} length The length of the resulting string once the\n *  *value* string has been padded. If the length is lower than\n *  `value.length`, the *value* string will be returned as-is.\n * @param {string} [fill] The string to pad the *value* string with\n *  (default `''`). If *fill* is too long to stay within the target\n *  *length*, it will be truncated: for left-to-right languages the\n *  left-most part and for right-to-left languages the right-most will\n *  be applied.\n * @return {string} The padded string.\n */\nexport function padstart(value, length, fill) {\n  return value == null ? value : String(value).padStart(length, fill);\n}\n\n/**\n * Returns the string *value* converted to upper case.\n * @param {*} value The input string value.\n * @return {string} The upper case string.\n */\nexport function upper(value) {\n  return value == null ? value : String(value).toUpperCase();\n}\n\n/**\n * Returns the string *value* converted to lower case.\n * @param {*} value The input string value.\n * @return {string} The lower case string.\n */\nexport function lower(value) {\n  return value == null ? value : String(value).toLowerCase();\n}\n\n/**\n * Returns a new string which contains the specified *number* of copies of\n * the *value* string concatenated together.\n * @param {*} value The input string to repeat.\n * @param {*} number An integer between `0` and `+Infinity`, indicating the\n *  number of times to repeat the string.\n * @return {string} The repeated string.\n */\nexport function repeat(value, number) {\n  return value == null ? value : String(value).repeat(number);\n}\n\n/**\n * Returns a new string with some or all matches of a *pattern* replaced by\n * a *replacement*. The *pattern* can be a string or a regular expression,\n * and the *replacement* must be a string. If *pattern* is a string, only\n * the first occurrence will be replaced; to make multiple replacements, use\n * a regular expression *pattern* with a `g` (global) flag.\n * @param {*} value The input string value.\n * @param {*} pattern The pattern string or regular expression to replace.\n * @param {*} replacement The replacement string to use.\n * @return {string} The string with patterns replaced.\n */\nexport function replace(value, pattern, replacement) {\n  return value == null\n    ? value\n    : String(value).replace(pattern, String(replacement));\n}\n\n/**\n * Divides a string *value* into an ordered list of substrings based on a\n * *separator* pattern, puts these substrings into an array, and returns the\n * array.\n * @param {*} value The input string value.\n * @param {*} separator A string or regular expression pattern describing\n *  where each split should occur.\n * @param {number} [limit] An integer specifying a limit on the number of\n *  substrings to be included in the array.\n * @return {string[]}\n */\nexport function split(value, separator, limit) {\n  return value == null ? [] : String(value).split(separator, limit);\n}\n\n/**\n * Determines whether a string *value* starts with the characters of a\n * specified *search* string, returning `true` or `false` as appropriate.\n * @param {*} value The input string value.\n * @param {string} search The search string to test for.\n * @param {number} [position=0] The position in the *value* string at which\n *  to begin searching (default `0`).\n * @return {boolean} True if the string starts with the search pattern,\n *  false otherwise.\n */\nexport function startswith(value, search, position) {\n  return value == null ? false : String(value).startsWith(search, position);\n}\n\n/**\n * Returns the part of the string *value* between the *start* and *end*\n * indexes, or to the end of the string.\n * @param {*} value The input string value.\n * @param {number} [start=0] The index of the first character to include in\n *  the returned substring (default `0`).\n * @param {number} [end] The index of the first character to exclude from\n *  the returned substring (default `value.length`).\n * @return {string} The substring.\n */\nexport function substring(value, start, end) {\n  return value == null ? value : String(value).substring(start, end);\n}\n\n/**\n * Returns a new string with whitespace removed from both ends of the input\n * *value* string. Whitespace in this context is all the whitespace\n * characters (space, tab, no-break space, etc.) and all the line terminator\n * characters (LF, CR, etc.).\n * @param {*} value The input string value to trim.\n * @return {string} The trimmed string.\n */\nexport function trim(value) {\n  return value == null ? value : String(value).trim();\n}\n","import { bin } from './bin.js';\nimport { equal } from './equal.js';\nimport { recode } from './recode.js';\nimport { sequence } from './sequence.js';\n\nimport * as array from './array.js';\nimport * as date from './date.js';\nimport * as json from './json.js';\nimport * as math from './math.js';\nimport * as object from './object.js';\nimport * as string from './string.js';\n\nexport const functions = {\n  bin,\n  equal,\n  recode,\n  sequence,\n  ...array,\n  ...date,\n  ...json,\n  ...math,\n  ...object,\n  ...string\n};\n","/**\n * Truncate a value to a bin boundary.\n * Useful for creating equal-width histograms.\n * Values outside the [min, max] range will be mapped to\n * -Infinity (< min) or +Infinity (> max).\n * @param {number} value The value to bin.\n * @param {number} min The minimum bin boundary.\n * @param {number} max The maximum bin boundary.\n * @param {number} step The step size between bin boundaries.\n * @param {number} [offset=0] Offset in steps by which to adjust\n *  the bin value. An offset of 1 will return the next boundary.\n */\nexport function bin(value, min, max, step, offset) {\n  return value == null ? null\n    : value < min ? -Infinity\n    : value > max ? +Infinity\n    : (\n        value = Math.max(min, Math.min(value, max)),\n        min + step * Math.floor(1e-14 + (value - min) / step + (offset || 0))\n      );\n}\n","/**\n * Recodes an input value to an alternative value, based on a provided\n * value map. If a fallback value is specified, it will be returned when\n * a matching value is not found in the map; otherwise, the input value\n * is returned unchanged.\n * @template T\n * @param {T} value The value to recode. The value must be safely\n *  coercible to a string for lookup against the value map.\n * @param {Map|Record<string,any>} map An object or Map with input values\n *  for keys and output recoded values as values. If a non-Map object, only\n *  the object's own properties will be considered.\n * @param {T} [fallback] A default fallback value to use if the input\n *  value is not found in the value map.\n * @return {T} The recoded value.\n */\nexport function recode(value, map, fallback) {\n  if (map instanceof Map) {\n    if (map.has(value)) return map.get(value);\n  } else {\n    const key = `${value}`;\n    if (Object.hasOwn(map, key)) return map[key];\n  }\n  return fallback !== undefined ? fallback : value;\n}\n","import { isArray } from './is-array.js';\n\nexport function toArray(value) {\n  return value != null\n    ? (isArray(value) ? value : [value])\n    : [];\n}\n","/**\n * @param {*} value\n * @returns {value is bigint}\n */\nexport function isBigInt(value) {\n  return typeof value === 'bigint';\n}\n","import { isBigInt } from './is-bigint.js';\n\nexport function toString(v) {\n  return v === undefined ? v + ''\n    : isBigInt(v) ? v + 'n'\n    : JSON.stringify(v);\n}\n","import { functions } from './functions/index.js';\nimport { toArray } from '../util/to-array.js';\nimport { toString } from '../util/to-string.js';\n\nexport class Op {\n  constructor(name, fields, params) {\n    this.name = name;\n    this.fields = fields;\n    this.params = params;\n  }\n  toString() {\n    const args = [\n      ...this.fields.map(f => `d[${toString(f)}]`),\n      ...this.params.map(toString)\n    ];\n    return `d => op.${this.name}(${args})`;\n  }\n  toObject() {\n    return { expr: this.toString(), func: true };\n  }\n}\n\n/**\n * @param {string} name\n * @param {any | any[]} [fields]\n * @param {any | any[]} [params]\n */\nexport function op(name, fields = [], params = []) {\n  return new Op(name, toArray(fields), toArray(params));\n}\n\nexport const any = (field) => op('any', field);\nexport const count = () => op('count');\nexport const array_agg = (field) => op('array_agg', field);\nexport const array_agg_distinct = (field) => op('array_agg_distinct', field);\nexport const map_agg = (key, value) => op('map_agg', [key, value]);\nexport const object_agg = (key, value) => op('object_agg', [key, value]);\nexport const entries_agg = (key, value) => op('entries_agg', [key, value]);\n\n/**\n * @typedef {import('../table/types.js').Struct} Struct\n */\n\n/**\n * All table expression operations including normal functions,\n * aggregate functions, and window functions.\n */\nexport const opApi = {\n  ...functions,\n\n  /**\n   * Generate an object representing the current table row.\n   * @param {...string} names The column names to include in the object.\n   *  If unspecified, all columns are included.\n   * @return {Struct} The generated row object.\n   */\n  row_object: (...names) => op('row_object', null, names.flat()),\n\n  /**\n   * Aggregate function to count the number of records (rows).\n   * @returns {number} The count of records.\n   */\n  count,\n\n  /**\n   * Aggregate function returning an arbitrary observed value.\n   * @template T\n   * @param {T} field The data field.\n   * @return {T} An arbitrary observed value.\n   */\n  any,\n\n  /**\n   * Aggregate function to collect an array of values.\n   * @template T\n   * @param {T} field The data field.\n   * @return {Array<T>} A list of values.\n   */\n  array_agg,\n\n  /**\n   * Aggregate function to collect an array of distinct (unique) values.\n   * @template T\n   * @param {T} field The data field.\n   * @return {Array<T>} An array of unique values.\n   */\n  array_agg_distinct,\n\n  /**\n   * Aggregate function to create an object given input key and value fields.\n   * @template K, V\n   * @param {K} key The object key field.\n   * @param {V} value The object value field.\n   * @return {Record<K, V>} An object of key-value pairs.\n   */\n  object_agg,\n\n  /**\n   * Aggregate function to create a Map given input key and value fields.\n   * @template K, V\n   * @param {K} key The object key field.\n   * @param {V} value The object value field.\n   * @return {Map<K, V>} A Map of key-value pairs.\n   */\n  map_agg,\n\n  /**\n   * Aggregate function to create an array in the style of Object.entries()\n   * given input key and value fields.\n   * @template K, V\n   * @param {K} key The object key field.\n   * @param {V} value The object value field.\n   * @return {[K, V][]} An array of [key, value] arrays.\n   */\n  entries_agg,\n\n  /**\n   * Aggregate function to count the number of valid values.\n   * Invalid values are null, undefined, or NaN.\n   * @param {*} field The data field.\n   * @return {number} The count of valid values.\n   */\n  // @ts-ignore\n  valid: (field) => op('valid', field),\n\n  /**\n   * Aggregate function to count the number of invalid values.\n   * Invalid values are null, undefined, or NaN.\n   * @param {*} field The data field.\n   * @return {number} The count of invalid values.\n   */\n  // @ts-ignore\n  invalid: (field) => op('invalid', field),\n\n  /**\n   * Aggregate function to count the number of distinct values.\n   * @param {*} field The data field.\n   * @return {number} The count of distinct values.\n   */\n  // @ts-ignore\n  distinct: (field) => op('distinct', field),\n\n  /**\n   * Aggregate function to determine the mode (most frequent) value.\n   * @template T\n   * @param {T} field The data field.\n   * @return {T} The mode value.\n   */\n  // @ts-ignore\n  mode: (field) => op('mode', field),\n\n  /**\n   * Aggregate function to sum values.\n   * @param {*} field The data field.\n   * @return {number} The sum of the values.\n   */\n  // @ts-ignore\n  sum: (field) => op('sum', field),\n\n  /**\n   * Aggregate function to multiply values.\n   * @param {*} field The data field.\n   * @return {number} The product of the values.\n   */\n  // @ts-ignore\n  product: (field) => op('product', field),\n\n  /**\n   * Aggregate function for the mean (average) value.\n   * @param {*} field The data field.\n   * @return {number} The mean (average) of the values.\n   */\n  // @ts-ignore\n  mean: (field) => op('mean', field),\n\n  /**\n   * Aggregate function for the average (mean) value.\n   * @param {*} field The data field.\n   * @return {number} The average (mean) of the values.\n   */\n  // @ts-ignore\n  average: (field) => op('average', field),\n\n  /**\n   * Aggregate function for the sample variance.\n   * @param {*} field The data field.\n   * @return {number} The sample variance of the values.\n   */\n  // @ts-ignore\n  variance: (field) => op('variance', field),\n\n  /**\n   * Aggregate function for the population variance.\n   * @param {*} field The data field.\n   * @return {number} The population variance of the values.\n   */\n  // @ts-ignore\n  variancep: (field) => op('variancep', field),\n\n  /**\n   * Aggregate function for the sample standard deviation.\n   * @param {*} field The data field.\n   * @return {number} The sample standard deviation of the values.\n   */\n  // @ts-ignore\n  stdev: (field) => op('stdev', field),\n\n  /**\n   * Aggregate function for the population standard deviation.\n   * @param {*} field The data field.\n   * @return {number} The population standard deviation of the values.\n   */\n  // @ts-ignore\n  stdevp: (field) => op('stdevp', field),\n\n  /**\n   * Aggregate function for the minimum value.\n   * @template T\n   * @param {T} field The data field.\n   * @return {T} The minimum value.\n   */\n  // @ts-ignore\n  min: (field) => op('min', field),\n\n  /**\n   * Aggregate function for the maximum value.\n   * @template T\n   * @param {T} field The data field.\n   * @return {T} The maximum value.\n   */\n  // @ts-ignore\n  max: (field) => op('max', field),\n\n  /**\n   * Aggregate function to compute the quantile boundary\n   * of a data field for a probability threshold.\n   * @param {*} field The data field.\n   * @param {number} p The probability threshold.\n   * @return {number} The quantile value.\n   */\n  // @ts-ignore\n  quantile: (field, p) => op('quantile', field, p),\n\n  /**\n   * Aggregate function for the median value.\n   * This is a shorthand for the 0.5 quantile value.\n   * @param {*} field The data field.\n   * @return {number} The median value.\n   */\n  // @ts-ignore\n  median: (field) => op('median', field),\n\n  /**\n   * Aggregate function for the sample covariance between two variables.\n   * @param {*} field1 The first data field.\n   * @param {*} field2 The second data field.\n   * @return {number} The sample covariance of the values.\n   */\n  // @ts-ignore\n  covariance: (field1, field2) => op('covariance', [field1, field2]),\n\n  /**\n   * Aggregate function for the population covariance between two variables.\n   * @param {*} field1 The first data field.\n   * @param {*} field2 The second data field.\n   * @return {number} The population covariance of the values.\n   */\n  // @ts-ignore\n  covariancep: (field1, field2) => op('covariancep', [field1, field2]),\n\n  /**\n   * Aggregate function for the product-moment correlation between two variables.\n   * To instead compute a rank correlation, compute the average ranks for each\n   * variable and then apply this function to the result.\n   * @param {*} field1 The first data field.\n   * @param {*} field2 The second data field.\n   * @return {number} The correlation between the field values.\n   */\n  // @ts-ignore\n  corr: (field1, field2) => op('corr', [field1, field2]),\n\n  /**\n   * Aggregate function for calculating a binning scheme in terms of\n   * the minimum bin boundary, maximum bin boundary, and step size.\n   * @param {*} field The data field.\n   * @param {number} [maxbins=15] The maximum number of allowed bins.\n   * @param {boolean} [nice=true] Flag indicating if the bin min and max\n   *  should snap to \"nice\" human-friendly values.\n   * @param {number} [minstep] The minimum allowed step size between bins.\n   * @param {number} [step] The exact step size to use between bins.\n   *  If specified, the maxbins and minstep arguments are ignored.\n   * @return {[number, number, number]} The bin [min, max, and step] values.\n   */\n  // @ts-ignore\n  bins: (field, maxbins, nice, minstep, step) => op(\n    'bins',\n    field,\n    [maxbins, nice, minstep, step]\n  ),\n\n  /**\n   * Window function to assign consecutive row numbers, starting from 1.\n   * @return {number} The row number value.\n   */\n  // @ts-ignore\n  row_number: () => op('row_number'),\n\n  /**\n   * Window function to assign a rank to each value in a group, starting\n   * from 1. Peer values are assigned the same rank. Subsequent ranks\n   * reflect the number of prior values: if the first two values tie for\n   * rank 1, the third value is assigned rank 3.\n   * @return {number} The rank value.\n   */\n  // @ts-ignore\n  rank: () => op('rank'),\n\n  /**\n   * Window function to assign a fractional (average) rank to each value in\n   * a group, starting from 1. Peer values are assigned the average of their\n   * indices: if the first two values tie, both will be assigned rank 1.5.\n   * @return {number} The peer-averaged rank value.\n   */\n  // @ts-ignore\n  avg_rank: () => op('avg_rank'),\n\n  /**\n   * Window function to assign a dense rank to each value in a group,\n   * starting from 1. Peer values are assigned the same rank. Subsequent\n   * ranks do not reflect the number of prior values: if the first two\n   * values tie for rank 1, the third value is assigned rank 2.\n   * @return {number} The dense rank value.\n   */\n  // @ts-ignore\n  dense_rank: () => op('dense_rank'),\n\n  /**\n   * Window function to assign a percentage rank to each value in a group.\n   * The percent is calculated as (rank - 1) / (group_size - 1).\n   * @return {number} The percentage rank value.\n   */\n  // @ts-ignore\n  percent_rank: () => op('percent_rank'),\n\n  /**\n   * Window function to assign a cumulative distribution value between 0 and 1\n   * to each value in a group.\n   * @return {number} The cumulative distribution value.\n   */\n  // @ts-ignore\n  cume_dist: () => op('cume_dist'),\n\n  /**\n   * Window function to assign a quantile (e.g., percentile) value to each\n   * value in a group. Accepts an integer parameter indicating the number of\n   * buckets to use (e.g., 100 for percentiles, 5 for quintiles).\n   * @param {number} num The number of buckets for ntile calculation.\n   * @return {number} The quantile value.\n   */\n  // @ts-ignore\n  ntile: (num) => op('ntile', null, num),\n\n  /**\n   * Window function to assign a value that precedes the current value by\n   * a specified number of positions. If no such value exists, returns a\n   * default value instead.\n   * @template T\n   * @param {T} field The data field.\n   * @param {number} [offset=1] The lag offset from the current value.\n   * @param {T} [defaultValue=undefined] The default value.\n   * @return {T} The lagging value.\n   */\n  // @ts-ignore\n  lag: (field, offset, defaultValue) => op('lag', field, [offset, defaultValue]),\n\n  /**\n   * Window function to assign a value that follows the current value by\n   * a specified number of positions. If no such value exists, returns a\n   * default value instead.\n   * @template T\n   * @param {T} field The data field.\n   * @param {number} [offset=1] The lead offset from the current value.\n   * @param {T} [defaultValue=undefined] The default value.\n   * @return {T} The leading value.\n   */\n  // @ts-ignore\n  lead: (field, offset, defaultValue) => op('lead', field, [offset, defaultValue]),\n\n  /**\n   * Window function to assign the first value in a sliding window frame.\n   * @template T\n   * @param {T} field The data field.\n   * @return {T} The first value in the current frame.\n   */\n  // @ts-ignore\n  first_value: (field) => op('first_value', field),\n\n  /**\n   * Window function to assign the last value in a sliding window frame.\n   * @template T\n   * @param {T} field The data field.\n   * @return {T} The last value in the current frame.\n   */\n  // @ts-ignore\n  last_value: (field) => op('last_value', field),\n\n  /**\n   * Window function to assign the nth value in a sliding window frame\n   * (counting from 1), or undefined if no such value exists.\n   * @template T\n   * @param {T} field The data field.\n   * @param {number} nth The nth position, starting from 1.\n   * @return {T} The nth value in the current frame.\n   */\n  // @ts-ignore\n  nth_value: (field, nth) => op('nth_value', field, nth),\n\n  /**\n   * Window function to fill in missing values with preceding values.\n   * @template T\n   * @param {T} field The data field.\n   * @param {T} [defaultValue=undefined] The default value.\n   * @return {T} The current value if valid, otherwise the first preceding\n   *  valid value. If no such value exists, returns the default value.\n   */\n  // @ts-ignore\n  fill_down: (field, defaultValue) => op('fill_down', field, defaultValue),\n\n  /**\n   * Window function to fill in missing values with subsequent values.\n   * @template T\n   * @param {T} field The data field.\n   * @param {T} [defaultValue=undefined] The default value.\n   * @return {T} The current value if valid, otherwise the first subsequent\n   *  valid value. If no such value exists, returns the default value.\n   */\n  // @ts-ignore\n  fill_up: (field, defaultValue) => op('fill_up', field, defaultValue)\n};\n","export function error(message, cause) {\n  // @ts-ignore\n  throw Error(message, { cause });\n}\n","/**\n * @param {*} value\n * @returns {value is Function}\n */\nexport function isFunction(value) {\n  return typeof value === 'function';\n}\n","import { isFunction } from './is-function.js';\n\nexport function repeat(reps, value) {\n  const result = Array(reps);\n  if (isFunction(value)) {\n    for (let i = 0; i < reps; ++i) {\n      result[i] = value(i);\n    }\n  } else {\n    result.fill(value);\n  }\n  return result;\n}\n","import { isArray } from './is-array.js';\nimport { isDate } from './is-date.js';\nimport { isRegExp } from './is-regexp.js';\nimport { isTypedArray } from './is-typed-array.js';\n\nexport function key(value) {\n  const type = typeof value;\n  return type === 'string' ? `\"${value}\"`\n    : type !== 'object' || !value ? value\n    : isDate(value) ? +value\n    : isArray(value) || isTypedArray(value) ? `[${value.map(key)}]`\n    : isRegExp(value) ? value + ''\n    : objectKey(value);\n}\n\nfunction objectKey(value) {\n  let s = '{';\n  let i = -1;\n  for (const k in value) {\n    if (++i > 0) s += ',';\n    s += `\"${k}\":${key(value[k])}`;\n  }\n  s += '}';\n  return s;\n}\n\nexport function keyFunction(get, nulls) {\n  const n = get.length;\n  return n === 1\n    ? (row, data) => key(get[0](row, data))\n    : (row, data) => {\n        let s = '';\n        for (let i = 0; i < n; ++i) {\n          if (i > 0) s += '|';\n          const v = get[i](row, data);\n          if (nulls && (v == null || v !== v)) return null;\n          s += key(v);\n        }\n        return s;\n      };\n}\n","export function noop() {}\n","import { bins } from '../util/bins.js';\nimport { distinctMap } from '../util/distinct-map.js';\nimport { isBigInt } from '../util/is-bigint.js';\nimport { noop } from '../util/no-op.js';\nimport { NULL } from '../util/null.js';\nimport { product } from '../util/product.js';\n\n/**\n * Initialize an aggregate operator.\n */\nfunction initOp(op) {\n  op.init = op.init || noop;\n  op.add = op.add || noop;\n  op.rem = op.rem || noop;\n  return op;\n}\n\nfunction initProduct(s, value) {\n  s.product_v = false;\n  return s.product = value;\n}\n\n/**\n * Initialize an aggregate operator.\n * @callback AggregateInit\n * @param {object} state The aggregate state object.\n * @return {void}\n */\n\n/**\n * Add a value to an aggregate operator.\n * @callback AggregateAdd\n * @param {object} state The aggregate state object.\n * @param {*} value The value to add.\n * @return {void}\n */\n\n/**\n * Remove a value from an aggregate operator.\n * @callback AggregateRem\n * @param {object} state The aggregate state object.\n * @param {*} value The value to remove.\n * @return {void}\n */\n\n/**\n * Retrive an output value from an aggregate operator.\n * @callback AggregateValue\n * @param {object} state The aggregate state object.\n * @return {*} The output value.\n */\n\n/**\n * An operator instance for an aggregate function.\n * @typedef {object} AggregateOperator\n * @property {AggregateInit} init Initialize the operator.\n * @property {AggregateAdd} [add] Add a value to the operator state.\n * @property {AggregateRem} [rem] Remove a value from the operator state.\n * @property {AggregateValue} value Retrieve an output value.\n */\n\n/**\n * Create a new aggregate operator instance.\n * @callback AggregateCreate\n * @param {...any} params The aggregate operator parameters.\n * @return {AggregateOperator} The instantiated aggregate operator.\n */\n\n/**\n * An operator definition for an aggregate function.\n * @typedef {object} AggregateDef\n * @property {AggregateCreate} create Create a new operator instance.\n * @property {number[]} param Two-element array containing the\n *  counts of input fields and additional parameters.\n * @property {string[]} [req] Names of operators required by this one.\n * @property {string[]} [stream] Names of operators required by this one\n *  for streaming operations (value removes).\n */\n\n/**\n * Aggregate operator definitions.\n */\nexport const aggregateFunctions = {\n  /** @type {AggregateDef} */\n  count: {\n    create: () => initOp({\n      value: s => s.count\n    }),\n    param: []\n  },\n\n  /** @type {AggregateDef} */\n  array_agg: {\n    create: () => initOp({\n      init: s => s.values = true,\n      value: s => s.list.values(s.stream)\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  object_agg: {\n    create: () => initOp({\n      init:  s => s.values = true,\n      value: s => Object.fromEntries(s.list.values())\n    }),\n    param: [2]\n  },\n\n  /** @type {AggregateDef} */\n  map_agg: {\n    create: () => initOp({\n      init:  s => s.values = true,\n      value: s => new Map(s.list.values())\n    }),\n    param: [2]\n  },\n\n  /** @type {AggregateDef} */\n  entries_agg: {\n    create: () => initOp({\n      init:  s => s.values = true,\n      value: s => s.list.values(s.stream)\n    }),\n    param: [2]\n  },\n\n  /** @type {AggregateDef} */\n  any: {\n    create: () => initOp({\n      add: (s, v) => { if (s.any == null) s.any = v; },\n      value: s => s.valid ? s.any : NULL\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  valid: {\n    create: () => initOp({\n      value: s => s.valid\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  invalid: {\n    create: () => initOp({\n      value: s => s.count - s.valid\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  distinct: {\n    create: () => ({\n      init: s => s.distinct = distinctMap(),\n      value: s => s.distinct.count() + (s.valid === s.count ? 0 : 1),\n      add: (s, v) => s.distinct.increment(v),\n      rem: (s, v) => s.distinct.decrement(v)\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  array_agg_distinct: {\n    create: () => initOp({\n      value: s => s.distinct.values()\n    }),\n    param: [1],\n    req: ['distinct']\n  },\n\n  /** @type {AggregateDef} */\n  mode: {\n    create: () => initOp({\n      value: s => {\n        let mode = NULL;\n        let max = 0;\n        s.distinct.forEach((value, count) => {\n          if (count > max) {\n            max = count;\n            mode = value;\n          }\n        });\n        return mode;\n      }\n    }),\n    param: [1],\n    req: ['distinct']\n  },\n\n  /** @type {AggregateDef} */\n  sum: {\n    create: () => ({\n      init:  s => s.sum = 0,\n      value: s => s.valid ? s.sum : NULL,\n      add: (s, v) => isBigInt(v)\n        ? (s.sum === 0 ? s.sum = v : s.sum += v)\n        : s.sum += +v,\n      rem: (s, v) => s.sum -= v\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  product: {\n    create: () => ({\n      init:  s => initProduct(s, 1),\n      value: s => s.valid\n        ? (\n            s.product_v\n              ? initProduct(s, product(s.list.values()))\n              : s.product\n          )\n        : undefined,\n      add: (s, v) => isBigInt(v)\n        ? (s.product === 1 ? s.product = v : s.product *= v)\n        : s.product *= v,\n      rem: (s, v) => (v == 0 || v === Infinity || v === -Infinity)\n        ? s.product_v = true\n        : s.product /= v\n    }),\n    param: [1],\n    stream: ['array_agg']\n  },\n\n  /** @type {AggregateDef} */\n  mean: {\n    create: () => ({\n      init: s => s.mean = 0,\n      value: s => s.valid ? s.mean : NULL,\n      add: (s, v) => {\n        s.mean_d = v - s.mean;\n        s.mean += s.mean_d / s.valid;\n      },\n      rem: (s, v) => {\n        s.mean_d = v - s.mean;\n        s.mean -= s.valid ? s.mean_d / s.valid : s.mean;\n      }\n    }),\n    param: [1]\n  },\n\n  /** @type {AggregateDef} */\n  average: {\n    create: () => initOp({\n      value: s => s.valid ? s.mean : NULL\n    }),\n    param: [1],\n    req: ['mean']\n  },\n\n  /** @type {AggregateDef} */\n  variance: {\n    create: () => ({\n      init:  s => s.dev = 0,\n      value: s => s.valid > 1 ? s.dev / (s.valid - 1) : NULL,\n      add: (s, v) => s.dev += s.mean_d * (v - s.mean),\n      rem: (s, v) => s.dev -= s.mean_d * (v - s.mean)\n    }),\n    param: [1],\n    req: ['mean']\n  },\n\n  /** @type {AggregateDef} */\n  variancep: {\n    create: () => initOp({\n      value: s => s.valid > 1 ? s.dev / s.valid : NULL\n    }),\n    param: [1],\n    req: ['variance']\n  },\n\n  /** @type {AggregateDef} */\n  stdev: {\n    create: () => initOp({\n      value: s => s.valid > 1 ? Math.sqrt(s.dev / (s.valid - 1)) : NULL\n    }),\n    param: [1],\n    req: ['variance']\n  },\n\n  /** @type {AggregateDef} */\n  stdevp: {\n    create: () => initOp({\n      value: s => s.valid > 1 ? Math.sqrt(s.dev / s.valid) : NULL\n    }),\n    param: [1],\n    req: ['variance']\n  },\n\n  /** @type {AggregateDef} */\n  min: {\n    create: () => ({\n      init:  s => s.min = NULL,\n      value: s => s.min = (Number.isNaN(s.min) ? s.list.min() : s.min),\n      add: (s, v) => { if (v < s.min || s.min === NULL) s.min = v; },\n      rem: (s, v) => { if (v <= s.min) s.min = NaN; }\n    }),\n    param: [1],\n    stream: ['array_agg']\n  },\n\n  /** @type {AggregateDef} */\n  max: {\n    create: () => ({\n      init:  s => s.max = NULL,\n      value: s => s.max = (Number.isNaN(s.max) ? s.list.max() : s.max),\n      add: (s, v) => { if (v > s.max || s.max === NULL) s.max = v; },\n      rem: (s, v) => { if (v >= s.max) s.max = NaN; }\n    }),\n    param: [1],\n    stream: ['array_agg']\n  },\n\n  /** @type {AggregateDef} */\n  quantile: {\n    create: (p) => initOp({\n      value: s => s.list.quantile(p)\n    }),\n    param: [1, 1],\n    req: ['array_agg']\n  },\n\n  /** @type {AggregateDef} */\n  median: {\n    create: () => initOp({\n      value: s => s.list.quantile(0.5)\n    }),\n    param: [1],\n    req: ['array_agg']\n  },\n\n  /** @type {AggregateDef} */\n  covariance: {\n    create: () => ({\n      init:  s => {\n        s.cov = s.mean_x = s.mean_y = s.dev_x = s.dev_y = 0;\n      },\n      value: s => s.valid > 1 ? s.cov / (s.valid - 1) : NULL,\n      add: (s, x, y) => {\n        const dx = x - s.mean_x;\n        const dy = y - s.mean_y;\n        s.mean_x += dx / s.valid;\n        s.mean_y += dy / s.valid;\n        const dy2 = y - s.mean_y;\n        s.dev_x += dx * (x - s.mean_x);\n        s.dev_y += dy * dy2;\n        s.cov += dx * dy2;\n      },\n      rem: (s, x, y) => {\n        const dx = x - s.mean_x;\n        const dy = y - s.mean_y;\n        s.mean_x -= s.valid ? dx / s.valid : s.mean_x;\n        s.mean_y -= s.valid ? dy / s.valid : s.mean_y;\n        const dy2 = y - s.mean_y;\n        s.dev_x -= dx * (x - s.mean_x);\n        s.dev_y -= dy * dy2;\n        s.cov -= dx * dy2;\n      }\n    }),\n    param: [2]\n  },\n\n  /** @type {AggregateDef} */\n  covariancep: {\n    create: () => initOp({\n      value: s => s.valid > 1 ? s.cov / s.valid : NULL\n    }),\n    param: [2],\n    req: ['covariance']\n  },\n\n  /** @type {AggregateDef} */\n  corr: {\n    create: () => initOp({\n      value: s => s.valid > 1\n        ? s.cov / (Math.sqrt(s.dev_x) * Math.sqrt(s.dev_y))\n        : NULL\n    }),\n    param: [2],\n    req: ['covariance']\n  },\n\n  /** @type {AggregateDef} */\n  bins: {\n    create: (maxbins, nice, minstep, step) => initOp({\n      value: s => bins(s.min, s.max, maxbins, nice, minstep, step)\n    }),\n    param: [1, 4],\n    req: ['min', 'max']\n  }\n};\n","import { key } from './key-function.js';\n\nexport function distinctMap() {\n  const map = new Map();\n  return {\n    count() {\n      return map.size;\n    },\n    values() {\n      return Array.from(map.values(), _ => _.v);\n    },\n    increment(v) {\n      const k = key(v);\n      const e = map.get(k);\n      e ? ++e.n : map.set(k, { v, n: 1 });\n    },\n    decrement(v) {\n      const k = key(v);\n      const e = map.get(k);\n      e.n === 1 ? map.delete(k) : --e.n;\n    },\n    forEach(fn) {\n      map.forEach(({ v, n }) => fn(v, n));\n    }\n  };\n}\n","export function product(values, start = 0, stop = values.length) {\n  let prod = values[start++];\n\n  for (let i = start; i < stop; ++i) {\n    prod *= values[i];\n  }\n\n  return prod;\n}\n","export function bins(min, max, maxbins = 15, nice = true, minstep = 0, step) {\n  const base = 10;\n  const logb = Math.LN10;\n\n  if (step == null) {\n    const level = Math.ceil(Math.log(maxbins) / logb);\n    const span = (max - min) || Math.abs(min) || 1;\n    const div = [5, 2];\n\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    while (Math.ceil(span / step) > maxbins) {\n      step *= base;\n    }\n\n    // decrease step size if it stays within maxbins\n    const n = div.length;\n    for (let i = 0; i < n; ++i) {\n      const v = step / div[i];\n      if (v >= minstep && span / v <= maxbins) {\n        step = v;\n      }\n    }\n  }\n\n  // snap to \"nice\" boundaries\n  if (nice) {\n    let v = Math.log(step);\n    const precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n    const eps = Math.pow(base, -precision - 1);\n    v = Math.floor(min / step + eps) * step;\n    min = min < v ? v - step : v;\n    max = Math.ceil(max / step) * step;\n  }\n\n  return [\n    min,\n    max === min ? min + step : max,\n    step\n  ];\n}\n","import { error } from '../util/error.js';\nimport { isValid } from '../util/is-valid.js';\nimport { noop } from '../util/no-op.js';\nimport { NULL } from '../util/null.js';\n\n/**\n * Initialize a window operator.\n * @callback WindowInit\n * @return {void}\n */\n\n/**\n * A storage object for the state of the window.\n * @typedef {import('../verbs/window/window-state.js').windowState} WindowState\n */\n\n/**\n * Retrieve an output value from a window operator.\n * @callback WindowValue\n * @param {WindowState} state The window state object.\n * @return {*} The output value.\n */\n\n/**\n * Initialize an aggregate operator.\n * @typedef {import('./aggregate-functions.js').AggregateInit} AggregateInit\n */\n\n/**\n * Retrive an output value from an aggregate operator.\n * @typedef {import('./aggregate-functions.js').AggregateValue} AggregateValue\n */\n\n/**\n * An operator instance for a window function.\n * @typedef {object} WindowOperator\n * @property {AggregateInit} init Initialize the operator.\n * @property {AggregateValue} value Retrieve an output value.\n */\n\n/**\n * Create a new window operator instance.\n * @callback WindowCreate\n * @param {...any} params The aggregate operator parameters.\n * @return {WindowOperator} The instantiated window operator.\n */\n\n/**\n * Create a new aggregate operator instance.\n * @typedef {import('./aggregate-functions.js').AggregateCreate} AggregateCreate\n */\n\n/**\n * An operator definition for a window function.\n * @typedef {object} WindowDef\n * @property {AggregateCreate} create Create a new operator instance.\n * @property {number[]} param Two-element array containing the\n *  counts of input fields and additional parameters.\n */\n\nconst rank = {\n  create() {\n    let rank;\n    return {\n      init: () => rank = 1,\n      value: w => {\n        const i = w.index;\n        return (i && !w.peer(i)) ? (rank = i + 1) : rank;\n      }\n    };\n  },\n  param: []\n};\n\nconst cume_dist = {\n  create() {\n    let cume;\n    return {\n      init: () => cume = 0,\n      value: w => {\n        const { index, peer, size } = w;\n        let i = index;\n        if (cume < i) {\n          while (i + 1 < size && peer(i + 1)) ++i;\n          cume = i;\n        }\n        return (1 + cume) / size;\n      }\n    };\n  },\n  param: []\n};\n\n/**\n * Window operator definitions.\n */\nexport const windowFunctions = {\n  /** @type {WindowDef} */\n  row_number: {\n    create() {\n      return {\n        init: noop,\n        value: w => w.index + 1\n      };\n    },\n    param: []\n  },\n\n  /** @type {WindowDef} */\n  rank,\n\n  /** @type {WindowDef} */\n  avg_rank: {\n    create() {\n      let j, rank;\n      return {\n        init: () => (j = -1, rank = 1),\n        value: w => {\n          const i = w.index;\n          if (i >= j) {\n            for (rank = j = i + 1; w.peer(j); rank += ++j);\n            rank /= (j - i);\n          }\n          return rank;\n        }\n      };\n    },\n    param: []\n  },\n\n  /** @type {WindowDef} */\n  dense_rank: {\n    create() {\n      let drank;\n      return {\n        init: () => drank = 1,\n        value: w => {\n          const i = w.index;\n          return (i && !w.peer(i)) ? ++drank : drank;\n        }\n      };\n    },\n    param: []\n  },\n\n  /** @type {WindowDef} */\n  percent_rank: {\n    create() {\n      const { init, value } = rank.create();\n      return {\n        init,\n        value: w => (value(w) - 1) / (w.size - 1)\n      };\n    },\n    param: []\n  },\n\n  /** @type {WindowDef} */\n  cume_dist,\n\n  /** @type {WindowDef} */\n  ntile: {\n    create(num) {\n      num = +num;\n      if (!(num > 0)) error('ntile num must be greater than zero.');\n      const { init, value } = cume_dist.create();\n      return {\n        init,\n        value: w => Math.ceil(num * value(w))\n      };\n    },\n    param: [0, 1]\n  },\n\n  /** @type {WindowDef} */\n  lag: {\n    create(offset, defaultValue = NULL) {\n      offset = +offset || 1;\n      return {\n        init: noop,\n        value: (w, f) => {\n          const i = w.index - offset;\n          return i >= 0 ? w.value(i, f) : defaultValue;\n        }\n      };\n    },\n    param: [1, 2]\n  },\n\n  /** @type {WindowDef} */\n  lead: {\n    create(offset, defaultValue = NULL) {\n      offset = +offset || 1;\n      return {\n        init: noop,\n        value: (w, f) => {\n          const i = w.index + offset;\n          return i < w.size ? w.value(i, f) : defaultValue;\n        }\n      };\n    },\n    param: [1, 2]\n  },\n\n  /** @type {WindowDef} */\n  first_value: {\n    create() {\n      return {\n        init: noop,\n        value: (w, f) => w.value(w.i0, f)\n      };\n    },\n    param: [1]\n  },\n\n  /** @type {WindowDef} */\n  last_value: {\n    create() {\n      return {\n        init: noop,\n        value: (w, f) => w.value(w.i1 - 1, f)\n      };\n    },\n    param: [1]\n  },\n\n  /** @type {WindowDef} */\n  nth_value: {\n    create(nth) {\n      nth = +nth;\n      if (!(nth > 0)) error('nth_value nth must be greater than zero.');\n      return {\n        init: noop,\n        value: (w, f) => {\n          const i = w.i0 + (nth - 1);\n          return i < w.i1 ? w.value(i, f) : NULL;\n        }\n      };\n    },\n    param: [1, 1]\n  },\n\n  /** @type {WindowDef} */\n  fill_down: {\n    create(defaultValue = NULL) {\n      let value;\n      return {\n        init: () => value = defaultValue,\n        value: (w, f) => {\n          const v = w.value(w.index, f);\n          return isValid(v) ? (value = v) : value;\n        }\n      };\n    },\n    param: [1, 1]\n  },\n\n  /** @type {WindowDef} */\n  fill_up: {\n    create(defaultValue = NULL) {\n      let value, idx;\n      return {\n        init: () => (value = defaultValue, idx = -1),\n        value: (w, f) => w.index <= idx ? value\n          : (idx = find(w, f, w.index)) >= 0 ? (value = w.value(idx, f))\n          : (idx = w.size, value = defaultValue)\n      };\n    },\n    param: [1, 1]\n  }\n};\n\nfunction find(w, f, i) {\n  for (const n = w.size; i < n; ++i) {\n    if (isValid(w.value(i, f))) return i;\n  }\n  return -1;\n}\n","import { aggregateFunctions } from './aggregate-functions.js';\nimport { windowFunctions } from './window-functions.js';\nimport { functions } from './functions/index.js';\n\nexport { aggregateFunctions } from './aggregate-functions.js';\nexport { windowFunctions } from './window-functions.js';\nexport { functions } from './functions/index.js';\n\n/**\n * Check if an aggregate function with the given name exists.\n * @param {string} name The name of the aggregate function.\n * @return {boolean} True if found, false otherwise.\n */\nexport function hasAggregate(name) {\n  return Object.hasOwn(aggregateFunctions, name);\n}\n\n/**\n * Check if a window function with the given name exists.\n * @param {string} name The name of the window function.\n * @return {boolean} True if found, false otherwise.\n */\nexport function hasWindow(name) {\n  return Object.hasOwn(windowFunctions, name);\n}\n\n/**\n * Check if an expression function with the given name exists.\n * @param {string} name The name of the function.\n * @return {boolean} True if found, false otherwise.\n */\n export function hasFunction(name) {\n  return Object.hasOwn(functions, name) || name === 'row_object';\n}\n\n/**\n * Get an aggregate function definition.\n * @param {string} name The name of the aggregate function.\n * @return {import('./aggregate-functions.js').AggregateDef}\n *  The aggregate function definition, or undefined if not found.\n */\nexport function getAggregate(name) {\n  return hasAggregate(name) && aggregateFunctions[name];\n}\n\n/**\n * Get a window function definition.\n * @param {string} name The name of the window function.\n * @return {import('./window-functions.js').WindowDef}\n *  The window function definition, or undefined if not found.\n */\nexport function getWindow(name) {\n  return hasWindow(name) && windowFunctions[name];\n}\n\n/**\n * Get an expression function definition.\n * @param {string} name The name of the function.\n * @return {Function} The function instance, or undefined if not found.\n */\nexport function getFunction(name) {\n  return hasFunction(name) && functions[name];\n}\n","// eslint-disable-next-line no-unused-vars\nexport function concat(list, fn = ((x, i) => x), delim = '') {\n  const n = list.length;\n  if (!n) return '';\n\n  let s = fn(list[0], 0);\n  for (let i = 1; i < n; ++i) {\n    s += delim + fn(list[i], i);\n  }\n\n  return s;\n}\n","export function unroll(args, code, ...lists) {\n  const v = ['_', '$'];\n  const a = v.slice(0, lists.length);\n  a.push('\"use strict\"; const '\n    + lists\n        .map((l, j) => l.map((_, i) => `${v[j]}${i} = ${v[j]}[${i}]`).join(', '))\n        .join(', ')\n    + `; return (${args}) => ${code};`\n  );\n  return Function(...a)(...lists);\n}\n","export function ascending(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import { isBigInt } from './is-bigint.js';\n\nexport function toNumeric(value) {\n  return isBigInt(value) ? value : +value;\n}\n","import { ascending } from './ascending.js';\nimport { max } from './max.js';\nimport { min } from './min.js';\nimport { quantile } from './quantile.js';\n\nexport class ValueList {\n  constructor(values) {\n    this._values = values || [];\n    this._sorted = null;\n    this._start = 0;\n  }\n\n  values(copy) {\n    if (this._start) {\n      this._values = this._values.slice(this._start);\n      this._start = 0;\n    }\n    return copy\n      ? this._values.slice()\n      : this._values;\n  }\n\n  add(value) {\n    this._values.push(value);\n    this._sorted = null;\n  }\n\n  rem() {\n    this._start += 1;\n    this._sorted = null;\n  }\n\n  min() {\n    return this._sorted && this._sorted.length\n      ? this._sorted[0]\n      : min(this._values, this._start);\n  }\n\n  max() {\n    return this._sorted && this._sorted.length\n      ? this._sorted[this._sorted.length - 1]\n      : max(this._values, this._start);\n  }\n\n  quantile(p) {\n    if (!this._sorted) {\n      this._sorted = this.values(true);\n      this._sorted.sort(ascending);\n    }\n    return quantile(this._sorted, p);\n  }\n}\n","import { NULL } from './null.js';\n\nexport function min(values, start = 0, stop = values.length) {\n  let min = stop ? values[start++] : NULL;\n\n  for (let i = start; i < stop; ++i) {\n    if (min > values[i]) {\n      min = values[i];\n    }\n  }\n\n  return min;\n}\n","import { NULL } from './null.js';\n\nexport function max(values, start = 0, stop = values.length) {\n  let max = stop ? values[start++] : NULL;\n\n  for (let i = start; i < stop; ++i) {\n    if (max < values[i]) {\n      max = values[i];\n    }\n  }\n\n  return max;\n}\n","import { isBigInt } from './is-bigint.js';\nimport { NULL } from './null.js';\nimport { toNumeric } from './to-numeric.js';\n\nexport function quantile(values, p) {\n  const n = values.length;\n\n  if (!n) return NULL;\n  if ((p = +p) <= 0 || n < 2) return toNumeric(values[0]);\n  if (p >= 1) return toNumeric(values[n - 1]);\n\n  const i = (n - 1) * p;\n  const i0 = Math.floor(i);\n  const v0 = toNumeric(values[i0]);\n  return isBigInt(v0)\n    ? v0\n    // @ts-ignore\n    : v0 + (toNumeric(values[i0 + 1]) - v0) * (i - i0);\n}\n","/**\n * Abstract class for custom aggregation operations.\n */\nexport class Reducer {\n  constructor(outputs) {\n    this._outputs = outputs;\n  }\n\n  size() {\n    return this._outputs.length;\n  }\n\n  outputs() {\n    return this._outputs;\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  init(columns) {\n    return {};\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  add(state, row, data) {\n    // no-op, subclasses should override\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  rem(state, row, data) {\n    // no-op, subclasses should override\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  write(state, values, index) {\n  }\n}\n","import { getAggregate } from '../../op/index.js';\nimport { concat } from '../../util/concat.js';\nimport { error } from '../../util/error.js';\nimport { isValid } from '../../util/is-valid.js';\nimport { unroll } from '../../util/unroll.js';\nimport { ValueList } from '../../util/value-list.js';\nimport { Reducer } from './reducer.js';\n\nconst update = (ops, args, fn) => unroll(\n  args,\n  '{' + concat(ops, (_, i) => `_${i}.${fn}(${args});`) + '}',\n  ops\n);\n\nexport function fieldReducer(oplist, stream) {\n  const { ops, output } = expand(oplist, stream);\n  const fields = oplist[0].fields;\n  const n = fields.length;\n  const cls = n === 0 ? FieldReducer\n    : n === 1 ? Field1Reducer\n    : n === 2 ? Field2Reducer\n    : error('Unsupported field count: ' + n);\n  // @ts-ignore\n  return new cls(fields, ops, output, stream);\n}\n\nfunction expand(oplist, stream) {\n  const has = {};\n  const ops = [];\n\n  function add(name, params = []) {\n    // check key\n    const key = name + ':' + params;\n    if (has[key]) return has[key];\n\n    // get op instance\n    const def = getAggregate(name);\n    const op = def.create(...params);\n\n    // add required dependencies\n    if (stream < 0 && def.stream) {\n      def.stream.forEach(name => add(name, []));\n    }\n    if (def.req) {\n      def.req.forEach(name => add(name, []));\n    }\n\n    // update state\n    has[key] = op;\n    ops.push(op);\n\n    return op;\n  }\n\n  const output = oplist.map(item => {\n    const op = add(item.name, item.params);\n    op.output = item.id;\n    return op;\n  });\n\n  return { ops, output };\n}\n\nclass FieldReducer extends Reducer {\n  constructor(fields, ops, outputs, stream) {\n    super(outputs);\n    this._op = ops;\n    this._fields = fields;\n    this._stream = !!stream;\n  }\n\n  init() {\n    const state = { count: 0, valid: 0, stream: this._stream };\n    this._op.forEach(op => op.init(state));\n\n    // value list requested\n    if (state.values) {\n      state.list = new ValueList();\n    }\n\n    return state;\n  }\n\n  write(state, values, index) {\n    const op = this._outputs;\n    const n = op.length;\n    for (let i = 0; i < n; ++i) {\n      values[op[i].output][index] = op[i].value(state);\n    }\n    return 1;\n  }\n\n  _add() {\n  }\n\n  _rem() {\n  }\n\n  add(state) {\n    ++state.count;\n  }\n\n  rem(state) {\n    --state.count;\n  }\n}\n\nclass Field1Reducer extends FieldReducer {\n  constructor(fields, ops, outputs, stream) {\n    super(fields, ops, outputs, stream);\n\n    // unroll op invocations for performance\n    const args = ['state', 'v1', 'v2'];\n    this._add = update(ops, args, 'add');\n    this._rem = update(ops, args, 'rem');\n  }\n\n  add(state, row, data) {\n    const value = this._fields[0](row, data);\n    ++state.count;\n    if (isValid(value)) {\n      ++state.valid;\n      if (state.list) state.list.add(value);\n      this._add(state, value);\n    }\n  }\n\n  rem(state, row, data) {\n    const value = this._fields[0](row, data);\n    --state.count;\n    if (isValid(value)) {\n      --state.valid;\n      if (state.list) state.list.rem();\n      this._rem(state, value);\n    }\n  }\n}\n\nclass Field2Reducer extends FieldReducer {\n  constructor(fields, ops, outputs, stream) {\n    super(fields, ops, outputs, stream);\n\n    // unroll op invocations for performance\n    const args = ['state', 'v1', 'v2'];\n    this._add = update(ops, args, 'add');\n    this._rem = update(ops, args, 'rem');\n  }\n\n  add(state, row, data) {\n    const value1 = this._fields[0](row, data);\n    const value2 = this._fields[1](row, data);\n    ++state.count;\n    if (isValid(value1) && isValid(value2)) {\n      ++state.valid;\n      if (state.list) state.list.add([value1, value2]);\n      this._add(state, value1, value2);\n    }\n  }\n\n  rem(state, row, data) {\n    const value1 = this._fields[0](row, data);\n    const value2 = this._fields[1](row, data);\n    --state.count;\n    if (isValid(value1) && isValid(value2)) {\n      --state.valid;\n      if (state.list) state.list.rem();\n      this._rem(state, value1, value2);\n    }\n  }\n}\n","import { repeat } from '../../util/repeat.js';\nimport { fieldReducer } from './field-reducer.js';\n\nexport function aggregateGet(table, ops, get) {\n  if (ops.length) {\n    const data = table.data();\n    const { keys } = table.groups() || {};\n    const result = aggregate(table, ops);\n    const op = keys\n      ? (name, row) => result[name][keys[row]]\n      : name => result[name][0];\n    get = get.map(f => row => f(row, data, op));\n  }\n\n  return get;\n}\n\nexport function aggregate(table, ops, result) {\n  if (!ops.length) return result; // early exit\n\n  // instantiate aggregators and result store\n  const aggrs = reducers(ops);\n  const groups = table.groups();\n  const size = groups ? groups.size : 1;\n  result = result || repeat(ops.length, () => Array(size));\n\n  // compute aggregates, extract results\n  if (size > 1) {\n    aggrs.forEach(aggr => {\n      const cells = reduceGroups(table, aggr, groups);\n      for (let i = 0; i < size; ++i) {\n        aggr.write(cells[i], result, i);\n      }\n    });\n  } else {\n    aggrs.forEach(aggr => {\n      const cell = reduceFlat(table, aggr);\n      aggr.write(cell, result, 0);\n    });\n  }\n\n  return result;\n}\n\nexport function reducers(ops, stream) {\n  const aggrs = [];\n  const fields = {};\n\n  // group operators by field inputs\n  for (const op of ops) {\n    const key = op.fields.map(f => f + '').join(',');\n    (fields[key] || (fields[key] = [])).push(op);\n  }\n\n  // generate a field reducer for each field\n  for (const key in fields) {\n    aggrs.push(fieldReducer(fields[key], stream));\n  }\n\n  return aggrs;\n}\n\nexport function reduceFlat(table, reducer) {\n  // initialize aggregation cell\n  const cell = reducer.init();\n\n  // compute aggregate values\n  // inline the following for performance:\n  // table.scan((row, data) => reducer.add(cell, row, data));\n  const data = table.data();\n  const bits = table.mask();\n\n  if (table.isOrdered()) {\n    const idx = table.indices();\n    const m = idx.length;\n    for (let i = 0; i < m; ++i) {\n      reducer.add(cell, idx[i], data);\n    }\n  } else if (bits) {\n    for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n      reducer.add(cell, i, data);\n    }\n  } else {\n    const n = table.totalRows();\n    for (let i = 0; i < n; ++i) {\n      reducer.add(cell, i, data);\n    }\n  }\n\n  return cell;\n}\n\nexport function reduceGroups(table, reducer, groups) {\n  const { keys, size } = groups;\n\n  // initialize aggregation cells\n  const cells = repeat(size, () => reducer.init());\n\n  // compute aggregate values\n  // inline the following for performance:\n  // table.scan((row, data) => reducer.add(cells[keys[row]], row, data));\n  const data = table.data();\n\n  if (table.isOrdered()) {\n    const idx = table.indices();\n    const m = idx.length;\n    for (let i = 0; i < m; ++i) {\n      const row = idx[i];\n      reducer.add(cells[keys[row]], row, data);\n    }\n  } else if (table.isFiltered()) {\n    const bits = table.mask();\n    for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n      reducer.add(cells[keys[i]], i, data);\n    }\n  } else {\n    const n = table.totalRows();\n    for (let i = 0; i < n; ++i) {\n      reducer.add(cells[keys[i]], i, data);\n    }\n  }\n\n  return cells;\n}\n\nexport function groupOutput(cols, groups) {\n  const { get, names, rows, size } = groups;\n\n  // write group values to output columns\n  const m = names.length;\n  for (let j = 0; j < m; ++j) {\n    const col = cols.add(names[j], Array(size));\n    const val = get[j];\n    for (let i = 0; i < size; ++i) {\n      col[i] = val(rows[i]);\n    }\n  }\n}\n","import { isArray } from './is-array.js';\nimport { isMap } from './is-map.js';\n\nexport function entries(value) {\n  return isArray(value) ? value\n    : isMap(value) ? value.entries()\n    : value ? Object.entries(value)\n    : [];\n}\n","export const ArrayPattern = 'ArrayPattern';\nexport const ArrowFunctionExpression = 'ArrowFunctionExpression';\nexport const FunctionExpression = 'FunctionExpression';\nexport const Identifier = 'Identifier';\nexport const Literal = 'Literal';\nexport const MemberExpression = 'MemberExpression';\nexport const ObjectExpression = 'ObjectExpression';\nexport const ObjectPattern = 'ObjectPattern';\nexport const Property = 'Property';\n\nexport const Column = 'Column';\nexport const Constant = 'Constant';\nexport const Dictionary = 'Dictionary';\nexport const Function = 'Function';\nexport const Parameter = 'Parameter';\nexport const Op = 'Op';\n","export function walk(node, ctx, visitors, parent) {\n  const visit = visitors[node.type] || visitors['Default'];\n  if (visit && visit(node, ctx, parent) === false) return;\n\n  const walker = walkers[node.type];\n  if (walker) walker(node, ctx, visitors);\n}\n\nconst unary = (node, ctx, visitors) => {\n  walk(node.argument, ctx, visitors, node);\n};\n\nconst binary = (node, ctx, visitors) => {\n  walk(node.left, ctx, visitors, node);\n  walk(node.right, ctx, visitors, node);\n};\n\nconst ternary = (node, ctx, visitors) => {\n  walk(node.test, ctx, visitors, node);\n  walk(node.consequent, ctx, visitors, node);\n  if (node.alternate) walk(node.alternate, ctx, visitors, node);\n};\n\nconst func = (node, ctx, visitors) => {\n  list(node.params, ctx, visitors, node);\n  walk(node.body, ctx, visitors, node);\n};\n\nconst call = (node, ctx, visitors) => {\n  walk(node.callee, ctx, visitors, node);\n  list(node.arguments, ctx, visitors, node);\n};\n\nconst list = (nodes, ctx, visitors, node) => {\n  nodes.forEach(item => walk(item, ctx, visitors, node));\n};\n\nconst walkers = {\n  TemplateLiteral: (node, ctx, visitors) => {\n    list(node.expressions, ctx, visitors, node);\n    list(node.quasis, ctx, visitors, node);\n  },\n  MemberExpression: (node, ctx, visitors) => {\n    walk(node.object, ctx, visitors, node);\n    walk(node.property, ctx, visitors, node);\n  },\n  CallExpression: call,\n  NewExpression: call,\n  ArrayExpression: (node, ctx, visitors) => {\n    list(node.elements, ctx, visitors, node);\n  },\n  AssignmentExpression: binary,\n  AwaitExpression: unary,\n  BinaryExpression: binary,\n  LogicalExpression: binary,\n  UnaryExpression: unary,\n  UpdateExpression: unary,\n  ConditionalExpression: ternary,\n  ObjectExpression: (node, ctx, visitors) => {\n    list(node.properties, ctx, visitors, node);\n  },\n  Property: (node, ctx, visitors) => {\n    walk(node.key, ctx, visitors, node);\n    walk(node.value, ctx, visitors, node);\n  },\n\n  ArrowFunctionExpression: func,\n  FunctionExpression: func,\n  FunctionDeclaration: func,\n\n  VariableDeclaration: (node, ctx, visitors) => {\n    list(node.declarations, ctx, visitors, node);\n  },\n  VariableDeclarator: (node, ctx, visitors) => {\n    walk(node.id, ctx, visitors, node);\n    walk(node.init, ctx, visitors, node);\n  },\n  SpreadElement: (node, ctx, visitors) => {\n    walk(node.argument, ctx, visitors, node);\n  },\n\n  BlockStatement: (node, ctx, visitors) => {\n    list(node.body, ctx, visitors, node);\n  },\n  ExpressionStatement: (node, ctx, visitors) => {\n    walk(node.expression, ctx, visitors, node);\n  },\n  IfStatement: ternary,\n  ForStatement: (node, ctx, visitors) => {\n    walk(node.init, ctx, visitors, node);\n    walk(node.test, ctx, visitors, node);\n    walk(node.update, ctx, visitors, node);\n    walk(node.body, ctx, visitors, node);\n  },\n  WhileStatement: (node, ctx, visitors) => {\n    walk(node.test, ctx, visitors, node);\n    walk(node.body, ctx, visitors, node);\n  },\n  DoWhileStatement: (node, ctx, visitors) => {\n    walk(node.body, ctx, visitors, node);\n    walk(node.test, ctx, visitors, node);\n  },\n  SwitchStatement: (node, ctx, visitors) => {\n    walk(node.discriminant, ctx, visitors, node);\n    list(node.cases, ctx, visitors, node);\n  },\n  SwitchCase: (node, ctx, visitors) => {\n    if (node.test) walk(node.test, ctx, visitors, node);\n    list(node.consequent, ctx, visitors, node);\n  },\n  ReturnStatement: unary,\n\n  Program: (node, ctx, visitors) => {\n    walk(node.body[0], ctx, visitors, node);\n  }\n};\n","import { walk } from './walk.js';\n\nfunction strip(node) {\n  delete node.start;\n  delete node.end;\n  delete node.optional;\n}\n\nfunction stripMember(node) {\n  strip(node);\n  delete node.object;\n  delete node.property;\n  delete node.computed;\n  if (!node.table) delete node.table;\n}\n\nexport function clean(ast) {\n  walk(ast, null, {\n    Column: stripMember,\n    Constant: stripMember,\n    Default: strip\n  });\n  return ast;\n}\n","import { ArrowFunctionExpression, FunctionExpression } from './constants.js';\n\nexport function is(type, node) {\n  return node && node.type === type;\n}\n\nexport function isFunctionExpression(node) {\n  return is(FunctionExpression, node)\n    || is(ArrowFunctionExpression, node);\n}\n","import { error } from '../util/error.js';\nimport { toString } from '../util/to-string.js';\n\nconst visit = (node, opt) => {\n  const f = visitors[node.type];\n  return f\n    ? f(node, opt)\n    : error(`Unsupported expression construct: ${node.type}`);\n};\n\nconst binary = (node, opt) => {\n  return '(' + visit(node.left, opt) + ' ' + node.operator + ' ' + visit(node.right, opt) + ')';\n};\n\nconst func = (node, opt) => {\n  return '(' + list(node.params, opt) + ')=>' + visit(node.body, opt);\n};\n\nconst call = (node, opt) => {\n  return visit(node.callee, opt) + '(' + list(node.arguments, opt) + ')';\n};\n\nconst list = (array, opt, delim = ',') => {\n  return array.map(node => visit(node, opt)).join(delim);\n};\n\nconst name = node => node.computed\n  ? `[${toString(node.name)}]`\n  : `.${node.name}`;\n\nconst ref = (node, opt, method) => {\n  const table = node.table || '';\n  return `data${table}${name(node)}.${method}(${opt.index}${table})`;\n};\n\nconst get = (node, opt) => {\n  const table = node.table || '';\n  return `data${table}${name(node)}[${opt.index}${table}]`;\n};\n\nconst visitors = {\n  Constant: node => node.raw,\n  Column: (node, opt) => node.array ? get(node, opt) : ref(node, opt, 'at'),\n  Dictionary: (node, opt) => ref(node, opt, 'key'),\n  Function: node => `fn.${node.name}`,\n  Parameter: node => `$${name(node)}`,\n  Op: (node, opt) => `op(${toString(node.name)},${opt.op || opt.index})`,\n  Literal: node => node.raw,\n  Identifier: node => node.name,\n  TemplateLiteral: (node, opt) => {\n    const { quasis, expressions } = node;\n    const n = expressions.length;\n    let t = quasis[0].value.raw;\n    for (let i = 0; i < n;) {\n      t += '${' + visit(expressions[i], opt) + '}' + quasis[++i].value.raw;\n    }\n    return '`' + t + '`';\n  },\n  MemberExpression: (node, opt) => {\n    const d = !node.computed;\n    const o = visit(node.object, opt);\n    const p = visit(node.property, opt);\n    return o + (d ? '.' + p : '[' + p + ']');\n  },\n  CallExpression: call,\n  NewExpression: (node, opt) => {\n    return 'new ' + call(node, opt);\n  },\n  ArrayExpression: (node, opt) => {\n    return '[' + list(node.elements, opt) + ']';\n  },\n  AssignmentExpression: binary,\n  BinaryExpression: binary,\n  LogicalExpression: binary,\n  UnaryExpression: (node, opt) => {\n    return '(' + node.operator + visit(node.argument, opt) + ')';\n  },\n  ConditionalExpression: (node, opt) => {\n    return '(' + visit(node.test, opt) +\n      '?' + visit(node.consequent, opt) +\n      ':' + visit(node.alternate, opt) + ')';\n  },\n  ObjectExpression: (node, opt) => {\n    return '({' + list(node.properties, opt) + '})';\n  },\n  Property: (node, opt) => {\n    const key = visit(node.key, opt);\n    return (node.computed ? `[${key}]` : key) + ':' + visit(node.value, opt);\n  },\n\n  ArrowFunctionExpression: func,\n  FunctionExpression: func,\n  FunctionDeclaration: func,\n\n  ArrayPattern: (node, opt) => {\n    return '[' + list(node.elements, opt) + ']';\n  },\n  ObjectPattern: (node, opt) => {\n    return '{' + list(node.properties, opt) + '}';\n  },\n  VariableDeclaration: (node, opt) => {\n    return node.kind + ' ' + list(node.declarations, opt, ',');\n  },\n  VariableDeclarator: (node, opt) => {\n    return visit(node.id, opt) + '=' + visit(node.init, opt);\n  },\n  SpreadElement: (node, opt) => {\n    return '...' + visit(node.argument, opt);\n  },\n\n  BlockStatement: (node, opt) => {\n    return '{' + list(node.body, opt, ';') + ';}';\n  },\n  BreakStatement: () => {\n    return 'break';\n  },\n  ExpressionStatement: (node, opt) => {\n    return visit(node.expression, opt);\n  },\n  IfStatement: (node, opt) => {\n    return 'if (' + visit(node.test, opt) + ')'\n      + visit(node.consequent, opt)\n      + (node.alternate ? ' else ' + visit(node.alternate, opt) : '');\n  },\n  SwitchStatement: (node, opt) => {\n    return 'switch (' + visit(node.discriminant, opt) + ') {'\n     + list(node.cases, opt, '')\n     + '}';\n  },\n  SwitchCase: (node, opt) => {\n    return (node.test ? 'case ' + visit(node.test, opt) : 'default')\n      + ': '\n      + list(node.consequent, opt, ';') + ';';\n  },\n  ReturnStatement: (node, opt) => {\n    return 'return ' + visit(node.argument, opt);\n  },\n  Program: (node, opt) => visit(node.body[0], opt)\n};\n\nexport function codegen(node, opt = { index: 'row' }) {\n  return visit(node, opt);\n}\n","import { functions as fn } from '../op/index.js';\n\nfunction _compile(code, fn, params) {\n  code = `\"use strict\"; return ${code};`;\n  return (Function('fn', '$', code))(fn, params);\n}\n\nexport const compile = {\n  escape: (code, func, params) => _compile(code, func, params),\n  expr:   (code, params) => _compile(`(row,data,op)=>${code}`, fn, params),\n  expr2:  (code, params) => _compile(`(row0,data0,row,data)=>${code}`, fn, params),\n  join:   (code, params) => _compile(`(row1,data1,row2,data2)=>${code}`, fn, params),\n  param:  (code, params) => _compile(code, fn, params)\n};\n","import { Column, Dictionary, Literal } from './ast/constants.js';\nimport { isArrayType } from '../util/is-array-type.js';\nimport { isFunction } from '../util/is-function.js';\n\nconst dictOps = {\n  '==': 1,\n  '!=': 1,\n  '===': 1,\n  '!==': 1\n};\n\n/**\n * Rewrite AST node to be a table column reference.\n * Additionally optimizes dictionary column operations.\n * @param {object} ref AST node to rewrite to a column reference.\n * @param {string} name The name of the column.\n * @param {number} [index] The table index of the column.\n * @param {object} [col] The actual table column instance.\n * @param {object} [op] Parent AST node operating on the column reference.\n */\nexport function rewrite(ref, name, index = 0, col = undefined, op = undefined) {\n  ref.type = Column;\n  ref.name = name;\n  ref.table = index;\n\n  // annotate arrays as such for optimized access\n  if (isArrayType(col)) {\n    ref.array = true;\n  }\n\n  // proceed only if has parent op and is a dictionary column\n  if (op && col && isFunction(col.keyFor)) {\n    // get other arg if op is an optimizeable operation\n    const lit = dictOps[op.operator]\n      ? op.left === ref ? op.right : op.left\n      : op.callee && op.callee.name === 'equal'\n      ? op.arguments[op.arguments[0] === ref ? 1 : 0]\n      : null;\n\n    // rewrite as dictionary lookup if other arg is a literal\n    if (lit && lit.type === Literal) {\n      rewriteDictionary(op, ref, lit, col.keyFor(lit.value));\n    }\n  }\n\n  return ref;\n}\n\nfunction rewriteDictionary(op, ref, lit, key) {\n  if (key < 0) {\n    // value not in dictionary, rewrite op as false literal\n    op.type = Literal;\n    op.value = false;\n    op.raw = 'false';\n  } else {\n    // rewrite ref as dict key access\n    ref.type = Dictionary;\n\n    // rewrite literal as target dict key\n    lit.value = key;\n    lit.raw = key + '';\n  }\n\n  return true;\n}\n","import { Literal, ObjectExpression, Property } from './ast/constants.js';\nimport { codegen } from './codegen.js';\nimport { compile } from './compile.js';\nimport { rewrite } from './rewrite.js';\nimport { entries } from '../util/entries.js';\nimport { isArray } from '../util/is-array.js';\nimport { toString } from '../util/to-string.js';\n\nexport const ROW_OBJECT = 'row_object';\n\nexport function rowObjectExpression(\n  node,\n  table,\n  props = table.columnNames())\n{\n  node.type = ObjectExpression;\n\n  const p = node.properties = [];\n  for (const prop of entries(props)) {\n    const [name, key] = isArray(prop) ? prop : [prop, prop];\n    p.push({\n      type: Property,\n      key: { type: Literal, raw: toString(key) },\n      value: rewrite({ computed: true }, name, 0, table.column(name))\n    });\n  }\n\n  return node;\n}\n\nexport function rowObjectCode(table, props) {\n  return codegen(rowObjectExpression({}, table, props));\n}\n\nexport function rowObjectBuilder(table, props) {\n  return compile.expr(rowObjectCode(table, props));\n}\n","import { compile } from './compile.js';\nimport { rowObjectCode } from './row-object.js';\nimport { error } from '../util/error.js';\nimport { toFunction } from '../util/to-function.js';\n\nconst ERROR_ESC_AGGRONLY = 'Escaped functions are not valid as rollup or pivot values.';\n\nexport function parseEscape(ctx, spec, params) {\n  if (ctx.aggronly) error(ERROR_ESC_AGGRONLY);\n\n  // generate escaped function invocation code\n  const code = `(row,data)=>fn(${rowObjectCode(ctx.table)},$)`;\n\n  return { escape: compile.escape(code, toFunction(spec.expr), params) };\n}\n","import { isFunction } from './is-function.js';\n\nexport function toFunction(value) {\n  return isFunction(value) ? value : () => value;\n}\n","// This file was generated. Do not modify manually!\nvar astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\n// This file was generated. Do not modify manually!\nvar astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\n\n// This file was generated. Do not modify manually!\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0897-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\n\n// This file was generated. Do not modify manually!\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c8a\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7cd\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7dc\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range.\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords$1 = {\n  5: ecma5AndLessKeywords,\n  \"5module\": ecma5AndLessKeywords + \" export import\",\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n  return false\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords[name] = new TokenType(name, options)\n}\n\nvar types$1 = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  privateId: new TokenType(\"privateId\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n  coalesce: binop(\"??\", 1),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\", startsExpr),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nfunction nextLineBreak(code, from, end) {\n  if ( end === void 0 ) end = code.length;\n\n  for (var i = from; i < end; i++) {\n    var next = code.charCodeAt(i);\n    if (isNewLine(next))\n      { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }\n  }\n  return -1\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\nvar hasOwn = Object.hasOwn || (function (obj, propName) { return (\n  hasOwnProperty.call(obj, propName)\n); });\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\nvar regexpCache = Object.create(null);\n\nfunction wordsRegexp(words) {\n  return regexpCache[words] || (regexpCache[words] = new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\"))\n}\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\nvar loneSurrogate = /(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/;\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    var nextBreak = nextLineBreak(input, cur, offset);\n    if (nextBreak < 0) { return new Position(line, offset - cur) }\n    ++line;\n    cur = nextBreak;\n  }\n}\n\n// A second argument must be given to configure the parser process.\n// These options are recognized (only `ecmaVersion` is required):\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10\n  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `\"latest\"`\n  // (the latest version the library supports). This influences\n  // support for strict mode, the set of reserved words, and support\n  // for new syntax features.\n  ecmaVersion: null,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called when\n  // a semicolon is automatically inserted. It will be passed the\n  // position of the inserted semicolon as an offset, and if\n  // `locations` is enabled, it is given the location as a `{line,\n  // column}` object as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program, and an import.meta expression\n  // in a script isn't considered an error.\n  allowImportExportEverywhere: false,\n  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: null,\n  // When enabled, super identifiers are not constrained to\n  // appearing in methods and do not raise an error when they appear elsewhere.\n  allowSuperOutsideMethod: null,\n  // When enabled, hashbang directive in the beginning of file is\n  // allowed and treated as a line comment. Enabled by default when\n  // `ecmaVersion` >= 2023.\n  allowHashBang: false,\n  // By default, the parser will verify that private properties are\n  // only used in places where they are valid and have been declared.\n  // Set this to false to turn such checks off.\n  checkPrivateFields: true,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callbackthat will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callbackthat will corrupt its internal state.\n  // When this option has an array as value, objects representing the\n  // comments are pushed to it.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false\n};\n\n// Interpret and default an options object\n\nvar warnedAboutEcmaVersion = false;\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion === \"latest\") {\n    options.ecmaVersion = 1e8;\n  } else if (options.ecmaVersion == null) {\n    if (!warnedAboutEcmaVersion && typeof console === \"object\" && console.warn) {\n      warnedAboutEcmaVersion = true;\n      console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is required.\\nDefaulting to 2020, but this will stop working in the future.\");\n    }\n    options.ecmaVersion = 11;\n  } else if (options.ecmaVersion >= 2015) {\n    options.ecmaVersion -= 2009;\n  }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (!opts || opts.allowHashBang == null)\n    { options.allowHashBang = options.ecmaVersion >= 14; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Each scope gets a bitset that may contain these flags\nvar\n    SCOPE_TOP = 1,\n    SCOPE_FUNCTION = 2,\n    SCOPE_ASYNC = 4,\n    SCOPE_GENERATOR = 8,\n    SCOPE_ARROW = 16,\n    SCOPE_SIMPLE_CATCH = 32,\n    SCOPE_SUPER = 64,\n    SCOPE_DIRECT_SUPER = 128,\n    SCOPE_CLASS_STATIC_BLOCK = 256,\n    SCOPE_CLASS_FIELD_INIT = 512,\n    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;\n\nfunction functionFlags(async, generator) {\n  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n}\n\n// Used in checkLVal* and declareName to determine the type of a binding\nvar\n    BIND_NONE = 0, // Not a binding\n    BIND_VAR = 1, // Var-style binding\n    BIND_LEXICAL = 2, // Let- or const-style binding\n    BIND_FUNCTION = 3, // Function declaration\n    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n  var reserved = \"\";\n  if (options.allowReserved !== true) {\n    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n    if (options.sourceType === \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = wordsRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types$1.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n  this.potentialArrowInForAwait = false;\n\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n  // Labels in scope.\n  this.labels = [];\n  // Thus-far undefined exports.\n  this.undefinedExports = Object.create(null);\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterScope(SCOPE_TOP);\n\n  // For RegExp validation\n  this.regexpState = null;\n\n  // The stack of private names.\n  // Each element has two properties: 'declared' and 'used'.\n  // When it exited from the outermost class definition, all used private names must be declared.\n  this.privateNameStack = [];\n};\n\nvar prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nprototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n\nprototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n\nprototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n\nprototypeAccessors.canAwait.get = function () {\n  for (var i = this.scopeStack.length - 1; i >= 0; i--) {\n    var ref = this.scopeStack[i];\n      var flags = ref.flags;\n    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) { return false }\n    if (flags & SCOPE_FUNCTION) { return (flags & SCOPE_ASYNC) > 0 }\n  }\n  return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction\n};\n\nprototypeAccessors.allowSuper.get = function () {\n  var ref = this.currentThisScope();\n    var flags = ref.flags;\n  return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod\n};\n\nprototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n\nprototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\nprototypeAccessors.allowNewDotTarget.get = function () {\n  for (var i = this.scopeStack.length - 1; i >= 0; i--) {\n    var ref = this.scopeStack[i];\n      var flags = ref.flags;\n    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) ||\n        ((flags & SCOPE_FUNCTION) && !(flags & SCOPE_ARROW))) { return true }\n  }\n  return false\n};\n\nprototypeAccessors.inClassStaticBlock.get = function () {\n  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0\n};\n\nParser.extend = function extend () {\n    var plugins = [], len = arguments.length;\n    while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  var cls = this;\n  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n  return cls\n};\n\nParser.parse = function parse (input, options) {\n  return new this(options, input).parse()\n};\n\nParser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n  var parser = new this(options, input, pos);\n  parser.nextToken();\n  return parser.parseExpression()\n};\n\nParser.tokenizer = function tokenizer (input, options) {\n  return new this(options, input)\n};\n\nObject.defineProperties( Parser.prototype, prototypeAccessors );\n\nvar pp$9 = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\[^]|[^'\\\\])*?)'|\"((?:\\\\[^]|[^\"\\\\])*?)\")/;\npp$9.strictDirective = function(start) {\n  if (this.options.ecmaVersion < 5) { return false }\n  for (;;) {\n    // Try to find string literal.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    var match = literal.exec(this.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) === \"use strict\") {\n      skipWhiteSpace.lastIndex = start + match[0].length;\n      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n      var next = this.input.charAt(end);\n      return next === \";\" || next === \"}\" ||\n        (lineBreak.test(spaceAfter[0]) &&\n         !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\"))\n    }\n    start += match[0].length;\n\n    // Skip semicolon, if any.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    if (this.input[start] === \";\")\n      { start++; }\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp$9.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp$9.isContextual = function(name) {\n  return this.type === types$1.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp$9.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp$9.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp$9.canInsertSemicolon = function() {\n  return this.type === types$1.eof ||\n    this.type === types$1.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp$9.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp$9.semicolon = function() {\n  if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp$9.afterTrailingComma = function(tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp$9.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp$9.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nvar DestructuringErrors = function DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n};\n\npp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, isAssign ? \"Assigning to rvalue\" : \"Parenthesized pattern\"); }\n};\n\npp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp$9.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp$9.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$8 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$8.parseTopLevel = function(node) {\n  var exports = Object.create(null);\n  if (!node.body) { node.body = []; }\n  while (this.type !== types$1.eof) {\n    var stmt = this.parseStatement(null, true, exports);\n    node.body.push(stmt);\n  }\n  if (this.inModule)\n    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n      {\n        var name = list[i];\n\n        this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n      } }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  node.sourceType = this.options.sourceType;\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\npp$8.isLet = function(context) {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  // For ambiguous cases, determine if a LexicalDeclaration (or only a\n  // Statement) is allowed here. If context is not empty then only a Statement\n  // is allowed. However, `let [` is an explicit negative lookahead for\n  // ExpressionStatement, so special-case it first.\n  if (nextCh === 91 || nextCh === 92) { return true } // '[', '\\'\n  if (context) { return false }\n\n  if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }\n    if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$8.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, after;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 === this.input.length ||\n     !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$8.parseStatement = function(context, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet(context)) {\n    starttype = types$1._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types$1._debugger: return this.parseDebuggerStatement(node)\n  case types$1._do: return this.parseDoStatement(node)\n  case types$1._for: return this.parseForStatement(node)\n  case types$1._function:\n    // Function as sole body of either an if statement or a labeled statement\n    // works, but not when it is part of a labeled statement that is the sole\n    // body of an if statement.\n    if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false, !context)\n  case types$1._class:\n    if (context) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types$1._if: return this.parseIfStatement(node)\n  case types$1._return: return this.parseReturnStatement(node)\n  case types$1._switch: return this.parseSwitchStatement(node)\n  case types$1._throw: return this.parseThrowStatement(node)\n  case types$1._try: return this.parseTryStatement(node)\n  case types$1._const: case types$1._var:\n    kind = kind || this.value;\n    if (context && kind !== \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types$1._while: return this.parseWhileStatement(node)\n  case types$1._with: return this.parseWithStatement(node)\n  case types$1.braceL: return this.parseBlock(true, node)\n  case types$1.semi: return this.parseEmptyStatement(node)\n  case types$1._export:\n  case types$1._import:\n    if (this.options.ecmaVersion > 10 && starttype === types$1._import) {\n      skipWhiteSpace.lastIndex = this.pos;\n      var skip = skipWhiteSpace.exec(this.input);\n      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n      if (nextCh === 40 || nextCh === 46) // '(' or '.'\n        { return this.parseExpressionStatement(node, this.parseExpression()) }\n    }\n\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (context) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true, !context)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types$1.name && expr.type === \"Identifier\" && this.eat(types$1.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$8.parseBreakContinueStatement = function(node, keyword) {\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types$1.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$8.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$8.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"do\");\n  this.labels.pop();\n  this.expect(types$1._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types$1.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$8.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterScope(0);\n  this.expect(types$1.parenL);\n  if (this.type === types$1.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types$1._var || this.type === types$1._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types$1._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init$1)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init$1)\n  }\n  var startsWithLet = this.isContextual(\"let\"), isForOf = false;\n  var containsEsc = this.containsEsc;\n  var refDestructuringErrors = new DestructuringErrors;\n  var initPos = this.start;\n  var init = awaitAt > -1\n    ? this.parseExprSubscripts(refDestructuringErrors, \"await\")\n    : this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (awaitAt > -1) { // implies `ecmaVersion >= 9` (see declaration of awaitAt)\n      if (this.type === types$1._in) { this.unexpected(awaitAt); }\n      node.await = true;\n    } else if (isForOf && this.options.ecmaVersion >= 8) {\n      if (init.start === initPos && !containsEsc && init.type === \"Identifier\" && init.name === \"async\") { this.unexpected(); }\n      else if (this.options.ecmaVersion >= 9) { node.await = false; }\n    }\n    if (startsWithLet && isForOf) { this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\"); }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLValPattern(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n  this.next();\n  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n};\n\npp$8.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(\"if\");\n  node.alternate = this.eat(types$1._else) ? this.parseStatement(\"if\") : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$8.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$8.parseSwitchStatement = function(node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types$1.braceL);\n  this.labels.push(switchLabel);\n  this.enterScope(0);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types$1.braceR;) {\n    if (this.type === types$1._case || this.type === types$1._default) {\n      var isCase = this.type === types$1._case;\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(types$1.colon);\n    } else {\n      if (!cur) { this.unexpected(); }\n      cur.consequent.push(this.parseStatement(null));\n    }\n  }\n  this.exitScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$8.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty$1 = [];\n\npp$8.parseCatchClauseParam = function() {\n  var param = this.parseBindingAtom();\n  var simple = param.type === \"Identifier\";\n  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n  this.expect(types$1.parenR);\n\n  return param\n};\n\npp$8.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types$1._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types$1.parenL)) {\n      clause.param = this.parseCatchClauseParam();\n    } else {\n      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n      clause.param = null;\n      this.enterScope(0);\n    }\n    clause.body = this.parseBlock(false);\n    this.exitScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {\n  this.next();\n  this.parseVar(node, false, kind, allowMissingInitializer);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$8.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"while\");\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$8.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(\"with\");\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$8.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$8.parseLabeledStatement = function(node, maybeName, expr, context) {\n  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types$1._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$8.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n  if ( node === void 0 ) node = this.startNode();\n\n  node.body = [];\n  this.expect(types$1.braceL);\n  if (createNewLexicalScope) { this.enterScope(0); }\n  while (this.type !== types$1.braceR) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n  if (exitStrict) { this.strict = false; }\n  this.next();\n  if (createNewLexicalScope) { this.exitScope(); }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$8.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types$1.semi);\n  node.test = this.type === types$1.semi ? null : this.parseExpression();\n  this.expect(types$1.semi);\n  node.update = this.type === types$1.parenR ? null : this.parseExpression();\n  this.expect(types$1.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$8.parseForIn = function(node, init) {\n  var isForIn = this.type === types$1._in;\n  this.next();\n\n  if (\n    init.type === \"VariableDeclaration\" &&\n    init.declarations[0].init != null &&\n    (\n      !isForIn ||\n      this.options.ecmaVersion < 8 ||\n      this.strict ||\n      init.kind !== \"var\" ||\n      init.declarations[0].id.type !== \"Identifier\"\n    )\n  ) {\n    this.raise(\n      init.start,\n      ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n    );\n  }\n  node.left = init;\n  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types$1.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n};\n\n// Parse a list of variable declarations.\n\npp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarId(decl, kind);\n    if (this.eat(types$1.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (!allowMissingInitializer && kind === \"const\" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected();\n    } else if (!allowMissingInitializer && decl.id.type !== \"Identifier\" && !(isFor && (this.type === types$1._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(types$1.comma)) { break }\n  }\n  return node\n};\n\npp$8.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom();\n  this.checkLValPattern(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\n\nvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\npp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n    if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))\n      { this.unexpected(); }\n    node.generator = this.eat(types$1.star);\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (statement & FUNC_STATEMENT) {\n    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();\n    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n      // If it is a regular function declaration in sloppy mode, then it is\n      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n      // mode depends on properties of the current scope (see\n      // treatFunctionsAsVar).\n      { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n  }\n\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(node.async, node.generator));\n\n  if (!(statement & FUNC_STATEMENT))\n    { node.id = this.type === types$1.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$8.parseFunctionParams = function(node) {\n  this.expect(types$1.parenL);\n  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$8.parseClass = function(node, isStatement) {\n  this.next();\n\n  // ecma-262 14.6 Class Definitions\n  // A class definition is always strict mode code.\n  var oldStrict = this.strict;\n  this.strict = true;\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var privateNameMap = this.enterClassBody();\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types$1.braceL);\n  while (this.type !== types$1.braceR) {\n    var element = this.parseClassElement(node.superClass !== null);\n    if (element) {\n      classBody.body.push(element);\n      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n        if (hadConstructor) { this.raiseRecoverable(element.start, \"Duplicate constructor in the same class\"); }\n        hadConstructor = true;\n      } else if (element.key && element.key.type === \"PrivateIdentifier\" && isPrivateNameConflicted(privateNameMap, element)) {\n        this.raiseRecoverable(element.key.start, (\"Identifier '#\" + (element.key.name) + \"' has already been declared\"));\n      }\n    }\n  }\n  this.strict = oldStrict;\n  this.next();\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  this.exitClassBody();\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$8.parseClassElement = function(constructorAllowsSuper) {\n  if (this.eat(types$1.semi)) { return null }\n\n  var ecmaVersion = this.options.ecmaVersion;\n  var node = this.startNode();\n  var keyName = \"\";\n  var isGenerator = false;\n  var isAsync = false;\n  var kind = \"method\";\n  var isStatic = false;\n\n  if (this.eatContextual(\"static\")) {\n    // Parse static init block\n    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {\n      this.parseClassStaticBlock(node);\n      return node\n    }\n    if (this.isClassElementNameStart() || this.type === types$1.star) {\n      isStatic = true;\n    } else {\n      keyName = \"static\";\n    }\n  }\n  node.static = isStatic;\n  if (!keyName && ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {\n      isAsync = true;\n    } else {\n      keyName = \"async\";\n    }\n  }\n  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {\n    isGenerator = true;\n  }\n  if (!keyName && !isAsync && !isGenerator) {\n    var lastValue = this.value;\n    if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n      if (this.isClassElementNameStart()) {\n        kind = lastValue;\n      } else {\n        keyName = lastValue;\n      }\n    }\n  }\n\n  // Parse element name\n  if (keyName) {\n    // 'async', 'get', 'set', or 'static' were not a keyword contextually.\n    // The last token is any of those. Make it the element name.\n    node.computed = false;\n    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n    node.key.name = keyName;\n    this.finishNode(node.key, \"Identifier\");\n  } else {\n    this.parseClassElementName(node);\n  }\n\n  // Parse element value\n  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== \"method\" || isGenerator || isAsync) {\n    var isConstructor = !node.static && checkKeyName(node, \"constructor\");\n    var allowsDirectSuper = isConstructor && constructorAllowsSuper;\n    // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.\n    if (isConstructor && kind !== \"method\") { this.raise(node.key.start, \"Constructor can't have get/set modifier\"); }\n    node.kind = isConstructor ? \"constructor\" : kind;\n    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n  } else {\n    this.parseClassField(node);\n  }\n\n  return node\n};\n\npp$8.isClassElementNameStart = function() {\n  return (\n    this.type === types$1.name ||\n    this.type === types$1.privateId ||\n    this.type === types$1.num ||\n    this.type === types$1.string ||\n    this.type === types$1.bracketL ||\n    this.type.keyword\n  )\n};\n\npp$8.parseClassElementName = function(element) {\n  if (this.type === types$1.privateId) {\n    if (this.value === \"constructor\") {\n      this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n    }\n    element.computed = false;\n    element.key = this.parsePrivateIdent();\n  } else {\n    this.parsePropertyName(element);\n  }\n};\n\npp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n  // Check key and flags\n  var key = method.key;\n  if (method.kind === \"constructor\") {\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n  } else if (method.static && checkKeyName(method, \"prototype\")) {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n\n  // Parse value\n  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n\n  // Check value\n  if (method.kind === \"get\" && value.params.length !== 0)\n    { this.raiseRecoverable(value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && value.params.length !== 1)\n    { this.raiseRecoverable(value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(value.params[0].start, \"Setter cannot use rest params\"); }\n\n  return this.finishNode(method, \"MethodDefinition\")\n};\n\npp$8.parseClassField = function(field) {\n  if (checkKeyName(field, \"constructor\")) {\n    this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n  } else if (field.static && checkKeyName(field, \"prototype\")) {\n    this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n  }\n\n  if (this.eat(types$1.eq)) {\n    // To raise SyntaxError if 'arguments' exists in the initializer.\n    this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);\n    field.value = this.parseMaybeAssign();\n    this.exitScope();\n  } else {\n    field.value = null;\n  }\n  this.semicolon();\n\n  return this.finishNode(field, \"PropertyDefinition\")\n};\n\npp$8.parseClassStaticBlock = function(node) {\n  node.body = [];\n\n  var oldLabels = this.labels;\n  this.labels = [];\n  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);\n  while (this.type !== types$1.braceR) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n  this.next();\n  this.exitScope();\n  this.labels = oldLabels;\n\n  return this.finishNode(node, \"StaticBlock\")\n};\n\npp$8.parseClassId = function(node, isStatement) {\n  if (this.type === types$1.name) {\n    node.id = this.parseIdent();\n    if (isStatement)\n      { this.checkLValSimple(node.id, BIND_LEXICAL, false); }\n  } else {\n    if (isStatement === true)\n      { this.unexpected(); }\n    node.id = null;\n  }\n};\n\npp$8.parseClassSuper = function(node) {\n  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;\n};\n\npp$8.enterClassBody = function() {\n  var element = {declared: Object.create(null), used: []};\n  this.privateNameStack.push(element);\n  return element.declared\n};\n\npp$8.exitClassBody = function() {\n  var ref = this.privateNameStack.pop();\n  var declared = ref.declared;\n  var used = ref.used;\n  if (!this.options.checkPrivateFields) { return }\n  var len = this.privateNameStack.length;\n  var parent = len === 0 ? null : this.privateNameStack[len - 1];\n  for (var i = 0; i < used.length; ++i) {\n    var id = used[i];\n    if (!hasOwn(declared, id.name)) {\n      if (parent) {\n        parent.used.push(id);\n      } else {\n        this.raiseRecoverable(id.start, (\"Private field '#\" + (id.name) + \"' must be declared in an enclosing class\"));\n      }\n    }\n  }\n};\n\nfunction isPrivateNameConflicted(privateNameMap, element) {\n  var name = element.key.name;\n  var curr = privateNameMap[name];\n\n  var next = \"true\";\n  if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) {\n    next = (element.static ? \"s\" : \"i\") + element.kind;\n  }\n\n  // `class { get #a(){}; static set #a(_){} }` is also conflict.\n  if (\n    curr === \"iget\" && next === \"iset\" ||\n    curr === \"iset\" && next === \"iget\" ||\n    curr === \"sget\" && next === \"sset\" ||\n    curr === \"sset\" && next === \"sget\"\n  ) {\n    privateNameMap[name] = \"true\";\n    return false\n  } else if (!curr) {\n    privateNameMap[name] = next;\n    return false\n  } else {\n    return true\n  }\n}\n\nfunction checkKeyName(node, name) {\n  var computed = node.computed;\n  var key = node.key;\n  return !computed && (\n    key.type === \"Identifier\" && key.name === name ||\n    key.type === \"Literal\" && key.value === name\n  )\n}\n\n// Parses module export declaration.\n\npp$8.parseExportAllDeclaration = function(node, exports) {\n  if (this.options.ecmaVersion >= 11) {\n    if (this.eatContextual(\"as\")) {\n      node.exported = this.parseModuleExportName();\n      this.checkExport(exports, node.exported, this.lastTokStart);\n    } else {\n      node.exported = null;\n    }\n  }\n  this.expectContextual(\"from\");\n  if (this.type !== types$1.string) { this.unexpected(); }\n  node.source = this.parseExprAtom();\n  if (this.options.ecmaVersion >= 16)\n    { node.attributes = this.parseWithClause(); }\n  this.semicolon();\n  return this.finishNode(node, \"ExportAllDeclaration\")\n};\n\npp$8.parseExport = function(node, exports) {\n  this.next();\n  // export * from '...'\n  if (this.eat(types$1.star)) {\n    return this.parseExportAllDeclaration(node, exports)\n  }\n  if (this.eat(types$1._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    node.declaration = this.parseExportDefaultDeclaration();\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseExportDeclaration(node);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n    if (this.options.ecmaVersion >= 16)\n      { node.attributes = []; }\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types$1.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n      if (this.options.ecmaVersion >= 16)\n        { node.attributes = this.parseWithClause(); }\n    } else {\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        // check for keywords used as local names\n        var spec = list[i];\n\n        this.checkUnreserved(spec.local);\n        // check if export is defined\n        this.checkLocalExport(spec.local);\n\n        if (spec.local.type === \"Literal\") {\n          this.raise(spec.local.start, \"A string literal cannot be used as an exported binding without `from`.\");\n        }\n      }\n\n      node.source = null;\n      if (this.options.ecmaVersion >= 16)\n        { node.attributes = []; }\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$8.parseExportDeclaration = function(node) {\n  return this.parseStatement(null)\n};\n\npp$8.parseExportDefaultDeclaration = function() {\n  var isAsync;\n  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {\n    var fNode = this.startNode();\n    this.next();\n    if (isAsync) { this.next(); }\n    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync)\n  } else if (this.type === types$1._class) {\n    var cNode = this.startNode();\n    return this.parseClass(cNode, \"nullableID\")\n  } else {\n    var declaration = this.parseMaybeAssign();\n    this.semicolon();\n    return declaration\n  }\n};\n\npp$8.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (typeof name !== \"string\")\n    { name = name.type === \"Identifier\" ? name.name : name.value; }\n  if (hasOwn(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$8.checkPatternExport = function(exports, pat) {\n  var type = pat.type;\n  if (type === \"Identifier\")\n    { this.checkExport(exports, pat, pat.start); }\n  else if (type === \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this.checkPatternExport(exports, prop);\n      } }\n  else if (type === \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this.checkPatternExport(exports, elt); }\n    } }\n  else if (type === \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type === \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type === \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n};\n\npp$8.checkVariableExport = function(exports, decls) {\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$8.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$8.parseExportSpecifier = function(exports) {\n  var node = this.startNode();\n  node.local = this.parseModuleExportName();\n\n  node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local;\n  this.checkExport(\n    exports,\n    node.exported,\n    node.exported.start\n  );\n\n  return this.finishNode(node, \"ExportSpecifier\")\n};\n\npp$8.parseExportSpecifiers = function(exports) {\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types$1.braceL);\n  while (!this.eat(types$1.braceR)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (this.afterTrailingComma(types$1.braceR)) { break }\n    } else { first = false; }\n\n    nodes.push(this.parseExportSpecifier(exports));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$8.parseImport = function(node) {\n  this.next();\n\n  // import '...'\n  if (this.type === types$1.string) {\n    node.specifiers = empty$1;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();\n  }\n  if (this.options.ecmaVersion >= 16)\n    { node.attributes = this.parseWithClause(); }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$8.parseImportSpecifier = function() {\n  var node = this.startNode();\n  node.imported = this.parseModuleExportName();\n\n  if (this.eatContextual(\"as\")) {\n    node.local = this.parseIdent();\n  } else {\n    this.checkUnreserved(node.imported);\n    node.local = node.imported;\n  }\n  this.checkLValSimple(node.local, BIND_LEXICAL);\n\n  return this.finishNode(node, \"ImportSpecifier\")\n};\n\npp$8.parseImportDefaultSpecifier = function() {\n  // import defaultObj, { x, y as z } from '...'\n  var node = this.startNode();\n  node.local = this.parseIdent();\n  this.checkLValSimple(node.local, BIND_LEXICAL);\n  return this.finishNode(node, \"ImportDefaultSpecifier\")\n};\n\npp$8.parseImportNamespaceSpecifier = function() {\n  var node = this.startNode();\n  this.next();\n  this.expectContextual(\"as\");\n  node.local = this.parseIdent();\n  this.checkLValSimple(node.local, BIND_LEXICAL);\n  return this.finishNode(node, \"ImportNamespaceSpecifier\")\n};\n\npp$8.parseImportSpecifiers = function() {\n  var nodes = [], first = true;\n  if (this.type === types$1.name) {\n    nodes.push(this.parseImportDefaultSpecifier());\n    if (!this.eat(types$1.comma)) { return nodes }\n  }\n  if (this.type === types$1.star) {\n    nodes.push(this.parseImportNamespaceSpecifier());\n    return nodes\n  }\n  this.expect(types$1.braceL);\n  while (!this.eat(types$1.braceR)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (this.afterTrailingComma(types$1.braceR)) { break }\n    } else { first = false; }\n\n    nodes.push(this.parseImportSpecifier());\n  }\n  return nodes\n};\n\npp$8.parseWithClause = function() {\n  var nodes = [];\n  if (!this.eat(types$1._with)) {\n    return nodes\n  }\n  this.expect(types$1.braceL);\n  var attributeKeys = {};\n  var first = true;\n  while (!this.eat(types$1.braceR)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (this.afterTrailingComma(types$1.braceR)) { break }\n    } else { first = false; }\n\n    var attr = this.parseImportAttribute();\n    var keyName = attr.key.type === \"Identifier\" ? attr.key.name : attr.key.value;\n    if (hasOwn(attributeKeys, keyName))\n      { this.raiseRecoverable(attr.key.start, \"Duplicate attribute key '\" + keyName + \"'\"); }\n    attributeKeys[keyName] = true;\n    nodes.push(attr);\n  }\n  return nodes\n};\n\npp$8.parseImportAttribute = function() {\n  var node = this.startNode();\n  node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n  this.expect(types$1.colon);\n  if (this.type !== types$1.string) {\n    this.unexpected();\n  }\n  node.value = this.parseExprAtom();\n  return this.finishNode(node, \"ImportAttribute\")\n};\n\npp$8.parseModuleExportName = function() {\n  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {\n    var stringLiteral = this.parseLiteral(this.value);\n    if (loneSurrogate.test(stringLiteral.value)) {\n      this.raise(stringLiteral.start, \"An export name cannot include a lone surrogate.\");\n    }\n    return stringLiteral\n  }\n  return this.parseIdent(true)\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$8.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$8.isDirectiveCandidate = function(statement) {\n  return (\n    this.options.ecmaVersion >= 5 &&\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$7 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"AssignmentPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n      break\n\n    case \"ChainExpression\":\n      this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$7.toAssignableList = function(exprList, isBinding) {\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$7.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$7.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types$1.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$7.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types$1.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types$1.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types$1.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this.expect(types$1.comma); }\n    if (allowEmpty && this.type === types$1.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === types$1.ellipsis) {\n      var rest = this.parseRestBinding();\n      this.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this.type === types$1.comma) { this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\"); }\n      this.expect(close);\n      break\n    } else {\n      elts.push(this.parseAssignableListItem(allowModifiers));\n    }\n  }\n  return elts\n};\n\npp$7.parseAssignableListItem = function(allowModifiers) {\n  var elem = this.parseMaybeDefault(this.start, this.startLoc);\n  this.parseBindingListItem(elem);\n  return elem\n};\n\npp$7.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$7.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// The following three functions all verify that a node is an lvalue \n// something that can be bound, or assigned to. In order to do so, they perform\n// a variety of checks:\n//\n// - Check that none of the bound/assigned-to identifiers are reserved words.\n// - Record name declarations for bindings in the appropriate scope.\n// - Check duplicate argument names, if checkClashes is set.\n//\n// If a complex binding pattern is encountered (e.g., object and array\n// destructuring), the entire pattern is recursively checked.\n//\n// There are three versions of checkLVal*() appropriate for different\n// circumstances:\n//\n// - checkLValSimple() shall be used if the syntactic construct supports\n//   nothing other than identifiers and member expressions. Parenthesized\n//   expressions are also correctly handled. This is generally appropriate for\n//   constructs for which the spec says\n//\n//   > It is a Syntax Error if AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   It is also appropriate for checking if an identifier is valid and not\n//   defined elsewhere, like import declarations or function/class identifiers.\n//\n//   Examples where this is used include:\n//     a += ;\n//     import a from '';\n//   where a is the node to be checked.\n//\n// - checkLValPattern() shall be used if the syntactic construct supports\n//   anything checkLValSimple() supports, as well as object and array\n//   destructuring patterns. This is generally appropriate for constructs for\n//   which the spec says\n//\n//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor\n//   > an ArrayLiteral and AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   Examples where this is used include:\n//     (a = );\n//     const a = ;\n//     try {  } catch (a) {  }\n//   where a is the node to be checked.\n//\n// - checkLValInnerPattern() shall be used if the syntactic construct supports\n//   anything checkLValPattern() supports, as well as default assignment\n//   patterns, rest elements, and other constructs that may appear within an\n//   object or array destructuring pattern.\n//\n//   As a special case, function parameters also use checkLValInnerPattern(),\n//   as they also support defaults and rest constructs.\n//\n// These functions deliberately support both assignment and binding constructs,\n// as the logic for both is exceedingly similar. If the node is the target of\n// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it\n// should be set to the appropriate BIND_* constant, like BIND_VAR or\n// BIND_LEXICAL.\n//\n// If the function is called with a non-BIND_NONE bindingType, then\n// additionally a checkClashes object may be specified to allow checking for\n// duplicate argument names. checkClashes is ignored if the provided construct\n// is an assignment (i.e., bindingType is BIND_NONE).\n\npp$7.checkLValSimple = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  var isBind = bindingType !== BIND_NONE;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (isBind ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (isBind) {\n      if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n        { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n      if (checkClashes) {\n        if (hasOwn(checkClashes, expr.name))\n          { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n        checkClashes[expr.name] = true;\n      }\n      if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n    }\n    break\n\n  case \"ChainExpression\":\n    this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n    break\n\n  case \"MemberExpression\":\n    if (isBind) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ParenthesizedExpression\":\n    if (isBind) { this.raiseRecoverable(expr.start, \"Binding parenthesized expression\"); }\n    return this.checkLValSimple(expr.expression, bindingType, checkClashes)\n\n  default:\n    this.raise(expr.start, (isBind ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\npp$7.checkLValPattern = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1) {\n      var prop = list[i];\n\n    this.checkLValInnerPattern(prop, bindingType, checkClashes);\n    }\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }\n    }\n    break\n\n  default:\n    this.checkLValSimple(expr, bindingType, checkClashes);\n  }\n};\n\npp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n  case \"Property\":\n    // AssignmentProperty has type === \"Property\"\n    this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLValPattern(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLValPattern(expr.argument, bindingType, checkClashes);\n    break\n\n  default:\n    this.checkLValPattern(expr, bindingType, checkClashes);\n  }\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$6 = Parser.prototype;\n\npp$6.initialContext = function() {\n  return [types.b_stat]\n};\n\npp$6.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\npp$6.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types.f_expr || parent === types.f_stat)\n    { return true }\n  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)\n    { return true }\n  if (prevType === types$1.braceL)\n    { return parent === types.b_stat }\n  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$6.inGeneratorContext = function() {\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$6.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType === types$1.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Used to handle edge cases when token context could not be inferred correctly during tokenization phase\n\npp$6.overrideContext = function(tokenCtx) {\n  if (this.curContext() !== tokenCtx) {\n    this.context[this.context.length - 1] = tokenCtx;\n  }\n};\n\n// Token-specific context update code\n\ntypes$1.parenR.updateContext = types$1.braceR.updateContext = function() {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes$1.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes$1.dollarBraceL.updateContext = function() {\n  this.context.push(types.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes$1.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;\n  this.context.push(statementParens ? types.p_stat : types.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes$1.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes$1._function.updateContext = types$1._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types$1._else &&\n      !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&\n      !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n      !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))\n    { this.context.push(types.f_expr); }\n  else\n    { this.context.push(types.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes$1.colon.updateContext = function() {\n  if (this.curContext().token === \"function\") { this.context.pop(); }\n  this.exprAllowed = true;\n};\n\ntypes$1.backQuote.updateContext = function() {\n  if (this.curContext() === types.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes$1.star.updateContext = function(prevType) {\n  if (prevType === types$1._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types.f_expr)\n      { this.context[index] = types.f_expr_gen; }\n    else\n      { this.context[index] = types.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes$1.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {\n    if (this.value === \"of\" && !this.exprAllowed ||\n        this.value === \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n\nvar pp$5 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors) {\n          if (refDestructuringErrors.doubleProto < 0) {\n            refDestructuringErrors.doubleProto = key.start;\n          }\n        } else {\n          this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n        }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$5.parseExpression = function(forInit, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n  if (this.type === types$1.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {\n  if (this.isContextual(\"yield\")) {\n    if (this.inGenerator) { return this.parseYield(forInit) }\n    // The tokenizer will assume an expression is allowed after\n    // `yield`, but this isn't that kind of yield\n    else { this.exprAllowed = false; }\n  }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    oldDoubleProto = refDestructuringErrors.doubleProto;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type === types$1.parenL || this.type === types$1.name) {\n    this.potentialArrowAt = this.start;\n    this.potentialArrowInForAwait = forInit === \"await\";\n  }\n  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    if (this.type === types$1.eq)\n      { left = this.toAssignable(left, false, refDestructuringErrors); }\n    if (!ownDestructuringErrors) {\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n    }\n    if (refDestructuringErrors.shorthandAssign >= left.start)\n      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly\n    if (this.type === types$1.eq)\n      { this.checkLValPattern(left); }\n    else\n      { this.checkLValSimple(left); }\n    node.left = left;\n    this.next();\n    node.right = this.parseMaybeAssign(forInit);\n    if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(forInit, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types$1.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types$1.colon);\n    node.alternate = this.parseMaybeAssign(forInit);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$5.parseExprOps = function(forInit, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n  var prec = this.type.binop;\n  if (prec != null && (!forInit || this.type !== types$1._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;\n      var coalesce = this.type === types$1.coalesce;\n      if (coalesce) {\n        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n        prec = types$1.logicalAND.binop;\n      }\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n      if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {\n        this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n      }\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)\n    }\n  }\n  return left\n};\n\npp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  if (right.type === \"PrivateIdentifier\") { this.raise(right.start, \"Private identifier can only be left side of binary expression\"); }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.isContextual(\"await\") && this.canAwait) {\n    expr = this.parseAwait(forInit);\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types$1.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true, update, forInit);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLValSimple(node.argument); }\n    else if (this.strict && node.operator === \"delete\" && isLocalVariableAccess(node.argument))\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else if (node.operator === \"delete\" && isPrivateFieldAccess(node.argument))\n      { this.raiseRecoverable(node.start, \"Private fields can not be deleted\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else if (!sawUnary && this.type === types$1.privateId) {\n    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) { this.unexpected(); }\n    expr = this.parsePrivateIdent();\n    // only could be private fields in 'in', such as #x in obj\n    if (this.type !== types$1._in) { this.unexpected(); }\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.operator = this.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this.checkLValSimple(expr);\n      this.next();\n      expr = this.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!incDec && this.eat(types$1.starstar)) {\n    if (sawUnary)\n      { this.unexpected(this.lastTokStart); }\n    else\n      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), \"**\", false) }\n  } else {\n    return expr\n  }\n};\n\nfunction isLocalVariableAccess(node) {\n  return (\n    node.type === \"Identifier\" ||\n    node.type === \"ParenthesizedExpression\" && isLocalVariableAccess(node.expression)\n  )\n}\n\nfunction isPrivateFieldAccess(node) {\n  return (\n    node.type === \"MemberExpression\" && node.property.type === \"PrivateIdentifier\" ||\n    node.type === \"ChainExpression\" && isPrivateFieldAccess(node.expression) ||\n    node.type === \"ParenthesizedExpression\" && isPrivateFieldAccess(node.expression)\n  )\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors, forInit);\n  if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\")\n    { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n    if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }\n  }\n  return result\n};\n\npp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&\n      this.potentialArrowAt === base.start;\n  var optionalChained = false;\n\n  while (true) {\n    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n\n    if (element.optional) { optionalChained = true; }\n    if (element === base || element.type === \"ArrowFunctionExpression\") {\n      if (optionalChained) {\n        var chainNode = this.startNodeAt(startPos, startLoc);\n        chainNode.expression = element;\n        element = this.finishNode(chainNode, \"ChainExpression\");\n      }\n      return element\n    }\n\n    base = element;\n  }\n};\n\npp$5.shouldParseAsyncArrow = function() {\n  return !this.canInsertSemicolon() && this.eat(types$1.arrow)\n};\n\npp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)\n};\n\npp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n  var optionalSupported = this.options.ecmaVersion >= 11;\n  var optional = optionalSupported && this.eat(types$1.questionDot);\n  if (noCalls && optional) { this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\"); }\n\n  var computed = this.eat(types$1.bracketL);\n  if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(types$1.bracketR);\n    } else if (this.type === types$1.privateId && base.type !== \"Super\") {\n      node.property = this.parsePrivateIdent();\n    } else {\n      node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n    }\n    node.computed = !!computed;\n    if (optionalSupported) {\n      node.optional = optional;\n    }\n    base = this.finishNode(node, \"MemberExpression\");\n  } else if (!noCalls && this.eat(types$1.parenL)) {\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      if (this.awaitIdentPos > 0)\n        { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos;\n      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)\n    }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n    var node$1 = this.startNodeAt(startPos, startLoc);\n    node$1.callee = base;\n    node$1.arguments = exprList;\n    if (optionalSupported) {\n      node$1.optional = optional;\n    }\n    base = this.finishNode(node$1, \"CallExpression\");\n  } else if (this.type === types$1.backQuote) {\n    if (optional || optionalChained) {\n      this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n    }\n    var node$2 = this.startNodeAt(startPos, startLoc);\n    node$2.tag = base;\n    node$2.quasi = this.parseTemplate({isTagged: true});\n    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n  }\n  return base\n};\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {\n  // If a division operator appears in an expression position, the\n  // tokenizer got confused, and we force it to read a regexp instead.\n  if (this.type === types$1.slash) { this.readRegexp(); }\n\n  var node, canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n  case types$1._super:\n    if (!this.allowSuper)\n      { this.raise(this.start, \"'super' keyword outside a method\"); }\n    node = this.startNode();\n    this.next();\n    if (this.type === types$1.parenL && !this.allowDirectSuper)\n      { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super ( Arguments )\n    if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types$1._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types$1.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(false);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types$1._function)) {\n      this.overrideContext(types.f_expr);\n      return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)\n    }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types$1.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types$1.name && !containsEsc &&\n          (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n        id = this.parseIdent(false);\n        if (this.canInsertSemicolon() || !this.eat(types$1.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)\n      }\n    }\n    return id\n\n  case types$1.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types$1.num: case types$1.string:\n    return this.parseLiteral(this.value)\n\n  case types$1._null: case types$1._true: case types$1._false:\n    node = this.startNode();\n    node.value = this.type === types$1._null ? null : this.type === types$1._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types$1.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types$1.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types$1.braceL:\n    this.overrideContext(types.b_expr);\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types$1._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, 0)\n\n  case types$1._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types$1._new:\n    return this.parseNew()\n\n  case types$1.backQuote:\n    return this.parseTemplate()\n\n  case types$1._import:\n    if (this.options.ecmaVersion >= 11) {\n      return this.parseExprImport(forNew)\n    } else {\n      return this.unexpected()\n    }\n\n  default:\n    return this.parseExprAtomDefault()\n  }\n};\n\npp$5.parseExprAtomDefault = function() {\n  this.unexpected();\n};\n\npp$5.parseExprImport = function(forNew) {\n  var node = this.startNode();\n\n  // Consume `import` as an identifier for `import.meta`.\n  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword import\"); }\n  this.next();\n\n  if (this.type === types$1.parenL && !forNew) {\n    return this.parseDynamicImport(node)\n  } else if (this.type === types$1.dot) {\n    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n    meta.name = \"import\";\n    node.meta = this.finishNode(meta, \"Identifier\");\n    return this.parseImportMeta(node)\n  } else {\n    this.unexpected();\n  }\n};\n\npp$5.parseDynamicImport = function(node) {\n  this.next(); // skip `(`\n\n  // Parse node.source.\n  node.source = this.parseMaybeAssign();\n\n  if (this.options.ecmaVersion >= 16) {\n    if (!this.eat(types$1.parenR)) {\n      this.expect(types$1.comma);\n      if (!this.afterTrailingComma(types$1.parenR)) {\n        node.options = this.parseMaybeAssign();\n        if (!this.eat(types$1.parenR)) {\n          this.expect(types$1.comma);\n          if (!this.afterTrailingComma(types$1.parenR)) {\n            this.unexpected();\n          }\n        }\n      } else {\n        node.options = null;\n      }\n    } else {\n      node.options = null;\n    }\n  } else {\n    // Verify ending.\n    if (!this.eat(types$1.parenR)) {\n      var errorPos = this.start;\n      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {\n        this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n      } else {\n        this.unexpected(errorPos);\n      }\n    }\n  }\n\n  return this.finishNode(node, \"ImportExpression\")\n};\n\npp$5.parseImportMeta = function(node) {\n  this.next(); // skip `.`\n\n  var containsEsc = this.containsEsc;\n  node.property = this.parseIdent(true);\n\n  if (node.property.name !== \"meta\")\n    { this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\"); }\n  if (containsEsc)\n    { this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\"); }\n  if (this.options.sourceType !== \"module\" && !this.options.allowImportExportEverywhere)\n    { this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\"); }\n\n  return this.finishNode(node, \"MetaProperty\")\n};\n\npp$5.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\"); }\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$5.parseParenExpression = function() {\n  this.expect(types$1.parenL);\n  var val = this.parseExpression();\n  this.expect(types$1.parenR);\n  return val\n};\n\npp$5.shouldParseArrow = function(exprList) {\n  return !this.canInsertSemicolon()\n};\n\npp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    // Do not save awaitIdentPos to allow checking awaits nested in parameters\n    while (this.type !== types$1.parenR) {\n      first ? first = false : this.expect(types$1.comma);\n      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this.type === types$1.ellipsis) {\n        spreadStart = this.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding()));\n        if (this.type === types$1.comma) {\n          this.raiseRecoverable(\n            this.start,\n            \"Comma is not permitted after the rest element\"\n          );\n        }\n        break\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n      }\n    }\n    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n    this.expect(types$1.parenR);\n\n    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList, forInit)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$5.parseParenItem = function(item) {\n  return item\n};\n\npp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call  at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty = [];\n\npp$5.parseNew = function() {\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword new\"); }\n  var node = this.startNode();\n  this.next();\n  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {\n    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n    meta.name = \"new\";\n    node.meta = this.finishNode(meta, \"Identifier\");\n    this.next();\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\")\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\"); }\n    if (containsEsc)\n      { this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\"); }\n    if (!this.allowNewDotTarget)\n      { this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);\n  if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$5.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types$1.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value.replace(/\\r\\n?/g, \"\\n\"),\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types$1.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$5.parseTemplate = function(ref) {\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this.type === types$1.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n    this.expect(types$1.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(types$1.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$5.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$5.parseObj = function(isPattern, refDestructuringErrors) {\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types$1.braceR)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$5.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types$1.comma) {\n        this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types$1.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);\n    this.parsePropertyName(prop);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$5.parseGetterSetter = function(prop) {\n  var kind = prop.key.name;\n  this.parsePropertyName(prop);\n  prop.value = this.parseMethod(false);\n  prop.kind = kind;\n  var paramCount = prop.kind === \"get\" ? 0 : 1;\n  if (prop.value.params.length !== paramCount) {\n    var start = prop.value.start;\n    if (prop.kind === \"get\")\n      { this.raiseRecoverable(start, \"getter should have no params\"); }\n    else\n      { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n  } else {\n    if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n      { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n  }\n};\n\npp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types$1.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types$1.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n    prop.kind = \"init\";\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    this.parseGetterSetter(prop);\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    this.checkUnreserved(prop.key);\n    if (prop.key.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = startPos; }\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n    } else if (this.type === types$1.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n    } else {\n      prop.value = this.copyNode(prop.key);\n    }\n    prop.kind = \"init\";\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$5.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types$1.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types$1.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n};\n\n// Initialize empty function node.\n\npp$5.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n  if (this.options.ecmaVersion >= 8) { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n  this.expect(types$1.parenL);\n  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false, true, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$5.parseArrowExpression = function(node, params, isAsync, forInit) {\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true, false, forInit);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {\n  var isExpression = isArrowFunction && this.type !== types$1.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign(forInit);\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }\n    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitScope();\n};\n\npp$5.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$5.checkParams = function(node, allowDuplicates) {\n  var nameHash = Object.create(null);\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this.type === types$1.comma)\n      { elt = null; }\n    else if (this.type === types$1.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this.start; }\n    } else {\n      elt = this.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$5.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n  if (!(this.currentThisScope().flags & SCOPE_VAR) && name === \"arguments\")\n    { this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\"); }\n  if (this.inClassStaticBlock && (name === \"arguments\" || name === \"await\"))\n    { this.raise(start, (\"Cannot use \" + name + \" in class static initialization block\")); }\n  if (this.keywords.test(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$5.parseIdent = function(liberal) {\n  var node = this.parseIdentNode();\n  this.next(!!liberal);\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) {\n    this.checkUnreserved(node);\n    if (node.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = node.start; }\n  }\n  return node\n};\n\npp$5.parseIdentNode = function() {\n  var node = this.startNode();\n  if (this.type === types$1.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n      (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n    this.type = types$1.name;\n  } else {\n    this.unexpected();\n  }\n  return node\n};\n\npp$5.parsePrivateIdent = function() {\n  var node = this.startNode();\n  if (this.type === types$1.privateId) {\n    node.name = this.value;\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"PrivateIdentifier\");\n\n  // For validating existence\n  if (this.options.checkPrivateFields) {\n    if (this.privateNameStack.length === 0) {\n      this.raise(node.start, (\"Private field '#\" + (node.name) + \"' must be declared in an enclosing class\"));\n    } else {\n      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n    }\n  }\n\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$5.parseYield = function(forInit) {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types$1.star);\n    node.argument = this.parseMaybeAssign(forInit);\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$5.parseAwait = function(forInit) {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true, false, forInit);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  if (this.sourceFile) {\n    message += \" in \" + this.sourceFile;\n  }\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$3 = Parser.prototype;\n\nvar Scope = function Scope(flags) {\n  this.flags = flags;\n  // A list of var-declared names in the current lexical scope\n  this.var = [];\n  // A list of lexically-declared names in the current lexical scope\n  this.lexical = [];\n  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n  this.functions = [];\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$3.enterScope = function(flags) {\n  this.scopeStack.push(new Scope(flags));\n};\n\npp$3.exitScope = function() {\n  this.scopeStack.pop();\n};\n\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\npp$3.treatFunctionsAsVarInScope = function(scope) {\n  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n};\n\npp$3.declareName = function(name, bindingType, pos) {\n  var redeclared = false;\n  if (bindingType === BIND_LEXICAL) {\n    var scope = this.currentScope();\n    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    scope.lexical.push(name);\n    if (this.inModule && (scope.flags & SCOPE_TOP))\n      { delete this.undefinedExports[name]; }\n  } else if (bindingType === BIND_SIMPLE_CATCH) {\n    var scope$1 = this.currentScope();\n    scope$1.lexical.push(name);\n  } else if (bindingType === BIND_FUNCTION) {\n    var scope$2 = this.currentScope();\n    if (this.treatFunctionsAsVar)\n      { redeclared = scope$2.lexical.indexOf(name) > -1; }\n    else\n      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n    scope$2.functions.push(name);\n  } else {\n    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n      var scope$3 = this.scopeStack[i];\n      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n        redeclared = true;\n        break\n      }\n      scope$3.var.push(name);\n      if (this.inModule && (scope$3.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n      if (scope$3.flags & SCOPE_VAR) { break }\n    }\n  }\n  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n};\n\npp$3.checkLocalExport = function(id) {\n  // scope.functions must be empty as Module code is always strict.\n  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n      this.scopeStack[0].var.indexOf(id.name) === -1) {\n    this.undefinedExports[id.name] = id;\n  }\n};\n\npp$3.currentScope = function() {\n  return this.scopeStack[this.scopeStack.length - 1]\n};\n\npp$3.currentVarScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) { return scope }\n  }\n};\n\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\npp$3.currentThisScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) &&\n        !(scope.flags & SCOPE_ARROW)) { return scope }\n  }\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$2 = Parser.prototype;\n\npp$2.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$2.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$2.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$2.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\npp$2.copyNode = function(node) {\n  var newNode = new Node(this, node.start, this.startLoc);\n  for (var prop in node) { newNode[prop] = node[prop]; }\n  return newNode\n};\n\n// This file was generated by \"bin/generate-unicode-script-values.js\". Do not modify manually!\nvar scriptValuesAddedInUnicode = \"Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz\";\n\n// This file contains Unicode properties extracted from the ECMAScript specification.\n// The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n// #table-binary-unicode-properties\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar ecma12BinaryProperties = ecma11BinaryProperties + \" EBase EComp EMod EPres ExtPict\";\nvar ecma13BinaryProperties = ecma12BinaryProperties;\nvar ecma14BinaryProperties = ecma13BinaryProperties;\n\nvar unicodeBinaryProperties = {\n  9: ecma9BinaryProperties,\n  10: ecma10BinaryProperties,\n  11: ecma11BinaryProperties,\n  12: ecma12BinaryProperties,\n  13: ecma13BinaryProperties,\n  14: ecma14BinaryProperties\n};\n\n// #table-binary-unicode-properties-of-strings\nvar ecma14BinaryPropertiesOfStrings = \"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji\";\n\nvar unicodeBinaryPropertiesOfStrings = {\n  9: \"\",\n  10: \"\",\n  11: \"\",\n  12: \"\",\n  13: \"\",\n  14: ecma14BinaryPropertiesOfStrings\n};\n\n// #table-unicode-general-category-values\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n// #table-unicode-script-values\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar ecma12ScriptValues = ecma11ScriptValues + \" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\";\nvar ecma13ScriptValues = ecma12ScriptValues + \" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\";\nvar ecma14ScriptValues = ecma13ScriptValues + \" \" + scriptValuesAddedInUnicode;\n\nvar unicodeScriptValues = {\n  9: ecma9ScriptValues,\n  10: ecma10ScriptValues,\n  11: ecma11ScriptValues,\n  12: ecma12ScriptValues,\n  13: ecma13ScriptValues,\n  14: ecma14ScriptValues\n};\n\nvar data = {};\nfunction buildUnicodeData(ecmaVersion) {\n  var d = data[ecmaVersion] = {\n    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),\n    nonBinary: {\n      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n    }\n  };\n  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n  d.nonBinary.gc = d.nonBinary.General_Category;\n  d.nonBinary.sc = d.nonBinary.Script;\n  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\n\nfor (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {\n  var ecmaVersion = list[i];\n\n  buildUnicodeData(ecmaVersion);\n}\n\nvar pp$1 = Parser.prototype;\n\n// Track disjunction structure to determine whether a duplicate\n// capture group name is allowed because it is in a separate branch.\nvar BranchID = function BranchID(parent, base) {\n  // Parent disjunction branch\n  this.parent = parent;\n  // Identifies this set of sibling branches\n  this.base = base || this;\n};\n\nBranchID.prototype.separatedFrom = function separatedFrom (alt) {\n  // A branch is separate from another branch if they or any of\n  // their parents are siblings in a given disjunction\n  for (var self = this; self; self = self.parent) {\n    for (var other = alt; other; other = other.parent) {\n      if (self.base === other.base && self !== other) { return true }\n    }\n  }\n  return false\n};\n\nBranchID.prototype.sibling = function sibling () {\n  return new BranchID(this.parent, this.base)\n};\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\") + (parser.options.ecmaVersion >= 13 ? \"d\" : \"\") + (parser.options.ecmaVersion >= 15 ? \"v\" : \"\");\n  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchV = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = Object.create(null);\n  this.backReferenceNames = [];\n  this.branchID = null;\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicodeSets = flags.indexOf(\"v\") !== -1;\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {\n    this.switchU = true;\n    this.switchV = true;\n    this.switchN = true;\n  } else {\n    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n    this.switchV = false;\n    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n  }\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i), next;\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.pos, forceU)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.nextIndex(this.pos, forceU), forceU)\n};\n\nRegExpValidationState.prototype.advance = function advance (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  this.pos = this.nextIndex(this.pos, forceU);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  if (this.current(forceU) === ch) {\n    this.advance(forceU);\n    return true\n  }\n  return false\n};\n\nRegExpValidationState.prototype.eatChars = function eatChars (chs, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var pos = this.pos;\n  for (var i = 0, list = chs; i < list.length; i += 1) {\n    var ch = list[i];\n\n      var current = this.at(pos, forceU);\n    if (current === -1 || current !== ch) {\n      return false\n    }\n    pos = this.nextIndex(pos, forceU);\n  }\n  this.pos = pos;\n  return true\n};\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$1.validateRegExpFlags = function(state) {\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  var u = false;\n  var v = false;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this.raise(state.start, \"Duplicate regular expression flag\");\n    }\n    if (flag === \"u\") { u = true; }\n    if (flag === \"v\") { v = true; }\n  }\n  if (this.options.ecmaVersion >= 15 && u && v) {\n    this.raise(state.start, \"Invalid regular expression flag\");\n  }\n};\n\nfunction hasProp(obj) {\n  for (var _ in obj) { return true }\n  return false\n}\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$1.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$1.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames = Object.create(null);\n  state.backReferenceNames.length = 0;\n  state.branchID = null;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (!state.groupNames[name]) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$1.regexp_disjunction = function(state) {\n  var trackDisjunction = this.options.ecmaVersion >= 16;\n  if (trackDisjunction) { state.branchID = new BranchID(state.branchID, null); }\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    if (trackDisjunction) { state.branchID = state.branchID.sibling(); }\n    this.regexp_alternative(state);\n  }\n  if (trackDisjunction) { state.branchID = state.branchID.parent; }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$1.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$1.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$1.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$1.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$1.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$1.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$1.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$1.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$1.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */)) {\n      if (this.options.ecmaVersion >= 16) {\n        var addModifiers = this.regexp_eatModifiers(state);\n        var hasHyphen = state.eat(0x2D /* - */);\n        if (addModifiers || hasHyphen) {\n          for (var i = 0; i < addModifiers.length; i++) {\n            var modifier = addModifiers.charAt(i);\n            if (addModifiers.indexOf(modifier, i + 1) > -1) {\n              state.raise(\"Duplicate regular expression modifiers\");\n            }\n          }\n          if (hasHyphen) {\n            var removeModifiers = this.regexp_eatModifiers(state);\n            if (!addModifiers && !removeModifiers && state.current() === 0x3A /* : */) {\n              state.raise(\"Invalid regular expression modifiers\");\n            }\n            for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {\n              var modifier$1 = removeModifiers.charAt(i$1);\n              if (\n                removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 ||\n                addModifiers.indexOf(modifier$1) > -1\n              ) {\n                state.raise(\"Duplicate regular expression modifiers\");\n              }\n            }\n          }\n        }\n      }\n      if (state.eat(0x3A /* : */)) {\n        this.regexp_disjunction(state);\n        if (state.eat(0x29 /* ) */)) {\n          return true\n        }\n        state.raise(\"Unterminated group\");\n      }\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$1.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n// RegularExpressionModifiers ::\n//   [empty]\n//   RegularExpressionModifiers RegularExpressionModifier\npp$1.regexp_eatModifiers = function(state) {\n  var modifiers = \"\";\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {\n    modifiers += codePointToString(ch);\n    state.advance();\n  }\n  return modifiers\n};\n// RegularExpressionModifier :: one of\n//   `i` `m` `s`\nfunction isRegularExpressionModifier(ch) {\n  return ch === 0x69 /* i */ || ch === 0x6d /* m */ || ch === 0x73 /* s */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$1.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$1.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$1.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$1.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$1.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier ::\n//   [empty]\n//   `?` GroupName\npp$1.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (!this.regexp_eatGroupName(state)) { state.raise(\"Invalid group\"); }\n    var trackDisjunction = this.options.ecmaVersion >= 16;\n    var known = state.groupNames[state.lastStringValue];\n    if (known) {\n      if (trackDisjunction) {\n        for (var i = 0, list = known; i < list.length; i += 1) {\n          var altID = list[i];\n\n          if (!altID.separatedFrom(state.branchID))\n            { state.raise(\"Duplicate capture group name\"); }\n        }\n      } else {\n        state.raise(\"Duplicate capture group name\");\n      }\n    }\n    if (trackDisjunction) {\n      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);\n    } else {\n      state.groupNames[state.lastStringValue] = true;\n    }\n  }\n};\n\n// GroupName ::\n//   `<` RegExpIdentifierName `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$1.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName ::\n//   RegExpIdentifierStart\n//   RegExpIdentifierName RegExpIdentifierPart\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$1.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\npp$1.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\n//   <ZWNJ>\n//   <ZWJ>\npp$1.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$1.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$1.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$1.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$1.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$1.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$1.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$1.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$1.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n  if ( forceU === void 0 ) forceU = false;\n\n  var start = state.pos;\n  var switchU = forceU || state.switchU;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$1.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$1.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// Return values used by character set parsing methods, needed to\n// forbid negation of sets that can match strings.\nvar CharSetNone = 0; // Nothing parsed\nvar CharSetOk = 1; // Construct parsed, cannot contain strings\nvar CharSetString = 2; // Construct parsed, can contain strings\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$1.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return CharSetOk\n  }\n\n  var negate = false;\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    ((negate = ch === 0x50 /* P */) || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    var result;\n    if (\n      state.eat(0x7B /* { */) &&\n      (result = this.regexp_eatUnicodePropertyValueExpression(state)) &&\n      state.eat(0x7D /* } */)\n    ) {\n      if (negate && result === CharSetString) { state.raise(\"Invalid property name\"); }\n      return result\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return CharSetNone\n};\n\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$1.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return CharSetOk\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue)\n  }\n  return CharSetNone\n};\n\npp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!hasOwn(state.unicodeProperties.nonBinary, name))\n    { state.raise(\"Invalid property name\"); }\n  if (!state.unicodeProperties.nonBinary[name].test(value))\n    { state.raise(\"Invalid property value\"); }\n};\n\npp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (state.unicodeProperties.binary.test(nameOrValue)) { return CharSetOk }\n  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) { return CharSetString }\n  state.raise(\"Invalid property name\");\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$1.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\n\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$1.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$1.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    var negate = state.eat(0x5E /* ^ */);\n    var result = this.regexp_classContents(state);\n    if (!state.eat(0x5D /* ] */))\n      { state.raise(\"Unterminated character class\"); }\n    if (negate && result === CharSetString)\n      { state.raise(\"Negated character class may contain strings\"); }\n    return true\n  }\n  return false\n};\n\n// https://tc39.es/ecma262/#prod-ClassContents\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\npp$1.regexp_classContents = function(state) {\n  if (state.current() === 0x5D /* ] */) { return CharSetOk }\n  if (state.switchV) { return this.regexp_classSetExpression(state) }\n  this.regexp_nonEmptyClassRanges(state);\n  return CharSetOk\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$1.regexp_nonEmptyClassRanges = function(state) {\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$1.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* ] */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$1.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetExpression\n// https://tc39.es/ecma262/#prod-ClassUnion\n// https://tc39.es/ecma262/#prod-ClassIntersection\n// https://tc39.es/ecma262/#prod-ClassSubtraction\npp$1.regexp_classSetExpression = function(state) {\n  var result = CharSetOk, subResult;\n  if (this.regexp_eatClassSetRange(state)) ; else if (subResult = this.regexp_eatClassSetOperand(state)) {\n    if (subResult === CharSetString) { result = CharSetString; }\n    // https://tc39.es/ecma262/#prod-ClassIntersection\n    var start = state.pos;\n    while (state.eatChars([0x26, 0x26] /* && */)) {\n      if (\n        state.current() !== 0x26 /* & */ &&\n        (subResult = this.regexp_eatClassSetOperand(state))\n      ) {\n        if (subResult !== CharSetString) { result = CharSetOk; }\n        continue\n      }\n      state.raise(\"Invalid character in character class\");\n    }\n    if (start !== state.pos) { return result }\n    // https://tc39.es/ecma262/#prod-ClassSubtraction\n    while (state.eatChars([0x2D, 0x2D] /* -- */)) {\n      if (this.regexp_eatClassSetOperand(state)) { continue }\n      state.raise(\"Invalid character in character class\");\n    }\n    if (start !== state.pos) { return result }\n  } else {\n    state.raise(\"Invalid character in character class\");\n  }\n  // https://tc39.es/ecma262/#prod-ClassUnion\n  for (;;) {\n    if (this.regexp_eatClassSetRange(state)) { continue }\n    subResult = this.regexp_eatClassSetOperand(state);\n    if (!subResult) { return result }\n    if (subResult === CharSetString) { result = CharSetString; }\n  }\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetRange\npp$1.regexp_eatClassSetRange = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatClassSetCharacter(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this.regexp_eatClassSetCharacter(state)) {\n      var right = state.lastIntValue;\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetOperand\npp$1.regexp_eatClassSetOperand = function(state) {\n  if (this.regexp_eatClassSetCharacter(state)) { return CharSetOk }\n  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state)\n};\n\n// https://tc39.es/ecma262/#prod-NestedClass\npp$1.regexp_eatNestedClass = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5B /* [ */)) {\n    var negate = state.eat(0x5E /* ^ */);\n    var result = this.regexp_classContents(state);\n    if (state.eat(0x5D /* ] */)) {\n      if (negate && result === CharSetString) {\n        state.raise(\"Negated character class may contain strings\");\n      }\n      return result\n    }\n    state.pos = start;\n  }\n  if (state.eat(0x5C /* \\ */)) {\n    var result$1 = this.regexp_eatCharacterClassEscape(state);\n    if (result$1) {\n      return result$1\n    }\n    state.pos = start;\n  }\n  return null\n};\n\n// https://tc39.es/ecma262/#prod-ClassStringDisjunction\npp$1.regexp_eatClassStringDisjunction = function(state) {\n  var start = state.pos;\n  if (state.eatChars([0x5C, 0x71] /* \\q */)) {\n    if (state.eat(0x7B /* { */)) {\n      var result = this.regexp_classStringDisjunctionContents(state);\n      if (state.eat(0x7D /* } */)) {\n        return result\n      }\n    } else {\n      // Make the same message as V8.\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return null\n};\n\n// https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents\npp$1.regexp_classStringDisjunctionContents = function(state) {\n  var result = this.regexp_classString(state);\n  while (state.eat(0x7C /* | */)) {\n    if (this.regexp_classString(state) === CharSetString) { result = CharSetString; }\n  }\n  return result\n};\n\n// https://tc39.es/ecma262/#prod-ClassString\n// https://tc39.es/ecma262/#prod-NonEmptyClassString\npp$1.regexp_classString = function(state) {\n  var count = 0;\n  while (this.regexp_eatClassSetCharacter(state)) { count++; }\n  return count === 1 ? CharSetOk : CharSetString\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetCharacter\npp$1.regexp_eatClassSetCharacter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (\n      this.regexp_eatCharacterEscape(state) ||\n      this.regexp_eatClassSetReservedPunctuator(state)\n    ) {\n      return true\n    }\n    if (state.eat(0x62 /* b */)) {\n      state.lastIntValue = 0x08; /* <BS> */\n      return true\n    }\n    state.pos = start;\n    return false\n  }\n  var ch = state.current();\n  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) { return false }\n  if (isClassSetSyntaxCharacter(ch)) { return false }\n  state.advance();\n  state.lastIntValue = ch;\n  return true\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator\nfunction isClassSetReservedDoublePunctuatorCharacter(ch) {\n  return (\n    ch === 0x21 /* ! */ ||\n    ch >= 0x23 /* # */ && ch <= 0x26 /* & */ ||\n    ch >= 0x2A /* * */ && ch <= 0x2C /* , */ ||\n    ch === 0x2E /* . */ ||\n    ch >= 0x3A /* : */ && ch <= 0x40 /* @ */ ||\n    ch === 0x5E /* ^ */ ||\n    ch === 0x60 /* ` */ ||\n    ch === 0x7E /* ~ */\n  )\n}\n\n// https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter\nfunction isClassSetSyntaxCharacter(ch) {\n  return (\n    ch === 0x28 /* ( */ ||\n    ch === 0x29 /* ) */ ||\n    ch === 0x2D /* - */ ||\n    ch === 0x2F /* / */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5D /* ] */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\npp$1.regexp_eatClassSetReservedPunctuator = function(state) {\n  var ch = state.current();\n  if (isClassSetReservedPunctuator(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\nfunction isClassSetReservedPunctuator(ch) {\n  return (\n    ch === 0x21 /* ! */ ||\n    ch === 0x23 /* # */ ||\n    ch === 0x25 /* % */ ||\n    ch === 0x26 /* & */ ||\n    ch === 0x2C /* , */ ||\n    ch === 0x2D /* - */ ||\n    ch >= 0x3A /* : */ && ch <= 0x3E /* > */ ||\n    ch === 0x40 /* @ */ ||\n    ch === 0x60 /* ` */ ||\n    ch === 0x7E /* ~ */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$1.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$1.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$1.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$1.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$1.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$1.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp = Parser.prototype;\n\n// Move to the next token\n\npp.next = function(ignoreEscapeSequenceInKeyword) {\n  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\n    { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword); }\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp[Symbol.iterator] = function() {\n    var this$1$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1$1.getToken();\n        return {\n          done: token.type === types$1.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xdc00) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00\n};\n\npp.skipBlockComment = function() {\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {\n      ++this.curLine;\n      pos = this.lineStart = nextBreak;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp.skipLineComment = function(startSkip) {\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this.input.charCodeAt(++this.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp.skipSpace = function() {\n  loop: while (this.pos < this.input.length) {\n    var ch = this.input.charCodeAt(this.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this.pos;\n      break\n    case 13:\n      if (this.input.charCodeAt(this.pos + 1) === 10) {\n        ++this.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this.pos;\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this.input.charCodeAt(this.pos + 1)) {\n      case 42: // '*'\n        this.skipBlockComment();\n        break\n      case 47:\n        this.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types$1.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types$1.dot)\n  }\n};\n\npp.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types$1.assign, 2) }\n  return this.finishOp(types$1.slash, 1)\n};\n\npp.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types$1.star : types$1.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types$1.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types$1.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (this.options.ecmaVersion >= 12) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 === 61) { return this.finishOp(types$1.assign, 3) }\n    }\n    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)\n  }\n  if (next === 61) { return this.finishOp(types$1.assign, 2) }\n  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)\n};\n\npp.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types$1.assign, 2) }\n  return this.finishOp(types$1.bitwiseXOR, 1)\n};\n\npp.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types$1.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types$1.assign, 2) }\n  return this.finishOp(types$1.plusMin, 1)\n};\n\npp.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }\n    return this.finishOp(types$1.bitShift, size)\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n      this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types$1.relational, size)\n};\n\npp.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types$1.arrow)\n  }\n  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)\n};\n\npp.readToken_question = function() { // '?'\n  var ecmaVersion = this.options.ecmaVersion;\n  if (ecmaVersion >= 11) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 46) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }\n    }\n    if (next === 63) {\n      if (ecmaVersion >= 12) {\n        var next2$1 = this.input.charCodeAt(this.pos + 2);\n        if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }\n      }\n      return this.finishOp(types$1.coalesce, 2)\n    }\n  }\n  return this.finishOp(types$1.question, 1)\n};\n\npp.readToken_numberSign = function() { // '#'\n  var ecmaVersion = this.options.ecmaVersion;\n  var code = 35; // '#'\n  if (ecmaVersion >= 13) {\n    ++this.pos;\n    code = this.fullCharCodeAtPos();\n    if (isIdentifierStart(code, true) || code === 92 /* '\\' */) {\n      return this.finishToken(types$1.privateId, this.readWord1())\n    }\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types$1.parenL)\n  case 41: ++this.pos; return this.finishToken(types$1.parenR)\n  case 59: ++this.pos; return this.finishToken(types$1.semi)\n  case 44: ++this.pos; return this.finishToken(types$1.comma)\n  case 91: ++this.pos; return this.finishToken(types$1.bracketL)\n  case 93: ++this.pos; return this.finishToken(types$1.bracketR)\n  case 123: ++this.pos; return this.finishToken(types$1.braceL)\n  case 125: ++this.pos; return this.finishToken(types$1.braceR)\n  case 58: ++this.pos; return this.finishToken(types$1.colon)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types$1.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 63: // '?'\n    return this.readToken_question()\n\n  case 126: // '~'\n    return this.finishOp(types$1.prefix, 1)\n\n  case 35: // '#'\n    return this.readToken_numberSign()\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp.readRegexp = function() {\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n    var ch = this.input.charAt(this.pos);\n    if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n  // `len` is used for character escape sequences. In that case, disallow separators.\n  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n\n  // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n  // and isn't fraction part nor exponent part. In that case, if the first digit\n  // is zero then disallow separators.\n  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n\n  var start = this.pos, total = 0, lastCode = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {\n    var code = this.input.charCodeAt(this.pos), val = (void 0);\n\n    if (allowSeparators && code === 95) {\n      if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\"); }\n      if (lastCode === 95) { this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\"); }\n      if (i === 0) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\"); }\n      lastCode = code;\n      continue\n    }\n\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    lastCode = code;\n    total = total * radix + val;\n  }\n\n  if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\"); }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\nfunction stringToNumber(str, isLegacyOctalNumericLiteral) {\n  if (isLegacyOctalNumericLiteral) {\n    return parseInt(str, 8)\n  }\n\n  // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n  return parseFloat(str.replace(/_/g, \"\"))\n}\n\nfunction stringToBigInt(str) {\n  if (typeof BigInt !== \"function\") {\n    return null\n  }\n\n  // `BigInt(value)` throws syntax error if the string contains numeric separators.\n  return BigInt(str.replace(/_/g, \"\"))\n}\n\npp.readRadixNumber = function(radix) {\n  var start = this.pos;\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n    val = stringToBigInt(this.input.slice(start, this.pos));\n    ++this.pos;\n  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types$1.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  var next = this.input.charCodeAt(this.pos);\n  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n    var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n    ++this.pos;\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types$1.num, val$1)\n  }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var val = stringToNumber(this.input.slice(start, this.pos), octal);\n  return this.finishToken(types$1.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\npp.readString = function(quote) {\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(false);\n      chunkStart = this.pos;\n    } else if (ch === 0x2028 || ch === 0x2029) {\n      if (this.options.ecmaVersion < 10) { this.raise(this.start, \"Unterminated string constant\"); }\n      ++this.pos;\n      if (this.options.locations) {\n        this.curLine++;\n        this.lineStart = this.pos;\n      }\n    } else {\n      if (isNewLine(ch)) { this.raise(this.start, \"Unterminated string constant\"); }\n      ++this.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types$1.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp.readTmplToken = function() {\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {\n        if (ch === 36) {\n          this.pos += 2;\n          return this.finishToken(types$1.dollarBraceL)\n        } else {\n          ++this.pos;\n          return this.finishToken(types$1.backQuote)\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos);\n      return this.finishToken(types$1.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(true);\n      chunkStart = this.pos;\n    } else if (isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.pos);\n      ++this.pos;\n      switch (ch) {\n      case 13:\n        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      chunkStart = this.pos;\n    } else {\n      ++this.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp.readInvalidTemplateToken = function() {\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this.input[this.pos]) {\n    case \"\\\\\":\n      ++this.pos;\n      break\n\n    case \"$\":\n      if (this.input[this.pos + 1] !== \"{\") { break }\n      // fall through\n    case \"`\":\n      return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))\n\n    case \"\\r\":\n      if (this.input[this.pos + 1] === \"\\n\") { ++this.pos; }\n      // fall through\n    case \"\\n\": case \"\\u2028\": case \"\\u2029\":\n      ++this.curLine;\n      this.lineStart = this.pos + 1;\n      break\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  case 56:\n  case 57:\n    if (this.strict) {\n      this.invalidStringToken(\n        this.pos - 1,\n        \"Invalid escape sequence\"\n      );\n    }\n    if (inTemplate) {\n      var codePos = this.pos - 1;\n\n      this.invalidStringToken(\n        codePos,\n        \"Invalid escape sequence in template string\"\n      );\n    }\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    if (isNewLine(ch)) {\n      // Unicode new line characters after \\ get removed from output in both\n      // template literals and strings\n      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n      return \"\"\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp.readWord1 = function() {\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this.containsEsc = true;\n      word += this.input.slice(chunkStart, this.pos);\n      var escStart = this.pos;\n      if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n        { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this.pos;\n      var esc = this.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString(esc);\n      chunkStart = this.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp.readWord = function() {\n  var word = this.readWord1();\n  var type = types$1.name;\n  if (this.keywords.test(word)) {\n    type = keywords[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n//\n// [walk]: util/walk.js\n\n\nvar version = \"8.14.1\";\n\nParser.acorn = {\n  Parser: Parser,\n  version: version,\n  defaultOptions: defaultOptions,\n  Position: Position,\n  SourceLocation: SourceLocation,\n  getLineInfo: getLineInfo,\n  Node: Node,\n  TokenType: TokenType,\n  tokTypes: types$1,\n  keywordTypes: keywords,\n  TokContext: TokContext,\n  tokContexts: types,\n  isIdentifierChar: isIdentifierChar,\n  isIdentifierStart: isIdentifierStart,\n  Token: Token,\n  isNewLine: isNewLine,\n  lineBreak: lineBreak,\n  lineBreakG: lineBreakG,\n  nonASCIIwhitespace: nonASCIIwhitespace\n};\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and returns\n// an abstract syntax tree as specified by the [ESTree spec][estree].\n//\n// [estree]: https://github.com/estree/estree\n\nfunction parse(input, options) {\n  return Parser.parse(input, options)\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  return Parser.parseExpressionAt(input, pos, options)\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return Parser.tokenizer(input, options)\n}\n\nexport { Node, Parser, Position, SourceLocation, TokContext, Token, TokenType, defaultOptions, getLineInfo, isIdentifierChar, isIdentifierStart, isNewLine, keywords as keywordTypes, lineBreak, lineBreakG, nonASCIIwhitespace, parse, parseExpressionAt, types as tokContexts, types$1 as tokTypes, tokenizer, version };\n","export const constants = {\n  undefined: 'void(0)',\n  Infinity:  'Number.POSITIVE_INFINITY',\n  NaN:       'Number.NaN',\n  E:         'Math.E',\n  LN2:       'Math.LN2',\n  LN10:      'Math.LN10',\n  LOG2E:     'Math.LOG2E',\n  LOG10E:    'Math.LOG10E',\n  PI:        'Math.PI',\n  SQRT1_2:   'Math.SQRT1_2',\n  SQRT2:     'Math.SQRT2'\n};\n","/**\n * @param {*} value\n * @returns {value is number}\n */\nexport function isNumber(value) {\n  return typeof value === 'number';\n}\n","import { parse } from 'acorn';\nimport {\n  ArrayPattern,\n  Constant,\n  Function,\n  Identifier,\n  Literal,\n  MemberExpression,\n  ObjectPattern,\n  Op,\n  Parameter,\n  Property\n} from './ast/constants.js';\nimport { is, isFunctionExpression } from './ast/util.js';\nimport { walk } from './ast/walk.js';\nimport { constants } from './constants.js';\nimport { rewrite } from './rewrite.js';\nimport { ROW_OBJECT, rowObjectExpression } from './row-object.js';\nimport {\n  getAggregate, getWindow,\n  hasAggregate, hasFunction, hasWindow\n} from '../op/index.js';\n\nimport { error } from '../util/error.js';\nimport { isArray } from '../util/is-array.js';\nimport { isNumber } from '../util/is-number.js';\nimport { toString } from '../util/to-string.js';\n\nconst PARSER_OPT = { ecmaVersion: 11 };\nconst DEFAULT_PARAM_ID = '$';\nconst DEFAULT_TUPLE_ID = 'd';\nconst DEFAULT_TUPLE_ID1 = 'd1';\nconst DEFAULT_TUPLE_ID2 = 'd2';\n\nconst NO = msg => (node, ctx) => ctx.error(node, msg + ' not allowed');\nconst ERROR_AGGREGATE = NO('Aggregate function');\nconst ERROR_WINDOW = NO('Window function');\nconst ERROR_ARGUMENT = 'Invalid argument';\nconst ERROR_COLUMN = 'Invalid column reference';\nconst ERROR_AGGRONLY = ERROR_COLUMN + ' (must be input to an aggregate function)';\nconst ERROR_FUNCTION = 'Invalid function call';\nconst ERROR_MEMBER = 'Invalid member expression';\nconst ERROR_OP_PARAMETER = 'Invalid operator parameter';\nconst ERROR_PARAM = 'Invalid param reference';\nconst ERROR_VARIABLE = 'Invalid variable reference';\nconst ERROR_VARIABLE_OP = 'Variable not accessible in operator call';\nconst ERROR_DECLARATION = 'Unsupported variable declaration';\nconst ERROR_DESTRUCTURE = 'Unsupported destructuring pattern';\nconst ERROR_CLOSURE = 'Table expressions do not support closures';\nconst ERROR_ESCAPE = 'Use aq.escape(fn) to use a function as-is (including closures)';\nconst ERROR_USE_PARAMS = 'use table.params({ name: value }) to define dynamic parameters';\nconst ERROR_ADD_FUNCTION = 'use aq.addFunction(name, fn) to add new op functions';\nconst ERROR_VARIABLE_NOTE = `\\nNote: ${ERROR_CLOSURE}. ${ERROR_ESCAPE}, or ${ERROR_USE_PARAMS}.`;\nconst ERROR_FUNCTION_NOTE = `\\nNote: ${ERROR_CLOSURE}. ${ERROR_ESCAPE}, or ${ERROR_ADD_FUNCTION}.`;\nconst ERROR_ROW_OBJECT = `The ${ROW_OBJECT} method is not valid in multi-table expressions.`;\n\nexport function parseExpression(ctx, spec) {\n  const ast = parseAST(spec);\n  let node = ctx.root = ast;\n  ctx.spec = spec;\n  ctx.tuple = null;\n  ctx.tuple1 = null;\n  ctx.tuple2 = null;\n  ctx.$param = null;\n  ctx.$op = 0;\n  ctx.scope = new Set();\n  ctx.paramsRef = new Map();\n  ctx.columnRef = new Map();\n\n  // parse input column parameters\n  // if no function def, assume default tuple identifiers\n  if (isFunctionExpression(node)) {\n    parseFunction(node, ctx);\n    node = node.body;\n  } else if (ctx.join) {\n    ctx.scope.add(ctx.tuple1 = DEFAULT_TUPLE_ID1);\n    ctx.scope.add(ctx.tuple2 = DEFAULT_TUPLE_ID2);\n    ctx.scope.add(ctx.$param = DEFAULT_PARAM_ID);\n  } else {\n    ctx.scope.add(ctx.tuple = DEFAULT_TUPLE_ID);\n    ctx.scope.add(ctx.$param = DEFAULT_PARAM_ID);\n  }\n\n  // rewrite column references & function calls\n  walk(node, ctx, visitors);\n\n  return ctx.root;\n}\n\nfunction parseAST(expr) {\n  try {\n    const code = expr.field ? fieldRef(expr)\n      : isArray(expr) ? toString(expr)\n      : expr;\n    // @ts-ignore\n    return parse(`expr=(${code})`, PARSER_OPT).body[0].expression.right;\n  } catch (err) { // eslint-disable-line no-unused-vars\n    error(`Expression parse error: ${expr+''}`);\n  }\n}\n\nfunction fieldRef(expr) {\n  const col = JSON.stringify(expr+'');\n  return !(expr.table || 0) ? `d=>d[${col}]` : `(a,b)=>b[${col}]`;\n}\n\nconst visitors = {\n  FunctionDeclaration: NO('Function definitions'),\n  ForStatement: NO('For loops'),\n  ForOfStatement: NO('For-of loops'),\n  ForInStatement: NO('For-in loops'),\n  WhileStatement: NO('While loops'),\n  DoWhileStatement: NO('Do-while loops'),\n  AwaitExpression: NO('Await expressions'),\n  ArrowFunctionExpression: NO('Function definitions'),\n  AssignmentExpression: NO('Assignments'),\n  FunctionExpression: NO('Function definitions'),\n  NewExpression: NO('Use of \"new\"'),\n  UpdateExpression: NO('Update expressions'),\n\n  VariableDeclarator(node, ctx) {\n    handleDeclaration(node.id, ctx);\n  },\n  Identifier(node, ctx, parent) {\n    if (handleIdentifier(node, ctx, parent) && !ctx.scope.has(node.name)) {\n      // handle identifier passed responsibility here\n      // raise error if identifier not defined in scope\n      ctx.error(node, ERROR_VARIABLE, ERROR_VARIABLE_NOTE);\n    }\n  },\n  CallExpression(node, ctx) {\n    const name = functionName(node.callee);\n    const def = getAggregate(name) || getWindow(name);\n\n    // parse operator and rewrite invocation\n    if (def) {\n      if ((ctx.join || ctx.aggregate === false) && hasAggregate(name)) {\n        ERROR_AGGREGATE(node, ctx);\n      }\n      if ((ctx.join || ctx.window === false) && hasWindow(name)) {\n        ERROR_WINDOW(node, ctx);\n      }\n\n      ctx.$op = 1;\n      if (ctx.ast) {\n        updateFunctionNode(node, name, ctx);\n        node.arguments.forEach(arg => walk(arg, ctx, opVisitors));\n      } else {\n        const op = ctx.op(parseOperator(ctx, def, name, node.arguments));\n        Object.assign(node, { type: Op, name: op.id });\n      }\n      ctx.$op = 0;\n      return false;\n    } else if (hasFunction(name)) {\n      updateFunctionNode(node, name, ctx);\n    } else {\n      ctx.error(node, ERROR_FUNCTION, ERROR_FUNCTION_NOTE);\n    }\n  },\n  MemberExpression(node, ctx, parent) {\n    const { object, property } = node;\n\n    // bail if left head is not an identifier\n    // in this case we will recurse and handle it later\n    if (!is(Identifier, object)) return;\n    const { name } = object;\n\n    // allow use of Math prefix to access constant values\n    if (isMath(node) && is(Identifier, property)\n        && Object.hasOwn(constants, property.name)) {\n      updateConstantNode(node, property.name);\n      return;\n    }\n\n    const index = name === ctx.tuple ? 0\n      : name === ctx.tuple1 ? 1\n      : name === ctx.tuple2 ? 2\n      : -1;\n\n    if (index >= 0) {\n      // replace member expression with column ref\n      return spliceMember(node, index, ctx, checkColumn, parent);\n    } else if (name === ctx.$param) {\n      // replace member expression with param ref\n      return spliceMember(node, index, ctx, checkParam);\n    } else if (ctx.paramsRef.has(name)) {\n      updateParameterNode(node, ctx.paramsRef.get(name));\n    } else if (ctx.columnRef.has(name)) {\n      updateColumnNode(object, name, ctx, node);\n    } else if (Object.hasOwn(ctx.params, name)) {\n      updateParameterNode(object, name);\n    }\n  }\n};\n\nfunction spliceMember(node, index, ctx, check, parent) {\n  const { property, computed } = node;\n  let name;\n\n  if (!computed) {\n    name = property.name;\n  } else if (is(Literal, property)) {\n    name = property.value;\n  } else try {\n    // visit subtree to ensure nodes are rewritten as needed\n    // then compile the code to compute the property name\n    walk(property, ctx, visitors, node);\n    name = ctx.param(property);\n  } catch (e) { // eslint-disable-line no-unused-vars\n    ctx.error(node, ERROR_MEMBER);\n  }\n\n  check(node, name, index, ctx, parent);\n  return false;\n}\n\nconst opVisitors = {\n  ...visitors,\n  VariableDeclarator: NO('Variable declaration in operator call'),\n  Identifier(node, ctx, parent) {\n    if (handleIdentifier(node, ctx, parent)) {\n      ctx.error(node, ERROR_VARIABLE_OP);\n    }\n  },\n  CallExpression(node, ctx) {\n    const name = functionName(node.callee);\n\n    // rewrite if built-in function\n    if (hasFunction(name)) {\n      updateFunctionNode(node, name, ctx);\n    } else {\n      ctx.error(node, ERROR_FUNCTION, ERROR_FUNCTION_NOTE);\n    }\n  }\n};\n\nfunction parseFunction(node, ctx) {\n  if (node.generator) NO('Generator functions')(node, ctx);\n  if (node.async) NO('Async functions')(node, ctx);\n\n  const { params } = node;\n  const len = params.length;\n  const setc = index => (name, key) => ctx.columnRef.set(name, [key, index]);\n  const setp = (name, key) => ctx.paramsRef.set(name, key);\n\n  if (!len) {\n    // do nothing\n  } else if (ctx.join) {\n    parseRef(ctx, params[0], 'tuple1', setc(1));\n    if (len > 1) parseRef(ctx, params[1], 'tuple2', setc(2));\n    if (len > 2) parseRef(ctx, params[2], '$param', setp);\n  } else {\n    parseRef(ctx, params[0], 'tuple', setc(0));\n    if (len > 1) parseRef(ctx, params[1], '$param', setp);\n  }\n\n  ctx.root = node.body;\n}\n\nfunction parseRef(ctx, node, refName, alias) {\n  if (is(Identifier, node)) {\n    ctx.scope.add(node.name);\n    ctx[refName] = node.name;\n  } else if (is(ObjectPattern, node)) {\n    node.properties.forEach(p => {\n      const key = is(Identifier, p.key) ? p.key.name\n        : is(Literal, p.key) ? p.key.value\n        : ctx.error(p, ERROR_ARGUMENT);\n      if (!is(Identifier, p.value)) {\n        ctx.error(p.value, ERROR_DESTRUCTURE);\n      }\n      alias(p.value.name, key);\n    });\n  }\n}\n\nfunction parseOperator(ctx, def, name, args) {\n  const fields = [];\n  const params = [];\n  const idxFields = def.param[0] || 0;\n  const idxParams = idxFields + (def.param[1] || 0);\n\n  args.forEach((arg, index) => {\n    if (index < idxFields) {\n      walk(arg, ctx, opVisitors);\n      fields.push(ctx.field(arg));\n    } else if (index < idxParams) {\n      walk(arg, ctx, opVisitors);\n      params.push(ctx.param(arg));\n    } else {\n      ctx.error(arg, ERROR_OP_PARAMETER);\n    }\n  });\n\n  return { name, fields, params, ...(ctx.spec.window || {}) };\n}\n\nfunction functionName(node) {\n  return is(Identifier, node) ? node.name\n    : !is(MemberExpression, node) ? null\n    : isMath(node) ? rewriteMath(node.property.name)\n    : node.property.name;\n}\n\nfunction isMath(node) {\n  return is(Identifier, node.object) && node.object.name === 'Math';\n}\n\nfunction rewriteMath(name) {\n  return name === 'max' ? 'greatest'\n    : name === 'min' ? 'least'\n    : name;\n}\n\nfunction handleIdentifier(node, ctx, parent) {\n  const { name } = node;\n\n  if (is(MemberExpression, parent) && parent.property === node) {\n    // do nothing: check head node, not nested properties\n  } else if (is(Property, parent) && parent.key === node) {\n    // do nothing: identifiers allowed in object expressions\n  } else if (ctx.paramsRef.has(name)) {\n    updateParameterNode(node, ctx.paramsRef.get(name));\n  } else if (ctx.columnRef.has(name)) {\n    updateColumnNode(node, name, ctx, parent);\n  } else if (Object.hasOwn(ctx.params, name)) {\n    updateParameterNode(node, name);\n  } else if (Object.hasOwn(constants, name)) {\n    updateConstantNode(node, name);\n  } else {\n    return true;\n  }\n}\n\nfunction checkColumn(node, name, index, ctx, parent) {\n  // check column existence if we have a backing table\n  const table = index === 0 ? ctx.table\n    : index > 0 ? ctx.join[index - 1]\n    : null;\n  const col = table && table.column(name);\n  if (table && !col) {\n    ctx.error(node, ERROR_COLUMN);\n  }\n\n  // check if column reference is valid in current context\n  if (ctx.aggronly && !ctx.$op) {\n    ctx.error(node, ERROR_AGGRONLY);\n  }\n\n  // rewrite ast node as a column access\n  rewrite(node, name, index, col, parent);\n}\n\nfunction updateColumnNode(node, key, ctx, parent) {\n  const [name, index] = ctx.columnRef.get(key);\n  checkColumn(node, name, index, ctx, parent);\n}\n\nfunction checkParam(node, name, index, ctx) {\n  if (ctx.params && !Object.hasOwn(ctx.params, name)) {\n    ctx.error(node, ERROR_PARAM);\n  }\n  updateParameterNode(node, name);\n}\n\nfunction updateParameterNode(node, name) {\n  node.type = Parameter;\n  node.name = name;\n}\n\nfunction updateConstantNode(node, name) {\n  node.type = Constant;\n  node.name = name;\n  node.raw = constants[name];\n}\n\nfunction updateFunctionNode(node, name, ctx) {\n  if (name === ROW_OBJECT) {\n    const t = ctx.table;\n    if (!t) ctx.error(node, ERROR_ROW_OBJECT);\n    rowObjectExpression(node, t,\n      node.arguments.length\n        ? node.arguments.map(node => {\n            const col = ctx.param(node);\n            const name = isNumber(col) ? t.columnName(col) : col;\n            if (!t.column(name)) ctx.error(node, ERROR_COLUMN);\n            return name;\n          })\n        : t.columnNames()\n    );\n  } else {\n    node.callee = { type: Function, name };\n  }\n}\n\nfunction handleDeclaration(node, ctx) {\n  if (is(Identifier, node)) {\n    ctx.scope.add(node.name);\n  } else if (is(ArrayPattern, node)) {\n    node.elements.forEach(elm => handleDeclaration(elm, ctx));\n  } else if (is(ObjectPattern, node)) {\n    node.properties.forEach(prop => handleDeclaration(prop.value, ctx));\n  } else {\n    ctx.error(node.id, ERROR_DECLARATION);\n  }\n}\n","import { entries } from '../util/entries.js';\nimport { error } from '../util/error.js';\nimport { isFunction } from '../util/is-function.js';\nimport { isObject } from '../util/is-object.js';\nimport { Column, Literal, Op } from './ast/constants.js';\nimport { clean } from './ast/clean.js';\nimport { is } from './ast/util.js';\nimport { codegen } from './codegen.js';\nimport { compile}  from './compile.js';\nimport { parseEscape } from './parse-escape.js';\nimport { parseExpression } from './parse-expression.js';\n\nconst ANNOTATE = { [Column]: 1, [Op]: 1 };\n\nexport function parse(input, opt = {}) {\n  const generate = opt.generate || codegen;\n  const compiler = opt.compiler || compile;\n  const params = getParams(opt);\n  const fields = {};\n  const opcall = {};\n  const names = [];\n  const exprs = [];\n  let fieldId = 0;\n  let opId = -1;\n\n  const compileExpr = opt.join ? compiler.join\n    : opt.index == 1 ? compiler.expr2\n    : compiler.expr;\n\n  // parser context\n  const ctx = {\n    op(op) {\n      const key = opKey(op);\n      return opcall[key] || (op.id = ++opId, opcall[key] = op);\n    },\n    field(node) {\n      const code = generate(node);\n      return fields[code] || (fields[code] = ++fieldId);\n    },\n    param(node) {\n      return is(Literal, node)\n        ? node.value\n        : compiler.param(generate(node), params);\n    },\n    value(name, node) {\n      names.push(name);\n      const e = node.escape || (opt.ast\n        ? clean(node)\n        : compileExpr(generate(node), params));\n      exprs.push(e);\n      // annotate expression if it is a direct column or op access\n      // this permits downstream optimizations\n      if (ANNOTATE[node.type] && e !== node && isObject(e)) {\n        e.field = node.name;\n      }\n    },\n    error(node, msg, note = '') {\n      // both expresions and fields are parsed\n      // with added code prefixes of length 6!\n      const i = node.start - 6;\n      const j = node.end - 6;\n      const snippet = String(ctx.spec).slice(i, j);\n      error(`${msg}: \"${snippet}\"${note}`);\n    }\n  };\n\n  // copy all options to context, potentially overwriting methods\n  Object.assign(ctx, opt, { params });\n\n  // parse each expression\n  for (const [name, value] of entries(input)) {\n    ctx.value(\n      name + '',\n      value.escape\n        ? parseEscape(ctx, value, params)\n        : parseExpression(ctx, value)\n    );\n  }\n\n  // return expression asts if requested\n  if (opt.ast) {\n    return { names, exprs };\n  }\n\n  // compile input field accessors\n  const f = [];\n  for (const key in fields) {\n    f[fields[key]] = compiler.expr(key, params);\n  }\n\n  // resolve input fields to operations\n  const ops = Object.values(opcall);\n  ops.forEach(op => op.fields = op.fields.map(id => f[id]));\n\n  return { names, exprs, ops };\n}\n\nfunction opKey(op) {\n  let key = `${op.name}(${op.fields.concat(op.params).join(',')})`;\n  if (op.frame) {\n    const frame = op.frame.map(v => Number.isFinite(v) ? Math.abs(v) : -1);\n    key += `[${frame},${!!op.peers}]`;\n  }\n  return key;\n}\n\nfunction getParams(opt) {\n  return (opt.table ? getTableParams(opt.table)\n    : opt.join ? {\n        ...getTableParams(opt.join[1]),\n        ...getTableParams(opt.join[0])\n      }\n    : {}) || {};\n}\n\nfunction getTableParams(table) {\n  return table && isFunction(table.params) ? table.params() : {};\n}\n","import { isFunction } from '../util/is-function.js';\n\n/**\n * Annotate an expression in an object wrapper.\n * @param {string|Function|object} expr An expression to annotate.\n * @param {object} properties The properties to annotate with.\n * @return {object} A new wrapped expression object.\n */\nexport function wrap(expr, properties) {\n  return expr && expr.expr\n    ? new Wrapper({ ...expr, ...properties })\n    : new Wrapper(properties, expr);\n}\n\nclass Wrapper {\n  constructor(properties, expr) {\n    this.expr = expr;\n    Object.assign(this, properties);\n  }\n  toString() {\n    return String(this.expr);\n  }\n  toObject() {\n    return {\n      ...this,\n      expr: this.toString(),\n      ...(isFunction(this.expr) ? { func: true } : {})\n    };\n  }\n}\n","import { wrap } from './wrap.js';\n\n/**\n * Annotate an expression to indicate it is a string field reference.\n * @param {string|object} expr The column name, or an existing wrapped\n *  expression for a column name.\n * @param {string} [name] The column name to use. If provided, will\n *  overwrite the input expression value.\n * @param {number} [table=0] The table index of the field, in case of\n *  expressions over multiple tables.\n * @return A wrapped expression for a named column.\n * @example field('colA')\n */\nexport function field(expr, name, table = 0) {\n  const props = table ? { field: true, table } : { field: true };\n  return wrap(\n    expr,\n    name ? { expr: name, ...props } : props\n  );\n}\n","import { entries } from './entries.js';\n\nexport function assign(map, pairs) {\n  for (const [key, value] of entries(pairs)) {\n    map.set(key, value);\n  }\n  return map;\n}\n","export function escapeRegExp(str) {\n  return str.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n","import { assign } from '../util/assign.js';\nimport { error } from '../util/error.js';\nimport { escapeRegExp } from '../util/escape-regexp.js';\nimport { isArray } from '../util/is-array.js';\nimport { isFunction } from '../util/is-function.js';\nimport { isNumber } from '../util/is-number.js';\nimport { isObject } from '../util/is-object.js';\nimport { isString } from '../util/is-string.js';\nimport { toString } from '../util/to-string.js';\n\nexport function resolve(table, sel, map = new Map()) {\n  sel = isNumber(sel) ? table.columnName(sel) : sel;\n\n  if (isString(sel)) {\n    map.set(sel, sel);\n  } else if (isArray(sel)) {\n    sel.forEach(r => resolve(table, r, map));\n  } else if (isFunction(sel)) {\n    resolve(table, sel(table), map);\n  } else if (isObject(sel)) {\n    assign(map, sel);\n  } else {\n    error(`Invalid column selection: ${toString(sel)}`);\n  }\n\n  return map;\n}\n\nfunction decorate(value, toObject) {\n  value.toObject = toObject;\n  return value;\n}\n\nfunction toObject(value) {\n  return isArray(value) ? value.map(toObject)\n    : value && value.toObject ? value.toObject()\n    : value;\n}\n\n/**\n * Proxy type for SelectHelper function.\n * @typedef {import('../table/types.js').SelectHelper} SelectHelper\n */\n\n/**\n * Select all columns in a table.\n * Returns a function-valued selection compatible with {@link Table#select}.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function all() {\n  return decorate(\n    table => table.columnNames(),\n    () => ({ all: [] })\n  );\n}\n\n/**\n * Negate a column selection, selecting all other columns in a table.\n * Returns a function-valued selection compatible with {@link Table#select}.\n * @param {...any} selection The selection to negate. May be a column name,\n *  column index, array of either, or a selection function (e.g., from range).\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function not(...selection) {\n  selection = selection.flat();\n  return decorate(\n    table => {\n      const drop = resolve(table, selection);\n      return table.columnNames(name => !drop.has(name));\n    },\n    () => ({ not: toObject(selection) })\n  );\n}\n\n/**\n * Select a contiguous range of columns.\n * @param {string|number} start The name/index of the first selected column.\n * @param {string|number} end The name/index of the last selected column.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function range(start, end) {\n  return decorate(\n    table => {\n      let i = isNumber(start) ? start : table.columnIndex(start);\n      let j = isNumber(end) ? end : table.columnIndex(end);\n      if (j < i) { const t = j; j = i; i = t; }\n      return table.columnNames().slice(i, j + 1);\n    },\n    () => ({ range: [start, end] })\n  );\n}\n\n/**\n * Select all columns whose names match a pattern.\n * @param {string|RegExp} pattern A string or regular expression pattern to match.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function matches(pattern) {\n  if (isString(pattern)) pattern = RegExp(escapeRegExp(pattern));\n  return decorate(\n    // @ts-ignore\n    table => table.columnNames(name => pattern.test(name)),\n    // @ts-ignore\n    () => ({ matches: [pattern.source, pattern.flags] })\n  );\n}\n\n/**\n * Select all columns whose names start with a string.\n * @param {string} string The string to match at the start of the column name.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function startswith(string) {\n  return matches(RegExp('^' + escapeRegExp(string)));\n}\n\n/**\n * Select all columns whose names end with a string.\n * @param {string} string The string to match at the end of the column name.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function endswith(string) {\n  return matches(RegExp(escapeRegExp(string) + '$'));\n}\n","import { parse } from '../../expression/parse.js';\nimport { field } from '../../helpers/field.js';\nimport { resolve } from '../../helpers/selection.js';\nimport { assign } from '../../util/assign.js';\nimport { error } from '../../util/error.js';\nimport { isNumber } from '../../util/is-number.js';\nimport { isObject } from '../../util/is-object.js';\nimport { isString } from '../../util/is-string.js';\nimport { isFunction } from '../../util/is-function.js';\nimport { toArray } from '../../util/to-array.js';\n\nexport function parseValue(name, table, params, options = { window: false }) {\n  const exprs = new Map();\n\n  const marshal = param => {\n    param = isNumber(param) ? table.columnName(param) : param;\n    isString(param) ? exprs.set(param, field(param))\n      : isFunction(param) ? resolve(table, param).forEach(marshal)\n      : isObject(param) ? assign(exprs, param)\n      : error(`Invalid ${name} value: ${param+''}`);\n  };\n\n  toArray(params).forEach(marshal);\n\n  if (options.preparse) {\n    options.preparse(exprs);\n  }\n\n  return parse(exprs, { table, ...options });\n}\n","import { aggregateGet } from './reduce/util.js';\nimport { parseValue } from './util/parse.js';\nimport { keyFunction } from '../util/key-function.js';\n\nexport function groupby(table, ...values) {\n  return _groupby(table, parseValue('groupby', table, values.flat()));\n}\n\nexport function _groupby(table, exprs) {\n  return table.create({\n    groups: createGroups(table, exprs)\n  });\n}\n\nfunction createGroups(table, { names = [], exprs = [], ops = [] }) {\n  const n = names.length;\n  if (n === 0) return null;\n\n  // check for optimized path when grouping by a single field\n  // use pre-calculated groups if available\n  if (n === 1 && !table.isFiltered() && exprs[0].field) {\n    const col = table.column(exprs[0].field);\n    if (col.groups) return col.groups(names);\n  }\n\n  let get = aggregateGet(table, ops, exprs);\n  const getKey = keyFunction(get);\n  const nrows = table.totalRows();\n  const keys = new Uint32Array(nrows);\n  const index = {};\n  const rows = [];\n\n  // inline table scan for performance\n  const data = table.data();\n  const bits = table.mask();\n  if (bits) {\n    for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n      const key = getKey(i, data) + '';\n      keys[i] = (index[key] ??= rows.push(i) - 1);\n    }\n  } else {\n    for (let i = 0; i < nrows; ++i) {\n      const key = getKey(i, data) + '';\n      keys[i] = (index[key] ??= rows.push(i) - 1);\n    }\n  }\n\n  if (!ops.length) {\n    // capture data in closure, so no interaction with select\n    get = get.map(f => row => f(row, data));\n  }\n\n  return { keys, get, names, rows, size: rows.length };\n}\n","/**\n * Return a new column set instance.\n * @param {import('./Table.js').Table} [table] A base table whose columns\n *  should populate the returned set. If unspecified, create an empty set.\n * @return {ColumnSet} The column set.\n */\nexport function columnSet(table) {\n  return table\n    ? new ColumnSet({ ...table.data() }, table.columnNames())\n    : new ColumnSet();\n}\n\n/** An editable collection of named columns. */\nexport class ColumnSet {\n  /**\n   * Create a new column set instance.\n   * @param {import('./types.js').ColumnData} [data] Initial column data.\n   * @param {string[]} [names] Initial column names.\n   */\n  constructor(data, names) {\n    this.data = data || {};\n    this.names = names || [];\n  }\n\n  /**\n   * Add a new column to this set and return the column values.\n   * @template {import('./types.js').ColumnType} T\n   * @param {string} name The column name.\n   * @param {T} values The column values.\n   * @return {T} The provided column values.\n   */\n  add(name, values) {\n    if (!this.has(name)) this.names.push(name + '');\n    return this.data[name] = values;\n  }\n\n  /**\n   * Test if this column set has a columns with the given name.\n   * @param {string} name A column name\n   * @return {boolean} True if this set contains a column with the given name,\n   *  false otherwise.\n   */\n  has(name) {\n    return Object.hasOwn(this.data, name);\n  }\n\n  /**\n   * Add a groupby specification to this column set.\n   * @param {import('./types.js').GroupBySpec} groups A groupby specification.\n   * @return {this} This column set.\n   */\n  groupby(groups) {\n    this.groups = groups;\n    return this;\n  }\n\n  /**\n   * Create a new table with the contents of this column set, using the same\n   * type as a given prototype table. The new table does not inherit the\n   * filter, groupby, or orderby state of the prototype.\n   * @template {import('./Table.js').Table} T\n   * @param {T} proto A prototype table\n   * @return {T} The new table.\n   */\n  new(proto) {\n    const { data, names, groups = null } = this;\n    return proto.create({ data, names, groups, filter: null, order: null });\n  }\n\n  /**\n   * Create a derived table with the contents of this column set, using the same\n   * type as a given prototype table. The new table will inherit the filter,\n   * groupby, and orderby state of the prototype.\n   * @template {import('./Table.js').Table} T\n   * @param {T} proto A prototype table\n   * @return {T} The new table.\n   */\n  derive(proto) {\n    return proto.create(this);\n  }\n}\n","import { aggregate, groupOutput } from './reduce/util.js';\nimport { parse } from '../expression/parse.js';\nimport { columnSet } from '../table/ColumnSet.js';\n\nexport function rollup(table, values) {\n  return _rollup(table, parse(values, { table, aggronly: true, window: false }));\n}\n\nexport function _rollup(table, { names, exprs, ops = [] }) {\n  // output data\n  const cols = columnSet();\n  const groups = table.groups();\n\n  // write groupby fields to output\n  if (groups) groupOutput(cols, groups);\n\n  // compute and write aggregate output\n  output(names, exprs, groups, aggregate(table, ops), cols);\n\n  // return output table\n  return cols.new(table);\n}\n\nfunction output(names, exprs, groups, result = [], cols) {\n  if (!exprs.length) return;\n  const size = groups ? groups.size : 1;\n  const op = (id, row) => result[id][row];\n  const n = names.length;\n\n  for (let i = 0; i < n; ++i) {\n    const get = exprs[i];\n    if (get.field != null) {\n      // if expression is op only, use aggregates directly\n      cols.add(names[i], result[get.field]);\n    } else if (size > 1) {\n      // if multiple groups, evaluate expression for each\n      const col = cols.add(names[i], Array(size));\n      for (let j = 0; j < size; ++j) {\n        col[j] = get(j, null, op);\n      }\n    } else {\n      // if only one group, no need to loop\n      cols.add(names[i], [ get(0, null, op) ]);\n    }\n  }\n}\n","import { resolve } from '../helpers/selection.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { error } from '../util/error.js';\nimport { isString } from '../util/is-string.js';\n\nexport function select(table, ...columns) {\n  return _select(table, resolve(table, columns.flat()));\n}\n\nexport function _select(table, columns) {\n  const cols = columnSet();\n\n  columns.forEach((value, curr) => {\n    const next = isString(value) ? value : curr;\n    if (next) {\n      const col = table.column(curr) || error(`Unrecognized column: ${curr}`);\n      cols.add(next, col);\n    }\n  });\n\n  return cols.derive(table);\n}\n","import { array_agg, entries_agg, map_agg, object_agg } from '../op/op-api.js';\nimport { error } from '../util/error.js';\nimport { uniqueName } from '../util/unique-name.js';\nimport { groupby } from '../verbs/groupby.js';\nimport { rollup } from '../verbs/rollup.js';\nimport { select } from '../verbs/select.js';\n\n/**\n * Regroup table rows in response to a BitSet filter.\n * @param {import('./types.js').GroupBySpec} groups The current groupby specification.\n * @param {import('./BitSet.js').BitSet} filter The filter to apply.\n */\nexport function regroup(groups, filter) {\n  if (!groups || !filter) return groups;\n\n  // check for presence of rows for each group\n  const { keys, rows, size } = groups;\n  const map = new Uint32Array(size);\n  filter.scan(row => map[keys[row]] = 1);\n\n  // check sum, exit early if all groups occur\n  const sum = map.reduce((sum, val) => sum + val, 0);\n  if (sum === size) return groups;\n\n  // create group index map, filter exemplar rows\n  const _rows = Array(sum);\n  let _size = 0;\n  for (let i = 0; i < size; ++i) {\n    if (map[i]) _rows[map[i] = _size++] = rows[i];\n  }\n\n  // re-index the group keys\n  const _keys = new Uint32Array(keys.length);\n  filter.scan(row => _keys[row] = map[keys[row]]);\n\n  return { ...groups, keys: _keys, rows: _rows, size: _size };\n}\n\n/**\n * Regroup table rows in response to a re-indexing.\n * This operation may or may not involve filtering of rows.\n * @param {import('./types.js').GroupBySpec} groups\n *  The current groupby specification.\n * @param {Function} scan Function to scan new row indices.\n * @param {boolean} filter Flag indicating if filtering may occur.\n * @param {number} nrows The number of rows in the new table.\n */\nexport function reindex(groups, scan, filter, nrows) {\n  const { keys, rows, size } = groups;\n  let _rows = rows;\n  let _size = size;\n  let map = null;\n\n  if (filter) {\n    // check for presence of rows for each group\n    map = new Int32Array(size);\n    scan(row => map[keys[row]] = 1);\n\n    // check sum, regroup if not all groups occur\n    const sum = map.reduce((sum, val) => sum + val, 0);\n    if (sum !== size) {\n      // create group index map, filter exemplar rows\n      _rows = Array(sum);\n      _size = 0;\n      for (let i = 0; i < size; ++i) {\n        if (map[i]) _rows[map[i] = _size++] = rows[i];\n      }\n    }\n  }\n\n  // re-index the group keys\n  let r = -1;\n  const _keys = new Uint32Array(nrows);\n  const fn = _size !== size\n    ? row => _keys[++r] = map[keys[row]]\n    : row => _keys[++r] = keys[row];\n  scan(fn);\n\n  return { ...groups, keys: _keys, rows: _rows, size: _size };\n}\n\nexport function nest(table, idx, obj, type) {\n  const agg = type === 'map' || type === true ? map_agg\n    : type === 'entries' ? entries_agg\n    : type === 'object' ? object_agg\n    : error('groups option must be \"map\", \"entries\", or \"object\".');\n\n  const { names } = table.groups();\n  const col = uniqueName(table.columnNames(), '_');\n\n  // create table with one column of row objects\n  // then aggregate into per-group arrays\n  let t = select(table, {}).reify(idx).create({ data: { [col]: obj } });\n  t = rollup(t, { [col]: array_agg(col) });\n\n  // create nested structures for each level of grouping\n  for (let i = names.length; --i >= 0;) {\n    t = rollup(\n        groupby(t, names.slice(0, i)),\n        // @ts-ignore\n        { [col]: agg(names[i], col) }\n      );\n  }\n\n  // return the final aggregated structure\n  return t.get(col);\n}\n","import { isMapOrSet } from './is-map-or-set.js';\n\nexport function uniqueName(names, name) {\n  names = isMapOrSet(names) ? names : new Set(names);\n  let uname = name;\n  let index = 0;\n\n  while (names.has(uname)) {\n    uname = name + ++index;\n  }\n\n  return uname;\n}\n","import { nest, regroup, reindex } from './regroup.js';\nimport { rowObjectBuilder } from '../expression/row-object.js';\nimport { all, resolve } from '../helpers/selection.js';\nimport { arrayType } from '../util/array-type.js';\nimport { error } from '../util/error.js';\nimport { isArrayType } from '../util/is-array-type.js';\nimport { isNumber } from '../util/is-number.js';\nimport { repeat } from '../util/repeat.js';\n\n/**\n * Base class representing a column-oriented data table.\n */\nexport class Table {\n  /**\n   * Instantiate a Table instance.\n   * @param {import('./types.js').ColumnData} columns\n   *  An object mapping column names to values.\n   * @param {string[]} [names]\n   *  An ordered list of column names.\n   * @param {import('./BitSet.js').BitSet} [filter]\n   *  A filtering BitSet.\n   * @param {import('./types.js').GroupBySpec} [group]\n   *  A groupby specification.\n   * @param {import('./types.js').RowComparator} [order]\n   *  A row comparator function.\n   * @param {import('./types.js').Params} [params]\n   *  An object mapping parameter names to values.\n   */\n  constructor(columns, names, filter, group, order, params) {\n    const data = Object.freeze({ ...columns });\n    names = names?.slice() ?? Object.keys(data);\n    const nrows = names.length ? data[names[0]].length : 0;\n    /**\n     * @private\n     * @type {readonly string[]}\n     */\n    this._names = Object.freeze(names);\n    /**\n     * @private\n     * @type {import('./types.js').ColumnData}\n     */\n    this._data = data;\n    /**\n     * @private\n     * @type {number}\n     */\n    this._total = nrows;\n    /**\n     * @private\n     * @type {number}\n     */\n    this._nrows = filter?.count() ?? nrows;\n    /**\n     * @private\n     * @type {import('./BitSet.js').BitSet}\n     */\n    this._mask = filter ?? null;\n    /**\n     * @private\n     * @type {import('./types.js').GroupBySpec}\n     */\n    this._group = group ?? null;\n    /**\n     * @private\n     * @type {import('./types.js').RowComparator}\n     */\n    this._order = order ?? null;\n    /**\n     * @private\n     * @type {import('./types.js').Params}\n     */\n    this._params = params;\n    /**\n     * @private\n     * @type {Uint32Array}\n     */\n    this._index = null;\n    /**\n     * @private\n     * @type {number[][] | Uint32Array[]}\n     */\n    this._partitions = null;\n  }\n\n  /**\n   * Create a new table with the same type as this table.\n   * The new table may have different data, filter, grouping, or ordering\n   * based on the values of the optional configuration argument. If a\n   * setting is not specified, it is inherited from the current table.\n   * @param {import('./types.js').CreateOptions} [options]\n   *  Creation options for the new table.\n   * @return {this} A newly created table.\n   */\n  create({\n    data = undefined,\n    names = undefined,\n    filter = undefined,\n    groups = undefined,\n    order = undefined\n  } = {}) {\n    const f = filter !== undefined ? filter : this.mask();\n    // @ts-ignore\n    return new this.constructor(\n      data || this._data,\n      names || (!data ? this._names : null),\n      f,\n      groups !== undefined ? groups : regroup(this._group, filter && f),\n      order !== undefined ? order : this._order,\n      this._params\n    );\n  }\n\n  /**\n   * Get or set table expression parameter values.\n   * If called with no arguments, returns the current parameter values\n   * as an object. Otherwise, adds the provided parameters to this\n   * table's parameter set and returns the table. Any prior parameters\n   * with names matching the input parameters are overridden.\n   * @param {import('./types.js').Params} [values]\n   *  The parameter values.\n   * @return {this|import('./types.js').Params}\n   *  The current parameter values (if called with no arguments) or this table.\n   */\n  params(values) {\n    if (arguments.length) {\n      if (values) {\n        this._params = { ...this._params, ...values };\n      }\n      return this;\n    } else {\n      return this._params;\n    }\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    if (!this._names) return 'Object'; // bail if called on prototype\n    const nr = this.numRows();\n    const nc = this.numCols();\n    const plural = v => v !== 1 ? 's' : '';\n    return `Table: ${nc} col${plural(nc)} x ${nr} row${plural(nr)}`\n      + (this.isFiltered() ? ` (${this.totalRows()} backing)` : '')\n      + (this.isGrouped() ? `, ${this._group.size} groups` : '')\n      + (this.isOrdered() ? ', ordered' : '');\n  }\n\n  /**\n   * Indicates if the table has a filter applied.\n   * @return {boolean} True if filtered, false otherwise.\n   */\n  isFiltered() {\n    return !!this._mask;\n  }\n\n  /**\n   * Indicates if the table has a groupby specification.\n   * @return {boolean} True if grouped, false otherwise.\n   */\n  isGrouped() {\n    return !!this._group;\n  }\n\n  /**\n   * Indicates if the table has a row order comparator.\n   * @return {boolean} True if ordered, false otherwise.\n   */\n  isOrdered() {\n    return !!this._order;\n  }\n\n  /**\n   * Get the backing column data for this table.\n   * @return {import('./types.js').ColumnData}\n   *  Object of named column instances.\n   */\n  data() {\n    return this._data;\n  }\n\n  /**\n   * Returns the filter bitset mask, if defined.\n   * @return {import('./BitSet.js').BitSet} The filter bitset mask.\n   */\n  mask() {\n    return this._mask;\n  }\n\n  /**\n   * Returns the groupby specification, if defined.\n   * @return {import('./types.js').GroupBySpec} The groupby specification.\n   */\n  groups() {\n    return this._group;\n  }\n\n  /**\n   * Returns the row order comparator function, if specified.\n   * @return {import('./types.js').RowComparator}\n   *  The row order comparator function.\n   */\n  comparator() {\n    return this._order;\n  }\n\n  /**\n   * The total number of rows in this table, counting both\n   * filtered and unfiltered rows.\n   * @return {number} The number of total rows.\n   */\n  totalRows() {\n    return this._total;\n  }\n\n  /**\n   * The number of active rows in this table. This number may be\n   * less than the *totalRows* if the table has been filtered.\n   * @return {number} The number of rows.\n   */\n  numRows() {\n    return this._nrows;\n  }\n\n  /**\n   * The number of active rows in this table. This number may be\n   * less than the *totalRows* if the table has been filtered.\n   * @return {number} The number of rows.\n   */\n  get size() {\n    return this._nrows;\n  }\n\n  /**\n   * The number of columns in this table.\n   * @return {number} The number of columns.\n   */\n  numCols() {\n    return this._names.length;\n  }\n\n  /**\n   * Filter function invoked for each column name.\n   * @callback NameFilter\n   * @param {string} name The column name.\n   * @param {number} index The column index.\n   * @param {string[]} array The array of names.\n   * @return {boolean} Returns true to retain the column name.\n   */\n\n  /**\n   * The table column names, optionally filtered.\n   * @param {NameFilter} [filter] An optional filter function.\n   *  If unspecified, all column names are returned.\n   * @return {string[]} An array of matching column names.\n   */\n  columnNames(filter) {\n    return filter ? this._names.filter(filter) : this._names.slice();\n  }\n\n  /**\n   * The column name at the given index.\n   * @param {number} index The column index.\n   * @return {string} The column name,\n   *  or undefined if the index is out of range.\n   */\n  columnName(index) {\n    return this._names[index];\n  }\n\n  /**\n   * The column index for the given name.\n   * @param {string} name The column name.\n   * @return {number} The column index, or -1 if the name is not found.\n   */\n  columnIndex(name) {\n    return this._names.indexOf(name);\n  }\n\n  /**\n   * Get the column instance with the given name.\n   * @param {string} name The column name.\n   * @return {import('./types.js').ColumnType | undefined}\n   *  The named column, or undefined if it does not exist.\n   */\n  column(name) {\n    return this._data[name];\n  }\n\n  /**\n   * Get the column instance at the given index position.\n   * @param {number} index The zero-based column index.\n   * @return {import('./types.js').ColumnType | undefined}\n   *  The column, or undefined if it does not exist.\n   */\n  columnAt(index) {\n    return this._data[this._names[index]];\n  }\n\n  /**\n   * Get an array of values contained in a column. The resulting array\n   * respects any table filter or orderby criteria.\n   * @param {string} name The column name.\n   * @param {ArrayConstructor | import('./types.js').TypedArrayConstructor} [constructor=Array]\n   *  The array constructor for instantiating the output array.\n   * @return {import('./types.js').DataValue[] | import('./types.js').TypedArray}\n   *  The array of column values.\n   */\n  array(name, constructor = Array) {\n    const column = this.column(name);\n    const array = new constructor(this.numRows());\n    let idx = -1;\n    this.scan(row => array[++idx] = column.at(row), true);\n    return array;\n  }\n\n  /**\n   * Get the value for the given column and row.\n   * @param {string} name The column name.\n   * @param {number} [row=0] The row index, defaults to zero if not specified.\n   * @return {import('./types.js').DataValue} The table value at (column, row).\n   */\n  get(name, row = 0) {\n    const column = this.column(name);\n    return this.isFiltered() || this.isOrdered()\n      ? column.at(this.indices()[row])\n      : column.at(row);\n  }\n\n  /**\n   * Returns an accessor (\"getter\") function for a column. The returned\n   * function takes a row index as its single argument and returns the\n   * corresponding column value.\n   * @param {string} name The column name.\n   * @return {import('./types.js').ColumnGetter} The column getter function.\n   */\n  getter(name) {\n    const column = this.column(name);\n    const indices = this.isFiltered() || this.isOrdered() ? this.indices() : null;\n    if (indices) {\n      return row => column.at(indices[row]);\n    } else if (column) {\n      return row => column.at(row);\n    } else {\n      error(`Unrecognized column: ${name}`);\n    }\n  }\n\n  /**\n   * Returns an object representing a table row.\n   * @param {number} [row=0] The row index, defaults to zero if not specified.\n   * @return {object} A row object with named properties for each column.\n   */\n  object(row = 0) {\n    return objectBuilder(this)(row);\n  }\n\n  /**\n   * Returns an array of objects representing table rows.\n   * @param {import('./types.js').ObjectsOptions} [options]\n   *  The options for row object generation.\n   * @return {object[]} An array of row objects.\n   */\n  objects(options = {}) {\n    const { grouped, limit, offset } = options;\n\n    // generate array of row objects\n    const names = resolve(this, options.columns || all());\n    const createRow = rowObjectBuilder(this, names);\n    const obj = [];\n    this.scan(\n      (row, data) => obj.push(createRow(row, data)),\n      true, limit, offset\n    );\n\n    // produce nested output as requested\n    if (grouped && this.isGrouped()) {\n      const idx = [];\n      this.scan(row => idx.push(row), true, limit, offset);\n      return nest(this, idx, obj, grouped);\n    }\n\n    return obj;\n  }\n\n  /**\n   * Returns an iterator over objects representing table rows.\n   * @return {Iterator<object>} An iterator over row objects.\n   */\n  *[Symbol.iterator]() {\n    const createRow = objectBuilder(this);\n    const n = this.numRows();\n    for (let i = 0; i < n; ++i) {\n      yield createRow(i);\n    }\n  }\n\n  /**\n   * Returns an iterator over column values.\n   * @return {Iterator<object>} An iterator over row objects.\n   */\n  *values(name) {\n    const get = this.getter(name);\n    const n = this.numRows();\n    for (let i = 0; i < n; ++i) {\n      yield get(i);\n    }\n  }\n\n  /**\n   * Print the contents of this table using the console.table() method.\n   * @param {import('./types.js').PrintOptions|number} options\n   *  The options for row object generation, determining which rows and\n   *  columns are printed. If number-valued, specifies the row limit.\n   * @return {this} The table instance.\n   */\n  print(options = {}) {\n    const opt = isNumber(options)\n      ? { limit: +options }\n      // @ts-ignore\n      : { ...options, limit: 10 };\n\n    const obj = this.objects({ ...opt, grouped: false });\n    const msg = `${this[Symbol.toStringTag]}. Showing ${obj.length} rows.`;\n\n    console.log(msg);   // eslint-disable-line no-console\n    console.table(obj); // eslint-disable-line no-console\n    return this;\n  }\n\n  /**\n   * Returns an array of indices for all rows passing the table filter.\n   * @param {boolean} [order=true] A flag indicating if the returned\n   *  indices should be sorted if this table is ordered. If false, the\n   *  returned indices may or may not be sorted.\n   * @return {Uint32Array} An array of row indices.\n   */\n  indices(order = true) {\n    if (this._index) return this._index;\n\n    const n = this.numRows();\n    const index = new Uint32Array(n);\n    const ordered = this.isOrdered();\n    const bits = this.mask();\n    let row = -1;\n\n    // inline the following for performance:\n    // this.scan(row => index[++i] = row);\n    if (bits) {\n      for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n        index[++row] = i;\n      }\n    } else {\n      for (let i = 0; i < n; ++i) {\n        index[++row] = i;\n      }\n    }\n\n    // sort index vector\n    if (order && ordered) {\n      const { _order, _data } = this;\n      index.sort((a, b) => _order(a, b, _data));\n    }\n\n    // save indices if they reflect table metadata\n    if (order || !ordered) {\n      this._index = index;\n    }\n\n    return index;\n  }\n\n  /**\n   * Returns an array of indices for each group in the table.\n   * If the table is not grouped, the result is the same as\n   * the *indices* method, but wrapped within an array.\n   * @param {boolean} [order=true] A flag indicating if the returned\n   *  indices should be sorted if this table is ordered. If false, the\n   *  returned indices may or may not be sorted.\n   * @return {number[][] | Uint32Array[]} An array of row index arrays, one\n   *  per group. The indices will be filtered if the table is filtered.\n   */\n  partitions(order = true) {\n    // return partitions if already generated\n    if (this._partitions) {\n      return this._partitions;\n    }\n\n    // if not grouped, return a single partition\n    if (!this.isGrouped()) {\n      return [ this.indices(order) ];\n    }\n\n    // generate partitions\n    const { keys, size } = this._group;\n    const part = repeat(size, () => []);\n\n    // populate partitions, don't sort if indices don't exist\n    // inline the following for performance:\n    // this.scan(row => part[keys[row]].push(row), sort);\n    const sort = this._index;\n    const bits = this.mask();\n    const n = this.numRows();\n    if (sort && this.isOrdered()) {\n      for (let i = 0, r; i < n; ++i) {\n        r = sort[i];\n        part[keys[r]].push(r);\n      }\n    } else if (bits) {\n      for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n        part[keys[i]].push(i);\n      }\n    } else {\n      for (let i = 0; i < n; ++i) {\n        part[keys[i]].push(i);\n      }\n    }\n\n    // if ordered but not yet sorted, sort partitions directly\n    if (order && !sort && this.isOrdered()) {\n      const compare = this._order;\n      const data = this._data;\n      for (let i = 0; i < size; ++i) {\n        part[i].sort((a, b) => compare(a, b, data));\n      }\n    }\n\n    // save partitions if they reflect table metadata\n    if (order || !this.isOrdered()) {\n      this._partitions = part;\n    }\n\n    return part;\n  }\n\n  /**\n   * Create a new fully-materialized instance of this table.\n   * All filter and orderby settings are removed from the new table.\n   * Instead, the backing data itself is filtered and ordered as needed.\n   * @param {number[]} [indices] Ordered row indices to materialize.\n   *  If unspecified, all rows passing the table filter are used.\n   * @return {this} A reified table.\n   */\n  reify(indices) {\n    const nrows = indices ? indices.length : this.numRows();\n    const names = this._names;\n    let data, groups;\n\n    if (!indices && !this.isOrdered()) {\n      if (!this.isFiltered()) {\n        return this; // data already reified\n      } else if (nrows === this.totalRows()) {\n        data = this.data(); // all rows pass filter, skip copy\n      }\n    }\n\n    if (!data) {\n      const scan = indices ? f => indices.forEach(f) : f => this.scan(f, true);\n      const ncols = names.length;\n      data = {};\n\n      for (let i = 0; i < ncols; ++i) {\n        const name = names[i];\n        const prev = this.column(name);\n        const curr = data[name] = new (arrayType(prev))(nrows);\n        let r = -1;\n        // optimize array access\n        isArrayType(prev)\n          ? scan(row => curr[++r] = prev[row])\n          : scan(row => curr[++r] = prev.at(row));\n      }\n\n      if (this.isGrouped()) {\n        groups = reindex(this.groups(), scan, !!indices, nrows);\n      }\n    }\n\n    return this.create({ data, names, groups, filter: null, order: null });\n  }\n\n  /**\n   * Callback function to cancel a table scan.\n   * @callback ScanStop\n   * @return {void}\n   */\n\n  /**\n   * Callback function invoked for each row of a table scan.\n   * @callback ScanVisitor\n   * @param {number} [row] The table row index.\n   * @param {import('./types.js').ColumnData} [data]\n   *  The backing table data store.\n   * @param {ScanStop} [stop] Function to stop the scan early.\n   *  Callees can invoke this function to prevent future calls.\n   * @return {void}\n   */\n\n  /**\n   * Perform a table scan, visiting each row of the table.\n   * If this table is filtered, only rows passing the filter are visited.\n   * @param {ScanVisitor} fn Callback invoked for each row of the table.\n   * @param {boolean} [order=false] Indicates if the table should be\n   *  scanned in the order determined by *orderby*. This\n   *  argument has no effect if the table is unordered.\n   * @property {number} [limit=Infinity] The maximum number of rows to scan.\n   * @property {number} [offset=0] The row offset indicating how many\n   *  initial rows to skip.\n   */\n  scan(fn, order, limit = Infinity, offset = 0) {\n    const filter = this._mask;\n    const nrows = this._nrows;\n    const data = this._data;\n\n    let i = offset || 0;\n    if (i > nrows) return;\n\n    const n = Math.min(nrows, i + limit);\n    const stop = () => i = this._total;\n\n    if (order && this.isOrdered() || filter && this._index) {\n      const index = this.indices();\n      const data = this._data;\n      for (; i < n; ++i) {\n        fn(index[i], data, stop);\n      }\n    } else if (filter) {\n      let c = n - i + 1;\n      for (i = filter.nth(i); --c && i > -1; i = filter.next(i + 1)) {\n        fn(i, data, stop);\n      }\n    } else {\n      for (; i < n; ++i) {\n        fn(i, data, stop);\n      }\n    }\n  }\n}\n\nfunction objectBuilder(table) {\n  let b = table._builder;\n\n  if (!b) {\n    const createRow = rowObjectBuilder(table);\n    const data = table.data();\n    if (table.isOrdered() || table.isFiltered()) {\n      const indices = table.indices();\n      b = row => createRow(indices[row], data);\n    } else {\n      b = row => createRow(row, data);\n    }\n    table._builder = b;\n  }\n\n  return b;\n}\n","import { isTypedArray } from './is-typed-array.js';\n\n/**\n * @param {*} column\n * @returns {ArrayConstructor | import('../table/types.js').TypedArrayConstructor}\n */\nexport function arrayType(column) {\n  // @ts-ignore\n  return isTypedArray(column) ? column.constructor : Array;\n}\n","import { columnSet } from '../table/ColumnSet.js';\nimport { NULL } from '../util/null.js';\n\nexport function concat(table, ...others) {\n  others = others.flat();\n  const trows = table.numRows();\n  const nrows = trows + others.reduce((n, t) => n + t.numRows(), 0);\n  if (trows === nrows) return table;\n\n  const tables = [table, ...others];\n  const cols = columnSet();\n\n  table.columnNames().forEach(name => {\n    const arr = Array(nrows);\n    let row = 0;\n    tables.forEach(table => {\n      const col = table.column(name) || { at: () => NULL };\n      table.scan(trow => arr[row++] = col.at(trow));\n    });\n    cols.add(name, arr);\n  });\n\n  return cols.new(table);\n}\n","import { _select } from './select.js';\nimport { resolve } from '../helpers/selection.js';\nimport { error } from '../util/error.js';\n\nexport function relocate(table, columns, {\n  before = undefined,\n  after = undefined\n} = {}) {\n  const bef = before != null;\n  const aft = after != null;\n\n  if (!(bef || aft)) {\n    error('relocate requires a before or after option.');\n  }\n  if (bef && aft) {\n    error('relocate accepts only one of the before or after options.');\n  }\n\n  columns = resolve(table, columns);\n  const anchors = [...resolve(table, bef ? before : after).keys()];\n  const anchor = bef ? anchors[0] : anchors.pop();\n  const select = new Map();\n\n  // marshal inputs to select in desired order\n  table.columnNames().forEach(name => {\n    // check if we should assign the current column\n    const assign = !columns.has(name);\n\n    // at anchor column, insert relocated columns\n    if (name === anchor) {\n      if (aft && assign) select.set(name, name);\n      for (const [key, value] of columns) {\n        select.set(key, value);\n      }\n      if (aft) return; // exit if current column has been handled\n    }\n\n    if (assign) select.set(name, name);\n  });\n\n  return _select(table, select);\n}\n","export function bisector(compare) {\n  return {\n    left(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        const mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        const mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n","import { ascending } from '../../util/ascending.js';\nimport { bisector } from '../../util/bisector.js';\nimport { concat } from '../../util/concat.js';\nimport { unroll } from '../../util/unroll.js';\n\nconst bisect = bisector(ascending);\n\nexport function windowState(data, frame, adjust, ops, aggrs) {\n  let rows, peer, cells, result, key;\n  const isPeer = index => peer[index - 1] === peer[index];\n  const numOps = ops.length;\n  const numAgg = aggrs.length;\n\n  const evaluate = ops.length\n    ? unroll(\n        ['w', 'r', 'k'],\n        '{' + concat(ops, (_, i) => `r[_${i}.id][k]=_${i}.value(w,_${i}.get);`) + '}',\n        ops\n      )\n    : () => {};\n\n  const w = {\n    i0: 0,\n    i1: 0,\n    index: 0,\n    size: 0,\n    peer: isPeer,\n\n    init(partition, peers, results, group) {\n      w.index = w.i0 = w.i1 = 0;\n      w.size = peers.length;\n      rows = partition;\n      peer = peers;\n      result = results;\n      key = group;\n\n      // initialize aggregates\n      cells = aggrs ? aggrs.map(aggr => aggr.init()) : null;\n\n      // initialize window ops\n      for (let i = 0; i < numOps; ++i) {\n        ops[i].init();\n      }\n\n      return w;\n    },\n\n    value(index, get) {\n      return get(rows[index], data);\n    },\n\n    step(idx) {\n      const [f0, f1] = frame;\n      const n = w.size;\n      const p0 = w.i0;\n      const p1 = w.i1;\n\n      w.i0 = f0 != null ? Math.max(0, idx - Math.abs(f0)) : 0;\n      w.i1 = f1 != null ? Math.min(n, idx + Math.abs(f1) + 1) : n;\n      w.index = idx;\n\n      if (adjust) {\n        if (w.i0 > 0 && isPeer(w.i0)) {\n          w.i0 = bisect.left(peer, peer[w.i0]);\n        }\n        if (w.i1 < n && isPeer(w.i1)) {\n          w.i1 = bisect.right(peer, peer[w.i1 - 1]);\n        }\n      }\n\n      // evaluate aggregates\n      for (let i = 0; i < numAgg; ++i) {\n        const aggr = aggrs[i];\n        const cell = cells[i];\n        for (let j = p0; j < w.i0; ++j) {\n          aggr.rem(cell, rows[j], data);\n        }\n        for (let j = p1; j < w.i1; ++j) {\n          aggr.add(cell, rows[j], data);\n        }\n        aggr.write(cell, result, key);\n      }\n\n      // evaluate window ops\n      evaluate(w, result, key);\n\n      return result;\n    }\n  };\n\n  return w;\n}\n","import { reducers } from '../reduce/util.js';\nimport { getWindow, hasAggregate } from '../../op/index.js';\nimport { concat } from '../../util/concat.js';\nimport { unroll } from '../../util/unroll.js';\nimport { windowState } from './window-state.js';\n\nconst frameValue = op =>\n  (op.frame || [null, null]).map(v => Number.isFinite(v) ? Math.abs(v) : null);\n\nconst peersValue = op => !!op.peers;\n\nfunction windowOp(spec) {\n  const { id, name, fields = [], params = [] } = spec;\n  return {\n    ...getWindow(name).create(...params),\n    get: fields.length ? fields[0] : null,\n    id\n  };\n}\n\nexport function window(table, cols, exprs, result = {}, ops) {\n  // instantiate window states\n  const data = table.data();\n  const states = windowStates(ops, data);\n  const nstate = states.length;\n\n  const write = unroll(\n    ['r', 'd', 'op'],\n    '{' + concat(cols, (_, i) => `_${i}[r] = $${i}(r, d, op);`) + '}',\n    cols, exprs\n  );\n\n  // scan each ordered partition\n  table.partitions().forEach((rows, key) => {\n    const size = rows.length;\n    const peers = windowPeers(table, rows);\n\n    // initialize window states\n    for (let i = 0; i < nstate; ++i) {\n      states[i].init(rows, peers, result, key);\n    }\n\n    // calculate window values per-row\n    const op = id => result[id][key];\n    for (let index = 0; index < size; ++index) {\n      // advance window frame, updates result object\n      for (let i = 0; i < nstate; ++i) {\n        states[i].step(index);\n      }\n      write(rows[index], data, op);\n    }\n  });\n}\n\nfunction windowStates(ops, data) {\n  const map = {};\n\n  // group operations by window frame parameters\n  ops.forEach(op => {\n    const frame = frameValue(op);\n    const peers = peersValue(op);\n    const key = `${frame},${peers}`;\n    const { aggOps, winOps } = map[key] || (map[key] = {\n      frame,\n      peers,\n      aggOps: [],\n      winOps: []\n    });\n    hasAggregate(op.name)\n      ? aggOps.push(op)\n      : winOps.push(windowOp(op));\n  });\n\n  return Object.values(map).map(_ => windowState(\n    data, _.frame, _.peers, _.winOps,\n    reducers(_.aggOps, _.frame[0] != null ? -1 : 1)\n  ));\n}\n\nfunction windowPeers(table, rows) {\n  if (table.isOrdered()) {\n    // generate peer ids for sort equality checking\n    const compare = table.comparator();\n    const data = table.data();\n    const nrows = rows.length;\n    const peers = new Uint32Array(nrows);\n    for (let i = 1, index = 0; i < nrows; ++i) {\n      peers[i] = compare(rows[i - 1], rows[i], data) ? ++index : index;\n    }\n    return peers;\n  } else {\n    // no sort, no peers: reuse row indices as peer ids\n    return rows;\n  }\n}\n","import { relocate } from './relocate.js';\nimport { aggregate } from './reduce/util.js';\nimport { window } from './window/window.js';\nimport { parse } from '../expression/parse.js';\nimport { hasWindow } from '../op/index.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { repeat } from '../util/repeat.js';\n\nfunction isWindowed(op) {\n  return hasWindow(op.name) ||\n    op.frame && (\n      Number.isFinite(op.frame[0]) ||\n      Number.isFinite(op.frame[1])\n    );\n}\n\nexport function derive(table, values, options = {}) {\n  const dt = _derive(table, parse(values, { table }), options);\n\n  return options.drop || (options.before == null && options.after == null)\n    ? dt\n    : relocate(\n        dt,\n        Object.keys(values).filter(name => !table.column(name)),\n        options\n      );\n}\n\nexport function _derive(table, { names, exprs, ops = [] }, options = {}) {\n  // instantiate output data\n  const total = table.totalRows();\n  const cols = columnSet(options.drop ? null : table);\n  const data = names.map(name => cols.add(name, Array(total)));\n\n  // analyze operations, compute non-windowed aggregates\n  const [ aggOps, winOps ] = segmentOps(ops);\n\n  const size = table.isGrouped() ? table.groups().size : 1;\n  const result = aggregate(\n    table, aggOps,\n    repeat(ops.length, () => Array(size))\n  );\n\n  // perform table scans to generate output values\n  winOps.length\n    ? window(table, data, exprs, result, winOps)\n    : output(table, data, exprs, result);\n\n  return cols.derive(table);\n}\n\nfunction segmentOps(ops) {\n  const aggOps = [];\n  const winOps = [];\n  const n = ops.length;\n\n  for (let i = 0; i < n; ++i) {\n    const op = ops[i];\n    op.id = i;\n    (isWindowed(op) ? winOps : aggOps).push(op);\n  }\n\n  return [aggOps, winOps];\n}\n\nfunction output(table, cols, exprs, result) {\n  const bits = table.mask();\n  const data = table.data();\n  const { keys } = table.groups() || {};\n  const op = keys\n    ? (id, row) => result[id][keys[row]]\n    : id => result[id][0];\n\n  const m = cols.length;\n  for (let j = 0; j < m; ++j) {\n    const get = exprs[j];\n    const col = cols[j];\n\n    // inline the following for performance:\n    // table.scan((i, data) => col[i] = get(i, data, op));\n    if (bits) {\n      for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n        col[i] = get(i, data, op);\n      }\n    } else {\n      const n = table.totalRows();\n      for (let i = 0; i < n; ++i) {\n        col[i] = get(i, data, op);\n      }\n    }\n  }\n}\n","import { _derive } from './derive.js';\nimport { parse } from '../expression/parse.js';\nimport { BitSet } from '../table/BitSet.js';\n\nexport function filter(table, criteria) {\n  const test = parse({ p: criteria }, { table });\n  let predicate = test.exprs[0];\n  if (test.ops.length) {\n    const data = _derive(table, test, { drop: true }).column('p');\n    predicate = row => data.at(row);\n  }\n  return _filter(table, predicate);\n}\n\nexport function _filter(table, predicate) {\n  const n = table.totalRows();\n  const bits = table.mask();\n  const data = table.data();\n  const filter = new BitSet(n);\n\n  // inline the following for performance:\n  // table.scan((row, data) => { if (predicate(row, data)) filter.set(row); });\n  if (bits) {\n    for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n      if (predicate(i, data)) filter.set(i);\n    }\n  } else {\n    for (let i = 0; i < n; ++i) {\n      if (predicate(i, data)) filter.set(i);\n    }\n  }\n\n  return table.create({ filter });\n}\n","import { groupby } from './groupby.js';\nimport { filter } from './filter.js';\n\nexport function dedupe(table, ...keys) {\n  keys = keys.flat();\n  const gt = groupby(table, keys.length ? keys : table.columnNames());\n  return filter(gt, 'row_number() === 1').ungroup().reify();\n}\n","export function rowLookup(table, hash) {\n  const lut = new Map();\n  table.scan((row, data) => {\n    const key = hash(row, data);\n    if (key != null && key === key) {\n      lut.set(key, row);\n    }\n  });\n  return lut;\n}\n\nexport function indexLookup(idx, data, hash) {\n  const lut = new Map();\n  const n = idx.length;\n  for (let i = 0; i < n; ++i) {\n    const row = idx[i];\n    const key = hash(row, data);\n    if (key != null && key === key) {\n      lut.has(key)\n        ? lut.get(key).push(i)\n        : lut.set(key, [i]);\n    }\n  }\n  return lut;\n}\n","import { parse } from '../../expression/parse.js';\nimport { field } from '../../helpers/field.js';\nimport { error } from '../../util/error.js';\nimport { isFunction } from '../../util/is-function.js';\nimport { isNumber } from '../../util/is-number.js';\nimport { isObject } from '../../util/is-object.js';\nimport { isString } from '../../util/is-string.js';\nimport { keyFunction } from '../../util/key-function.js';\nimport { toArray } from '../../util/to-array.js';\n\nexport function parseKey(name, table, params) {\n  const exprs = new Map();\n\n  toArray(params).forEach((param, i) => {\n    param = isNumber(param) ? table.columnName(param) : param;\n    isString(param) ? exprs.set(i, field(param))\n      : isFunction(param) || isObject(param) && param.expr ? exprs.set(i, param)\n      : error(`Invalid ${name} key value: ${param+''}`);\n  });\n\n  const fn = parse(exprs, { table, aggregate: false, window: false });\n  return keyFunction(fn.exprs, true);\n}\n","import { error } from '../../util/error.js';\nimport { intersect } from '../../util/intersect.js';\nimport { isArray } from '../../util/is-array.js';\nimport { isString } from '../../util/is-string.js';\nimport { parseKey } from './parse-key.js';\n\nexport function inferKeys(tableL, tableR, on) {\n  if (!on) {\n    // perform natural join if join condition not provided\n    const isect = intersect(tableL.columnNames(), tableR.columnNames());\n    if (!isect.length) error('Natural join requires shared column names.');\n    on = [isect, isect];\n  } else if (isString(on)) {\n    on = [on, on];\n  } else if (isArray(on) && on.length === 1) {\n    on = [on[0], on[0]];\n  }\n\n  return on;\n}\n\nexport function keyPredicate(tableL, tableR, onL, onR) {\n  if (onL.length !== onR.length) {\n    error('Mismatched number of join keys');\n  }\n  return [\n    parseKey('join', tableL, onL),\n    parseKey('join', tableR, onR)\n  ];\n}\n","export function intersect(a, b) {\n  const set = new Set(b);\n  return a.filter(x => set.has(x));\n}\n","import { rowLookup } from './join/lookup.js';\nimport { inferKeys, keyPredicate } from './util/join-keys.js';\nimport { parse } from '../expression/parse.js';\nimport { BitSet } from '../table/BitSet.js';\nimport { isArray } from '../util/is-array.js';\nimport { toArray } from '../util/to-array.js';\n\nexport function semijoin(tableL, tableR, on) {\n  return join_filter(tableL, tableR, on, { anti: false });\n}\n\nexport function antijoin(tableL, tableR, on) {\n  return join_filter(tableL, tableR, on, { anti: true });\n}\n\nexport function join_filter(tableL, tableR, on, options) {\n  on = inferKeys(tableL, tableR, on);\n\n  const predicate = isArray(on)\n    ? keyPredicate(tableL, tableR, ...on.map(toArray))\n    : parse({ on }, { join: [tableL, tableR] }).exprs[0];\n\n  return _join_filter(tableL, tableR, predicate, options);\n}\n\nexport function _join_filter(tableL, tableR, predicate, options = {}) {\n  // calculate semi-join filter mask\n  const filter = new BitSet(tableL.totalRows());\n  const join = isArray(predicate) ? hashSemiJoin : loopSemiJoin;\n  join(filter, tableL, tableR, predicate);\n\n  // if anti-join, negate the filter\n  if (options.anti) {\n    filter.not().and(tableL.mask());\n  }\n\n  return tableL.create({ filter });\n}\n\nfunction hashSemiJoin(filter, tableL, tableR, [keyL, keyR]) {\n  // build lookup table\n  const lut = rowLookup(tableR, keyR);\n\n  // scan table, update filter with matches\n  tableL.scan((rowL, data) => {\n    const rowR = lut.get(keyL(rowL, data));\n    if (rowR >= 0) filter.set(rowL);\n  });\n}\n\nfunction loopSemiJoin(filter, tableL, tableR, predicate) {\n  const nL = tableL.numRows();\n  const nR = tableR.numRows();\n  const dataL = tableL.data();\n  const dataR = tableR.data();\n\n  if (tableL.isFiltered() || tableR.isFiltered()) {\n    // use indices as at least one table is filtered\n    const idxL = tableL.indices(false);\n    const idxR = tableR.indices(false);\n    for (let i = 0; i < nL; ++i) {\n      const rowL = idxL[i];\n      for (let j = 0; j < nR; ++j) {\n        if (predicate(rowL, dataL, idxR[j], dataR)) {\n          filter.set(rowL);\n          break;\n        }\n      }\n    }\n  } else {\n    // no filters, enumerate row indices directly\n    for (let i = 0; i < nL; ++i) {\n      for (let j = 0; j < nR; ++j) {\n        if (predicate(i, dataL, j, dataR)) {\n          filter.set(i);\n          break;\n        }\n      }\n    }\n  }\n}\n","import { aggregateGet } from './reduce/util.js';\nimport { parseValue } from './util/parse.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { toArray } from '../util/to-array.js';\n\nexport function unroll(table, values, options) {\n  return _unroll(\n    table,\n    parseValue('unroll', table, values),\n    options && options.drop\n      ? { ...options, drop: parseValue('unroll', table, options.drop).names }\n      : options\n  );\n}\n\nexport function _unroll(table, { names = [], exprs = [], ops = [] }, options = {}) {\n  if (!names.length) return table;\n\n  const limit = options.limit > 0 ? +options.limit : Infinity;\n  const index = options.index\n    ? options.index === true ? 'index' : options.index + ''\n    : null;\n  const drop = new Set(options.drop);\n  const get = aggregateGet(table, ops, exprs);\n\n  // initialize output columns\n  const cols = columnSet();\n  const nset = new Set(names);\n  const priors = [];\n  const copies = [];\n  const unroll = [];\n\n  // original and copied columns\n  table.columnNames().forEach(name => {\n    if (!drop.has(name)) {\n      const col = cols.add(name, []);\n      if (!nset.has(name)) {\n        priors.push(table.column(name));\n        copies.push(col);\n      }\n    }\n  });\n\n  // unrolled output columns\n  names.forEach(name => {\n    if (!drop.has(name)) {\n      if (!cols.has(name)) cols.add(name, []);\n      unroll.push(cols.data[name]);\n    }\n  });\n\n  // index column, if requested\n  const icol = index ? cols.add(index, []) : null;\n\n  let start = 0;\n  const m = priors.length;\n  const n = unroll.length;\n\n  const copy = (row, maxlen) => {\n    for (let i = 0; i < m; ++i) {\n      copies[i].length = start + maxlen;\n      copies[i].fill(priors[i].at(row), start, start + maxlen);\n    }\n  };\n\n  const indices = icol\n    ? (row, maxlen) => {\n        for (let i = 0; i < maxlen; ++i) {\n          icol[row + i] = i;\n        }\n      }\n    : () => {};\n\n  if (n === 1) {\n    // optimize common case of one array-valued column\n    const fn = get[0];\n    const col = unroll[0];\n\n    table.scan((row, data) => {\n      // extract array data\n      const array = toArray(fn(row, data));\n      const maxlen = Math.min(array.length, limit);\n\n      // copy original table data\n      copy(row, maxlen);\n\n      // copy unrolled array data\n      for (let j = 0; j < maxlen; ++j) {\n        col[start + j] = array[j];\n      }\n\n      // fill in array indices\n      indices(start, maxlen);\n\n      start += maxlen;\n    });\n  } else {\n    table.scan((row, data) => {\n      let maxlen = 0;\n\n      // extract parallel array data\n      const arrays = get.map(fn => {\n        const value = toArray(fn(row, data));\n        maxlen = Math.min(Math.max(maxlen, value.length), limit);\n        return value;\n      });\n\n      // copy original table data\n      copy(row, maxlen);\n\n      // copy unrolled array data\n      for (let i = 0; i < n; ++i) {\n        const col = unroll[i];\n        const arr = arrays[i];\n        for (let j = 0; j < maxlen; ++j) {\n          col[start + j] = arr[j];\n        }\n      }\n\n      // fill in array indices\n      indices(start, maxlen);\n\n      start += maxlen;\n    });\n  }\n\n  return cols.new(table);\n}\n","import { aggregateGet } from './reduce/util.js';\nimport { _unroll } from './unroll.js';\nimport { parseValue } from './util/parse.js';\n\nexport function fold(table, values, options) {\n  return _fold(table, parseValue('fold', table, values), options);\n}\n\nexport function _fold(table, { names = [], exprs = [], ops = [] }, options = {}) {\n  if (names.length === 0) return table;\n\n  const [k = 'key', v = 'value'] = options.as || [];\n  const vals = aggregateGet(table, ops, exprs);\n\n  return _unroll(\n    table,\n    {\n      names: [k, v],\n      exprs: [() => names, (row, data) => vals.map(fn => fn(row, data))]\n    },\n    { ...options, drop: names }\n  );\n}\n","export function ungroup(table) {\n  return table.isGrouped()\n    ? table.create({ groups: null })\n    : table;\n}\n","import { aggregateGet } from './reduce/util.js';\nimport { _rollup } from './rollup.js';\nimport { ungroup } from './ungroup.js';\nimport { parseValue } from './util/parse.js';\nimport { parse } from '../expression/parse.js';\nimport { array_agg_distinct } from '../op/op-api.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { error } from '../util/error.js';\nimport { isValid } from '../util/is-valid.js';\nimport { keyFunction } from '../util/key-function.js';\nimport { toString } from '../util/to-string.js';\nimport { unroll } from '../util/unroll.js';\n\nexport function impute(table, values, options = {}) {\n  values = parse(values, { table });\n\n  values.names.forEach(name =>\n    table.column(name) ? 0 : error(`Invalid impute column ${toString(name)}`)\n  );\n\n  if (options.expand) {\n    const opt = { preparse, window: false, aggronly: true };\n    const params = parseValue('impute', table, options.expand, opt);\n    const result = _rollup(ungroup(table), params);\n    return _impute(\n      table, values, params.names,\n      params.names.map(name => result.get(name, 0))\n    );\n  } else {\n    return _impute(table, values);\n  }\n}\n\n// map direct field reference to \"unique\" aggregate\nfunction preparse(map) {\n  map.forEach((value, key) =>\n    value.field ? map.set(key, array_agg_distinct(value + '')) : 0\n  );\n}\n\nexport function _impute(table, values, keys, arrays) {\n  const write = keys && keys.length;\n  table = write ? expand(table, keys, arrays) : table;\n  const { names, exprs, ops } = values;\n  const gets = aggregateGet(table, ops, exprs);\n  const cols = write ? null : columnSet(table);\n  const rows = table.totalRows();\n\n  names.forEach((name, i) => {\n    const col = table.column(name);\n    const out = write ? col : cols.add(name, Array(rows));\n    const get = gets[i];\n\n    table.scan(idx => {\n      const v = col.at(idx);\n      out[idx] = !isValid(v) ? get(idx) : v;\n    });\n  });\n\n  return write ? table : table.create(cols);\n}\n\nfunction expand(table, keys, values) {\n  const groups = table.groups();\n  const data = table.data();\n\n  // expansion keys and accessors\n  const keyNames = (groups ? groups.names : []).concat(keys);\n  const keyGet = (groups ? groups.get : [])\n    .concat(keys.map(key => table.getter(key)));\n\n  // build hash of existing rows\n  const hash = new Set();\n  const keyTable = keyFunction(keyGet);\n  table.scan((idx, data) => hash.add(keyTable(idx, data)));\n\n  // initialize output table data\n  const names = table.columnNames();\n  const cols = columnSet();\n  const out = names.map(name => cols.add(name, []));\n  names.forEach((name, i) => {\n    const old = data[name];\n    const col = out[i];\n    table.scan(row => col.push(old.at(row)));\n  });\n\n  // enumerate expanded value sets and augment output table\n  const keyEnum = keyFunction(keyGet.map((k, i) => a => a[i]));\n  const set = unroll(\n    'v',\n    '{' + out.map((_, i) => `_${i}.push(v[$${i}]);`).join('') + '}',\n    out, names.map(name => keyNames.indexOf(name))\n  );\n\n  if (groups) {\n    let row = groups.keys.length;\n    const prod = values.reduce((p, a) => p * a.length, groups.size);\n    const keys = new Uint32Array(prod + (row - hash.size));\n    keys.set(groups.keys);\n    enumerate(groups, values, (vec, idx) => {\n      if (!hash.has(keyEnum(vec))) {\n        set(vec);\n        keys[row++] = idx[0];\n      }\n    });\n    cols.groupby({ ...groups, keys });\n  } else {\n    enumerate(groups, values, vec => {\n      if (!hash.has(keyEnum(vec))) set(vec);\n    });\n  }\n\n  return cols.new(table);\n}\n\nfunction enumerate(groups, values, callback) {\n  const offset = groups ? groups.get.length : 0;\n  const pad = groups ? 1 : 0;\n  const len = pad + values.length;\n  const lens = new Int32Array(len);\n  const idxs = new Int32Array(len);\n  const set = [];\n\n  if (groups) {\n    const { get, rows, size } = groups;\n    lens[0] = size;\n    set.push((vec, idx) => {\n      const row = rows[idx];\n      for (let i = 0; i < offset; ++i) {\n        vec[i] = get[i](row);\n      }\n    });\n  }\n\n  values.forEach((a, i) => {\n    const j = i + offset;\n    lens[i + pad] = a.length;\n    set.push((vec, idx) => vec[j] = a[idx]);\n  });\n\n  const vec = Array(offset + values.length);\n\n  // initialize value vector\n  for (let i = 0; i < len; ++i) {\n    set[i](vec, 0);\n  }\n  callback(vec, idxs);\n\n  // enumerate all combinations of values\n  for (let i = len - 1; i >= 0;) {\n    const idx = ++idxs[i];\n    if (idx < lens[i]) {\n      set[i](vec, idx);\n      callback(vec, idxs);\n      i = len - 1;\n    } else {\n      idxs[i] = 0;\n      set[i](vec, 0);\n      --i;\n    }\n  }\n}\n","import { indexLookup } from './join/lookup.js';\nimport { inferKeys, keyPredicate } from './util/join-keys.js';\nimport { parseValue } from './util/parse.js';\nimport { parse } from '../expression/parse.js';\nimport { all, not } from '../helpers/selection.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { concat } from '../util/concat.js';\nimport { isArray } from '../util/is-array.js';\nimport { isString } from '../util/is-string.js';\nimport { toArray } from '../util/to-array.js';\nimport { toString } from '../util/to-string.js';\nimport { unroll } from '../util/unroll.js';\n\nconst OPT_L = { aggregate: false, window: false };\nconst OPT_R = { ...OPT_L, index: 1 };\nconst NONE = -Infinity;\n\nexport function cross(table, other, values, options) {\n  return join(\n    table,\n    other,\n    () => true,\n    values,\n    { ...options, left: true, right: true }\n  );\n}\n\nexport function join(tableL, tableR, on, values, options = {}) {\n  on = inferKeys(tableL, tableR, on);\n  const optParse = { join: [tableL, tableR] };\n  let predicate;\n\n  if (isArray(on)) {\n    const [onL, onR] = on.map(toArray);\n    predicate = keyPredicate(tableL, tableR, onL, onR);\n\n    if (!values) {\n      // infer output columns, suppress duplicated key columns\n      values = inferValues(tableL, onL, onR, options);\n    }\n  } else {\n    predicate = parse({ on }, optParse).exprs[0];\n\n    if (!values) {\n      // include all table columns if values not provided\n      values = [all(), all()];\n    }\n  }\n\n  return _join(\n    tableL, tableR, predicate,\n    parseValues(tableL, tableR, values, optParse, options && options.suffix),\n    options\n  );\n}\n\nfunction inferValues(tableL, onL, onR, options) {\n  const isect = [];\n  onL.forEach((s, i) => isString(s) && s === onR[i] ? isect.push(s) : 0);\n  const vR = not(isect);\n\n  if (options.left && options.right) {\n    // for full join, merge shared key columns together\n    const shared = new Set(isect);\n    return [\n      tableL.columnNames().map(s => {\n        const c = `[${toString(s)}]`;\n        return shared.has(s)\n          ? { [s]: `(a, b) => a${c} == null ? b${c} : a${c}` }\n          : s;\n      }),\n      vR\n    ];\n  }\n\n  return options.right ? [vR, all()] : [all(), vR];\n}\n\nfunction parseValues(tableL, tableR, values, optParse, suffix = []) {\n  if (isArray(values)) {\n    let vL, vR, vJ, n = values.length;\n    vL = vR = vJ = { names: [], exprs: [] };\n\n    if (n--) {\n      vL = parseValue('join', tableL, values[0], optParse);\n    }\n    if (n--) {\n      vR = parseValue('join', tableR, values[1], OPT_R);\n    }\n    if (n--) {\n      vJ = parse(values[2], optParse);\n    }\n\n    // handle name collisions\n    const rename = new Set();\n    const namesL = new Set(vL.names);\n    vR.names.forEach(name => {\n      if (namesL.has(name)) {\n        rename.add(name);\n      }\n    });\n    if (rename.size) {\n      suffix[0] !== '' && rekey(vL.names, rename, suffix[0] || '_1');\n      suffix[1] !== '' && rekey(vR.names, rename, suffix[1] || '_2');\n    }\n\n    return {\n      names: vL.names.concat(vR.names, vJ.names),\n      exprs: vL.exprs.concat(vR.exprs, vJ.exprs)\n    };\n  } else {\n    return parse(values, optParse);\n  }\n}\n\nfunction rekey(names, rename, suffix) {\n  names.forEach((name, i) => rename.has(name)\n    ? (names[i] = name + suffix)\n    : 0);\n}\n\nfunction emitter(columns, getters) {\n  const args = ['i', 'a', 'j', 'b'];\n  return unroll(\n    args,\n    '{' + concat(columns, (_, i) => `_${i}.push($${i}(${args}));`) + '}',\n    columns, getters\n  );\n}\n\nexport function _join(tableL, tableR, predicate, { names, exprs }, options = {}) {\n  // initialize data for left table\n  const dataL = tableL.data();\n  const idxL = tableL.indices(false);\n  const nL = idxL.length;\n  const hitL = new Int32Array(nL);\n\n  // initialize data for right table\n  const dataR = tableR.data();\n  const idxR = tableR.indices(false);\n  const nR = idxR.length;\n  const hitR = new Int32Array(nR);\n\n  // initialize output data\n  const ncols = names.length;\n  const cols = columnSet();\n  const columns = Array(ncols);\n  const getters = Array(ncols);\n  for (let i = 0; i < names.length; ++i) {\n    columns[i] = cols.add(names[i], []);\n    getters[i] = exprs[i];\n  }\n  const emit = emitter(columns, getters);\n\n  // perform join\n  const join = isArray(predicate) ? hashJoin : loopJoin;\n  join(emit, predicate, dataL, dataR, idxL, idxR, hitL, hitR, nL, nR);\n\n  if (options.left) {\n    for (let i = 0; i < nL; ++i) {\n      if (!hitL[i]) {\n        emit(idxL[i], dataL, NONE, dataR);\n      }\n    }\n  }\n\n  if (options.right) {\n    for (let j = 0; j < nR; ++j) {\n      if (!hitR[j]) {\n        emit(NONE, dataL, idxR[j], dataR);\n      }\n    }\n  }\n\n  return cols.new(tableL);\n}\n\nfunction loopJoin(emit, predicate, dataL, dataR, idxL, idxR, hitL, hitR, nL, nR) {\n  // perform nested-loops join\n  for (let i = 0; i < nL; ++i) {\n    const rowL = idxL[i];\n    for (let j = 0; j < nR; ++j) {\n      const rowR = idxR[j];\n      if (predicate(rowL, dataL, rowR, dataR)) {\n        emit(rowL, dataL, rowR, dataR);\n        hitL[i] = 1;\n        hitR[j] = 1;\n      }\n    }\n  }\n}\n\nfunction hashJoin(emit, [keyL, keyR], dataL, dataR, idxL, idxR, hitL, hitR, nL, nR) {\n  // determine which table to hash\n  let dataScan, keyScan, hitScan, idxScan;\n  let dataHash, keyHash, hitHash, idxHash;\n  let emitScan = emit;\n  if (nL >= nR) {\n    dataScan = dataL; keyScan = keyL; hitScan = hitL; idxScan = idxL;\n    dataHash = dataR; keyHash = keyR; hitHash = hitR; idxHash = idxR;\n  } else {\n    dataScan = dataR; keyScan = keyR; hitScan = hitR; idxScan = idxR;\n    dataHash = dataL; keyHash = keyL; hitHash = hitL; idxHash = idxL;\n    emitScan = (i, a, j, b) => emit(j, b, i, a);\n  }\n\n  // build lookup table\n  const lut = indexLookup(idxHash, dataHash, keyHash);\n\n  // scan other table\n  const m = idxScan.length;\n  for (let j = 0; j < m; ++j) {\n    const rowScan = idxScan[j];\n    const list = lut.get(keyScan(rowScan, dataScan));\n    if (list) {\n      const n = list.length;\n      for (let k = 0; k < n; ++k) {\n        const i = list[k];\n        emitScan(rowScan, dataScan, idxHash[i], dataHash);\n        hitHash[i] = 1;\n      }\n      hitScan[j] = 1;\n    }\n  }\n}\n","import { not } from '../helpers/selection.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { concat } from '../util/concat.js';\nimport { NULL } from '../util/null.js';\nimport { unroll } from '../util/unroll.js';\nimport { rowLookup } from './join/lookup.js';\nimport { aggregateGet } from './reduce/util.js';\nimport { inferKeys } from './util/join-keys.js';\nimport { parseKey } from './util/parse-key.js';\nimport { parseValue } from './util/parse.js';\n\nexport function lookup(tableL, tableR, on, ...values) {\n  on = inferKeys(tableL, tableR, on);\n  values = values.length === 0\n    ? [not(tableL.columnNames())]\n    : values.flat();\n  return _lookup(\n    tableL,\n    tableR,\n    [ parseKey('lookup', tableL, on[0]), parseKey('lookup', tableR, on[1]) ],\n    parseValue('lookup', tableR, values)\n  );\n}\n\nexport function _lookup(tableL, tableR, [keyL, keyR], { names, exprs, ops = [] }) {\n  // instantiate output data\n  const cols = columnSet(tableL);\n  const total = tableL.totalRows();\n  names.forEach(name => cols.add(name, Array(total).fill(NULL)));\n\n  // build lookup table\n  const lut = rowLookup(tableR, keyR);\n\n  // generate setter function for lookup match\n  const set = unroll(\n    ['lr', 'rr', 'data'],\n    '{' + concat(names, (_, i) => `_[${i}][lr] = $[${i}](rr, data);`) + '}',\n    names.map(name => cols.data[name]),\n    aggregateGet(tableR, ops, exprs)\n  );\n\n  // find matching rows, set values on match\n  const dataR = tableR.data();\n  tableL.scan((lrow, data) => {\n    const rrow = lut.get(keyL(lrow, data));\n    if (rrow >= 0) set(lrow, rrow, dataR);\n  });\n\n  return cols.derive(tableL);\n}\n","import { codegen } from './codegen.js';\nimport { parse } from './parse.js';\nimport { aggregate } from '../verbs/reduce/util.js';\n\n// generate code to compare a single field\nconst _compare = (u, v, lt, gt) => `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt} : (u > v || v == null) && u != null ? ${gt} : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt} : v !== v && u === u ? ${gt} : `;\nconst _collate = (u, v, lt, gt, f) => `(v = ${v}, (u = ${u}) == null && v == null) ? 0 : v == null ? ${gt} : u == null ? ${lt} : (u = ${f}(u,v)) ? u : `;\n\nexport function compare(table, fields) {\n  // parse expressions, generate code for both a and b values\n  const names = [];\n  const exprs = [];\n  const fn = [];\n  let keys = null, opA = '0', opB = '0';\n  if (table.isGrouped()) {\n    keys = table.groups().keys;\n    opA = 'ka';\n    opB = 'kb';\n  }\n  const { ops } = parse(fields, {\n    table,\n    value: (name, node) => {\n      names.push(name);\n      if (node.escape) {\n        // if an escaped function, invoke it directly\n        const f = i => `fn[${fn.length}](${i}, data)`;\n        exprs.push([f('a'), f('b')]);\n        fn.push(node.escape);\n      } else {\n        // generate code to extract values to compare\n        exprs.push([\n          codegen(node, { index: 'a', op: opA }),\n          codegen(node, { index: 'b', op: opB })\n        ]);\n      }\n    },\n    window: false\n  });\n\n  // calculate aggregate values if needed\n  const result = aggregate(table, ops);\n  const op = (id, row) => result[id][row];\n\n  // generate comparison code for each field\n  const n = names.length;\n  let code = 'return (a, b) => {'\n    + (op && table.isGrouped() ? 'const ka = keys[a], kb = keys[b];' : '')\n    + 'let u, v; return ';\n  for (let i = 0; i < n; ++i) {\n    const field = fields.get(names[i]);\n    const o = field.desc ? -1 : 1;\n    const [u, v] = exprs[i];\n    if (field.collate) {\n      code += _collate(u, v, -o, o, `${o < 0 ? '-' : ''}fn[${fn.length}]`);\n      fn.push(field.collate);\n    } else {\n      code += _compare(u, v, -o, o);\n    }\n  }\n  code += '0;};';\n\n  // instantiate and return comparator function\n  return Function('op', 'keys', 'fn', 'data', code)(op, keys, fn, table.data());\n}\n","import { compare } from '../expression/compare.js';\nimport { field } from '../helpers/field.js';\nimport { error } from '../util/error.js';\nimport { isFunction } from '../util/is-function.js';\nimport { isObject } from '../util/is-object.js';\nimport { isNumber } from '../util/is-number.js';\nimport { isString } from '../util/is-string.js';\n\nexport function orderby(table, ...values) {\n  return _orderby(table, parseValues(table, values.flat()));\n}\n\nfunction parseValues(table, params) {\n  let index = -1;\n  const exprs = new Map();\n  const add = val => exprs.set(++index + '', val);\n\n  params.forEach(param => {\n    const expr = param.expr != null ? param.expr : param;\n\n    if (isObject(expr) && !isFunction(expr)) {\n      for (const key in expr) add(expr[key]);\n    } else {\n      add(\n        isNumber(expr) ? field(param, table.columnName(expr))\n          : isString(expr) ? field(param)\n          : isFunction(expr) ? param\n          : error(`Invalid orderby field: ${param+''}`)\n      );\n    }\n  });\n\n  return compare(table, exprs);\n}\n\nexport function _orderby(table, comparator) {\n  return table.create({ order: comparator });\n}\n","import { aggregate, aggregateGet, groupOutput } from './reduce/util.js';\nimport { parseValue } from './util/parse.js';\nimport { ungroup } from './ungroup.js';\nimport { any } from '../op/op-api.js';\nimport { columnSet } from '../table/ColumnSet.js';\n\n// TODO: enforce aggregates only (no output changes) for values\nexport function pivot(table, on, values, options) {\n  return _pivot(\n    table,\n    parseValue('fold', table, on),\n    parseValue('fold', table, values, { preparse, window: false, aggronly: true }),\n    options\n  );\n}\n\n// map direct field reference to \"any\" aggregate\nfunction preparse(map) {\n  map.forEach((value, key) =>\n    value.field ? map.set(key, any(value + '')) : 0\n  );\n}\n\nconst opt = (value, defaultValue) => value != null ? value : defaultValue;\n\nexport function _pivot(table, on, values, options = {}) {\n  const { keys, keyColumn } = pivotKeys(table, on, options);\n  const vsep = opt(options.valueSeparator, '_');\n  const namefn = values.names.length > 1\n    ? (i, name) => name + vsep + keys[i]\n    : i => keys[i];\n\n  // perform separate aggregate operations for each key\n  // if keys do not match, emit NaN so aggregate skips it\n  // use custom toString method for proper field resolution\n  const results = keys.map(\n    k => aggregate(table, values.ops.map(op => {\n      if (op.name === 'count') { // fix #273\n        const fn = r => k === keyColumn[r] ? 1 : NaN;\n        fn.toString = () => k + ':1';\n        return { ...op, name: 'sum', fields: [fn] };\n      }\n      const fields = op.fields.map(f => {\n        const fn = (r, d) => k === keyColumn[r] ? f(r, d) : NaN;\n        fn.toString = () => k + ':' + f;\n        return fn;\n      });\n      return { ...op, fields };\n    }))\n  );\n\n  return output(values, namefn, table.groups(), results).new(table);\n}\n\nfunction pivotKeys(table, on, options) {\n  const limit = options.limit > 0 ? +options.limit : Infinity;\n  const sort = opt(options.sort, true);\n  const ksep = opt(options.keySeparator, '_');\n\n  // construct key accessor function\n  const get = aggregateGet(table, on.ops, on.exprs);\n  const key = get.length === 1\n    ? get[0]\n    : (row, data) => get.map(fn => fn(row, data)).join(ksep);\n\n  // generate vector of per-row key values\n  const kcol = Array(table.totalRows());\n  table.scan((row, data) => kcol[row] = key(row, data));\n\n  // collect unique key values\n  const uniq = aggregate(\n    ungroup(table),\n    [ {\n      id: 0,\n      name: 'array_agg_distinct',\n      fields: [(row => kcol[row])], params: []\n    } ]\n  )[0][0];\n\n  // get ordered set of unique key values\n  const keys = sort ? uniq.sort() : uniq;\n\n  // return key values\n  return {\n    keys: Number.isFinite(limit) ? keys.slice(0, limit) : keys,\n    keyColumn: kcol\n  };\n}\n\nfunction output({ names, exprs }, namefn, groups, results) {\n  const size = groups ? groups.size : 1;\n  const cols = columnSet();\n  const m = results.length;\n  const n = names.length;\n\n  let result;\n  const op = (id, row) => result[id][row];\n\n  // write groupby fields to output\n  if (groups) groupOutput(cols, groups);\n\n  // write pivot values to output\n  for (let i = 0; i < n; ++i) {\n    const get = exprs[i];\n    if (get.field != null) {\n      // if expression is op only, use aggregates directly\n      for (let j = 0; j < m; ++j) {\n        cols.add(namefn(j, names[i]), results[j][get.field]);\n      }\n    } else if (size > 1) {\n      // if multiple groups, evaluate expression for each\n      for (let j = 0; j < m; ++j) {\n        result = results[j];\n        const col = cols.add(namefn(j, names[i]), Array(size));\n        for (let k = 0; k < size; ++k) {\n          col[k] = get(k, null, op);\n        }\n      }\n    } else {\n      // if only one group, no need to loop\n      for (let j = 0; j < m; ++j) {\n        result = results[j];\n        cols.add(namefn(j, names[i]), [ get(0, null, op) ]);\n      }\n    }\n  }\n\n  return cols;\n}\n","import { ascending } from './ascending.js';\nimport { bisector } from './bisector.js';\nimport { random } from './random.js';\n\nexport function sample(buffer, replace, index, weight) {\n  return (\n    replace\n      ? (weight ? sampleRW : sampleRU)\n      : (weight ? sampleNW : sampleNU)\n  )(buffer.length, buffer, index, weight);\n}\n\n// uniform sampling with replacement\n// uses straightforward uniform sampling\nfunction sampleRU(size, buffer, index) {\n  const n = index.length;\n  for (let i = 0; i < size; ++i) {\n    buffer[i] = index[(n * random()) | 0];\n  }\n  return buffer;\n}\n\n// weighted sampling with replacement\n// uses binary search lookup against cumulative weight\nfunction sampleRW(size, buffer, index, weight) {\n  const n = index.length;\n  const w = new Float64Array(n);\n\n  let sum = 0;\n  for (let i = 0; i < n; ++i) {\n    w[i] = (sum += weight(index[i]));\n  }\n\n  const bisect = bisector(ascending).right;\n  for (let i = 0; i < size; ++i) {\n    buffer[i] = index[bisect(w, sum * random())];\n  }\n  return buffer;\n}\n\n// uniform sampling without replacement\n// uses reservoir sampling to build out the sample\n// https://en.wikipedia.org/wiki/Reservoir_sampling\nfunction sampleNU(size, buffer, index) {\n  const n = index.length;\n  if (size >= n) return index;\n\n  for (let i = 0; i < size; ++i) {\n    buffer[i] = index[i];\n  }\n\n  for (let i = size; i < n; ++i) {\n    const j = i * random();\n    if (j < size) {\n      buffer[j | 0] = index[i];\n    }\n  }\n\n  return buffer;\n}\n\n// weighted sample without replacement\n// uses method of Efraimidis and Spirakis\n// TODO: could use min-heap to improve efficiency\nfunction sampleNW(size, buffer, index, weight) {\n  const n = index.length;\n  if (size >= n) return index;\n\n  const w = new Float32Array(n);\n  const k = new Uint32Array(n);\n  for (let i = 0; i < n; ++i) {\n    k[i] = i;\n    w[i] = -Math.log(random()) / weight(index[i]);\n  }\n\n  k.sort((a, b) => w[a] - w[b]);\n  for (let i = 0; i < size; ++i) {\n    buffer[i] = index[k[i]];\n  }\n  return buffer;\n}\n","import { _derive } from './derive.js';\nimport { _rollup } from './rollup.js';\nimport { parse } from '../expression/parse.js';\nimport { isNumber } from '../util/is-number.js';\nimport { isString } from '../util/is-string.js';\nimport { sample as sampleIndices } from '../util/sample.js';\nimport { shuffle as shuffleIndices } from '../util/shuffle.js';\n\nexport function sample(table, size, options = {}) {\n  return _sample(\n    table,\n    parseSize(table, size),\n    parseWeight(table, options.weight),\n    options\n  );\n}\n\nconst get = col => row => col.at(row) || 0;\n\nfunction parseSize(table, size) {\n  return isNumber(size)\n    ? () => size\n    : get(_rollup(table, parse({ size }, { table, window: false })).column('size'));\n}\n\nfunction parseWeight(table, w) {\n  if (w == null) return null;\n  w = isNumber(w) ? table.columnName(w) : w;\n  return get(\n    isString(w)\n      ? table.column(w)\n      : _derive(table, parse({ w }, { table }), { drop: true }).column('w')\n  );\n}\n\nexport function _sample(table, size, weight, options = {}) {\n  const { replace, shuffle } = options;\n  const parts = table.partitions(false);\n\n  let total = 0;\n  size = parts.map((idx, group) => {\n    let s = size(group);\n    total += (s = (replace ? s : Math.min(idx.length, s)));\n    return s;\n  });\n\n  const samples = new Uint32Array(total);\n  let curr = 0;\n\n  parts.forEach((idx, group) => {\n    const sz = size[group];\n    const buf = samples.subarray(curr, curr += sz);\n\n    if (!replace && sz === idx.length) {\n      // sample size === data size, no replacement\n      // no need to sample, just copy indices\n      buf.set(idx);\n    } else {\n      sampleIndices(buf, replace, idx, weight);\n    }\n  });\n\n  if (shuffle !== false && (parts.length > 1 || !replace)) {\n    // sampling with replacement methods shuffle, so in\n    // that case a single partition is already good to go\n    shuffleIndices(samples);\n  }\n\n  return table.reify(samples);\n}\n","import { random } from './random.js';\n\nexport function shuffle(array, lo = 0, hi = array.length) {\n  let n = hi - (lo = +lo);\n\n  while (n) {\n    const i = random() * n-- | 0;\n    const v = array[n + lo];\n    array[n + lo] = array[i + lo];\n    array[i + lo] = v;\n  }\n\n  return array;\n}\n","/**\n * Generate a table expression that filters a table based on ordered row\n * indices from start to end (end not included), where start and end\n * represent per-group ordered row numbers in the table. The resulting\n * string can be used as the input to the filter verb.\n * @param {number} [start] Zero-based index at which to start extraction.\n *  A negative index indicates an offset from the end of the group.\n *  If start is undefined, slice starts from the index 0.\n * @param {number} [end] Zero-based index before which to end extraction.\n *  A negative index indicates an offset from the end of the group.\n *  If end is omitted, slice extracts through the end of the group.\n * @return {string} A table expression string for slicing values.\n * @example slice(1, -1)\n */\nexport function slice(start = 0, end = Infinity) {\n  return `${prep(start)} < row_number() && row_number() <= ${prep(end)}`;\n}\n\nfunction prep(index) {\n  return index < 0 ? `count() + ${index}` : index;\n}\n","import { filter } from './filter.js';\nimport { slice as _slice } from '../helpers/slice.js';\n\nexport function slice(table, start = 0, end = Infinity) {\n  if (table.isGrouped()) {\n    return filter(table, _slice(start, end)).reify();\n  }\n\n  // if not grouped, scan table directly\n  const indices = [];\n  const nrows = table.numRows();\n  start = Math.max(0, start + (start < 0 ? nrows : 0));\n  end = Math.min(nrows, Math.max(0, end + (end < 0 ? nrows : 0)));\n  table.scan(row => indices.push(row), true, end - start, start);\n  return table.reify(indices);\n}\n","import { aggregateGet } from './reduce/util.js';\nimport { parseValue } from './util/parse.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { NULL } from '../util/null.js';\nimport { toArray } from '../util/to-array.js';\n\nexport function spread(table, values, options) {\n  return _spread(table, parseValue('spread', table, values), options);\n}\n\nexport function _spread(table, { names, exprs, ops = [] }, options = {}) {\n  if (names.length === 0) return table;\n\n  // ignore 'as' if there are multiple field names\n  const as = (names.length === 1 && options.as) || [];\n  const drop = options.drop == null ? true : !!options.drop;\n  const limit = options.limit == null\n    ? as.length || Infinity\n    : Math.max(1, +options.limit || 1);\n\n  const get = aggregateGet(table, ops, exprs);\n  const cols = columnSet();\n  const map = names.reduce((map, name, i) => map.set(name, i), new Map());\n\n  const add = (index, name) => {\n    const columns = spreadCols(table, get[index], limit);\n    const n = columns.length;\n    for (let i = 0; i < n; ++i) {\n      cols.add(as[i] || `${name}_${i + 1}`, columns[i]);\n    }\n  };\n\n  table.columnNames().forEach(name => {\n    if (map.has(name)) {\n      if (!drop) cols.add(name, table.column(name));\n      add(map.get(name), name);\n      map.delete(name);\n    } else {\n      cols.add(name, table.column(name));\n    }\n  });\n\n  map.forEach(add);\n\n  return cols.derive(table);\n}\n\nfunction spreadCols(table, get, limit) {\n  const nrows = table.totalRows();\n  const columns = [];\n\n  table.scan((row, data) => {\n    const values = toArray(get(row, data));\n    const n = Math.min(values.length, limit);\n    while (columns.length < n) {\n      columns.push(Array(nrows).fill(NULL));\n    }\n    for (let i = 0; i < n; ++i) {\n      columns[i][row] = values[i];\n    }\n  });\n\n  return columns;\n}\n","/** Magic bytes 'ARROW1' indicating the Arrow 'file' format. */\nexport const MAGIC = Uint8Array.of(65, 82, 82, 79, 87, 49);\n\n/** Bytes for an 'end of stream' message. */\nexport const EOS = Uint8Array.of(255, 255, 255, 255, 0, 0, 0, 0);\n\n/**\n * Apache Arrow version.\n */\nexport const Version = /** @type {const} */ ({\n  /** 0.1.0 (October 2016). */\n  V1: 0,\n  /** 0.2.0 (February 2017). Non-backwards compatible with V1. */\n  V2: 1,\n  /** 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2. */\n  V3: 2,\n  /** >= 0.8.0 (December 2017). Non-backwards compatible with V3. */\n  V4: 3,\n  /**\n   * >= 1.0.0 (July 2020). Backwards compatible with V4 (V5 readers can read V4\n   * metadata and IPC messages). Implementations are recommended to provide a\n   * V4 compatibility mode with V5 format changes disabled.\n   *\n   * Incompatible changes between V4 and V5:\n   * - Union buffer layout has changed.\n   *   In V5, Unions don't have a validity bitmap buffer.\n   */\n  V5: 4\n});\n\n/**\n * Endianness of Arrow-encoded data.\n */\nexport const Endianness = /** @type {const} */ ({\n  Little: 0,\n  Big: 1\n});\n\n/**\n * Message header type codes.\n */\nexport const MessageHeader = /** @type {const} */ ({\n  NONE: 0,\n  /**\n   * A Schema describes the columns in a record batch.\n   */\n  Schema: 1,\n  /**\n   * For sending dictionary encoding information. Any Field can be\n   * dictionary-encoded, but in this case none of its children may be\n   * dictionary-encoded.\n   * There is one vector / column per dictionary, but that vector / column\n   * may be spread across multiple dictionary batches by using the isDelta\n   * flag.\n   */\n  DictionaryBatch: 2,\n  /**\n   * A data header describing the shared memory layout of a \"record\" or \"row\"\n   * batch. Some systems call this a \"row batch\" internally and others a \"record\n   * batch\".\n   */\n  RecordBatch: 3,\n  /**\n   * EXPERIMENTAL: Metadata for n-dimensional arrays, aka \"tensors\" or\n   * \"ndarrays\". Arrow implementations in general are not required to implement\n   * this type.\n   *\n   * Not currently supported by Flechette.\n   */\n  Tensor: 4,\n  /**\n   * EXPERIMENTAL: Metadata for n-dimensional sparse arrays, aka \"sparse\n   * tensors\". Arrow implementations in general are not required to implement\n   * this type.\n   *\n   * Not currently supported by Flechette.\n   */\n  SparseTensor: 5\n});\n\n/**\n * Field data type ids.\n * Only non-negative values ever occur in IPC flatbuffer binary data.\n */\nexport const Type = /** @type {const} */ ({\n  /**\n   * Dictionary types compress data by using a set of integer indices to\n   * lookup potentially repeated vales in a separate dictionary of values.\n   *\n   * This type entry is provided for API convenience, it does not occur\n   * in actual Arrow IPC binary data.\n   */\n  Dictionary: -1,\n  /** No data type. Included for flatbuffer compatibility. */\n  NONE: 0,\n  /** Null values only. */\n  Null: 1,\n  /** Integers, either signed or unsigned, with 8, 16, 32, or 64 bit widths. */\n  Int: 2,\n  /** Floating point numbers with 16, 32, or 64 bit precision. */\n  Float: 3,\n  /** Opaque binary data. */\n  Binary: 4,\n  /** Unicode with UTF-8 encoding. */\n  Utf8: 5,\n  /** Booleans represented as 8 bit bytes. */\n  Bool: 6,\n  /**\n   * Exact decimal value represented as an integer value in two's complement.\n   * Currently only 128-bit (16-byte) and 256-bit (32-byte) integers are used.\n   * The representation uses the endianness indicated in the schema.\n   */\n  Decimal: 7,\n  /**\n   * Date is either a 32-bit or 64-bit signed integer type representing an\n   * elapsed time since UNIX epoch (1970-01-01), stored in either of two units:\n   * - Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no\n   * leap seconds), where the values are evenly divisible by 86400000\n   * - Days (32 bits) since the UNIX epoch\n   */\n  Date: 8,\n  /**\n   * Time is either a 32-bit or 64-bit signed integer type representing an\n   * elapsed time since midnight, stored in either of four units: seconds,\n   * milliseconds, microseconds or nanoseconds.\n   *\n   * The integer `bitWidth` depends on the `unit` and must be one of the following:\n   * - SECOND and MILLISECOND: 32 bits\n   * - MICROSECOND and NANOSECOND: 64 bits\n   *\n   * The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds\n   * (exclusive), adjusted for the time unit (for example, up to 86400000\n   * exclusive for the MILLISECOND unit).\n   * This definition doesn't allow for leap seconds. Time values from\n   * measurements with leap seconds will need to be corrected when ingesting\n   * into Arrow (for example by replacing the value 86400 with 86399).\n   */\n  Time: 9,\n  /**\n   * Timestamp is a 64-bit signed integer representing an elapsed time since a\n   * fixed epoch, stored in either of four units: seconds, milliseconds,\n   * microseconds or nanoseconds, and is optionally annotated with a timezone.\n   *\n   * Timestamp values do not include any leap seconds (in other words, all\n   * days are considered 86400 seconds long).\n   *\n   * The timezone is an optional string for the name of a timezone, one of:\n   *\n   *  - As used in the Olson timezone database (the \"tz database\" or\n   *    \"tzdata\"), such as \"America/New_York\".\n   *  - An absolute timezone offset of the form \"+XX:XX\" or \"-XX:XX\",\n   *    such as \"+07:30\".\n   *\n   * Whether a timezone string is present indicates different semantics about\n   * the data.\n   */\n  Timestamp: 10,\n  /**\n   * A \"calendar\" interval which models types that don't necessarily\n   * have a precise duration without the context of a base timestamp (e.g.\n   * days can differ in length during day light savings time transitions).\n   * All integers in the units below are stored in the endianness indicated\n   * by the schema.\n   *\n   *  - YEAR_MONTH - Indicates the number of elapsed whole months, stored as\n   *    4-byte signed integers.\n   *  - DAY_TIME - Indicates the number of elapsed days and milliseconds (no\n   *    leap seconds), stored as 2 contiguous 32-bit signed integers (8-bytes\n   *    in total). Support of this IntervalUnit is not required for full arrow\n   *    compatibility.\n   *  - MONTH_DAY_NANO - A triple of the number of elapsed months, days, and\n   *    nanoseconds. The values are stored contiguously in 16-byte blocks.\n   *    Months and days are encoded as 32-bit signed integers and nanoseconds\n   *    is encoded as a 64-bit signed integer. Nanoseconds does not allow for\n   *    leap seconds. Each field is independent (e.g. there is no constraint\n   *    that nanoseconds have the same sign as days or that the quantity of\n   *    nanoseconds represents less than a day's worth of time).\n   */\n  Interval: 11,\n  /**\n   * List (vector) data supporting variably-sized lists.\n   * A list has a single child data type for list entries.\n   */\n  List: 12,\n  /**\n   * A struct consisting of multiple named child data types.\n   */\n  Struct: 13,\n  /**\n   * A union is a complex type with parallel child data types. By default ids\n   * in the type vector refer to the offsets in the children. Optionally\n   * typeIds provides an indirection between the child offset and the type id.\n   * For each child `typeIds[offset]` is the id used in the type vector.\n   */\n  Union: 14,\n  /**\n   * Binary data where each entry has the same fixed size.\n   */\n  FixedSizeBinary: 15,\n  /**\n   * List (vector) data where every list has the same fixed size.\n   * A list has a single child data type for list entries.\n   */\n  FixedSizeList: 16,\n  /**\n   * A Map is a logical nested type that is represented as\n   * List<entries: Struct<key: K, value: V>>\n   *\n   * In this layout, the keys and values are each respectively contiguous. We do\n   * not constrain the key and value types, so the application is responsible\n   * for ensuring that the keys are hashable and unique. Whether the keys are sorted\n   * may be set in the metadata for this field.\n   *\n   * In a field with Map type, the field has a child Struct field, which then\n   * has two children: key type and the second the value type. The names of the\n   * child fields may be respectively \"entries\", \"key\", and \"value\", but this is\n   * not enforced.\n   *\n   * Map\n   * ```text\n   *   - child[0] entries: Struct\n   *   - child[0] key: K\n   *   - child[1] value: V\n   *  ```\n   * Neither the \"entries\" field nor the \"key\" field may be nullable.\n   *\n   * The metadata is structured so that Arrow systems without special handling\n   * for Map can make Map an alias for List. The \"layout\" attribute for the Map\n   * field must have the same contents as a List.\n   */\n  Map: 17,\n  /**\n   * An absolute length of time unrelated to any calendar artifacts. For the\n   * purposes of Arrow implementations, adding this value to a Timestamp\n   * (\"t1\") naively (i.e. simply summing the two numbers) is acceptable even\n   * though in some cases the resulting Timestamp (t2) would not account for\n   * leap-seconds during the elapsed time between \"t1\" and \"t2\". Similarly,\n   * representing the difference between two Unix timestamp is acceptable, but\n   * would yield a value that is possibly a few seconds off from the true\n   * elapsed time.\n   *\n   * The resolution defaults to millisecond, but can be any of the other\n   * supported TimeUnit values as with Timestamp and Time types. This type is\n   * always represented as an 8-byte integer.\n   */\n  Duration: 18,\n  /**\n   * Same as Binary, but with 64-bit offsets, allowing representation of\n   * extremely large data values.\n   */\n  LargeBinary: 19,\n  /**\n   * Same as Utf8, but with 64-bit offsets, allowing representation of\n   * extremely large data values.\n   */\n  LargeUtf8: 20,\n  /**\n   * Same as List, but with 64-bit offsets, allowing representation of\n   * extremely large data values.\n   */\n  LargeList: 21,\n  /**\n   * Contains two child arrays, run_ends and values. The run_ends child array\n   * must be a 16/32/64-bit integer array which encodes the indices at which\n   * the run with the value in each corresponding index in the values child\n   * array ends. Like list/struct types, the value array can be of any type.\n   */\n  RunEndEncoded: 22,\n  /**\n   * Logically the same as Binary, but the internal representation uses a view\n   * struct that contains the string length and either the string's entire data\n   * inline (for small strings) or an inlined prefix, an index of another buffer,\n   * and an offset pointing to a slice in that buffer (for non-small strings).\n   *\n   * Since it uses a variable number of data buffers, each Field with this type\n   * must have a corresponding entry in `variadicBufferCounts`.\n   */\n  BinaryView: 23,\n  /**\n   * Logically the same as Utf8, but the internal representation uses a view\n   * struct that contains the string length and either the string's entire data\n   * inline (for small strings) or an inlined prefix, an index of another buffer,\n   * and an offset pointing to a slice in that buffer (for non-small strings).\n   *\n   * Since it uses a variable number of data buffers, each Field with this type\n   * must have a corresponding entry in `variadicBufferCounts`.\n   */\n  Utf8View: 24,\n  /**\n   * Represents the same logical types that List can, but contains offsets and\n   * sizes allowing for writes in any order and sharing of child values among\n   * list values.\n   */\n  ListView: 25,\n  /**\n   * Same as ListView, but with 64-bit offsets and sizes, allowing to represent\n   * extremely large data values.\n   */\n  LargeListView: 26\n});\n\n/**\n * Floating point number precision.\n */\nexport const Precision = /** @type {const} */ ({\n  /** 16-bit floating point number. */\n  HALF: 0,\n  /** 32-bit floating point number. */\n  SINGLE: 1,\n  /** 64-bit floating point number. */\n  DOUBLE: 2\n});\n\n/**\n * Date units.\n */\nexport const DateUnit = /** @type {const} */ ({\n  /* Days (as 32 bit int) since the UNIX epoch. */\n  DAY: 0,\n  /**\n   * Milliseconds (as 64 bit int) indicating UNIX time elapsed since the epoch\n   * (no leap seconds), with values evenly divisible by 86400000.\n   */\n  MILLISECOND: 1\n});\n\n/**\n * Time units.\n */\nexport const TimeUnit = /** @type {const} */ ({\n  /** Seconds. */\n  SECOND: 0,\n  /** Milliseconds. */\n  MILLISECOND: 1,\n  /** Microseconds. */\n  MICROSECOND: 2,\n  /** Nanoseconds. */\n  NANOSECOND: 3\n});\n\n/**\n * Date/time interval units.\n */\nexport const IntervalUnit = /** @type {const} */ ({\n  /**\n   * Indicates the number of elapsed whole months, stored as 4-byte signed\n   * integers.\n   */\n  YEAR_MONTH: 0,\n  /**\n   * Indicates the number of elapsed days and milliseconds (no leap seconds),\n   * stored as 2 contiguous 32-bit signed integers (8-bytes in total). Support\n   * of this IntervalUnit is not required for full arrow compatibility.\n   */\n  DAY_TIME: 1,\n  /**\n   * A triple of the number of elapsed months, days, and nanoseconds.\n   * The values are stored contiguously in 16-byte blocks. Months and days are\n   * encoded as 32-bit signed integers and nanoseconds is encoded as a 64-bit\n   * signed integer. Nanoseconds does not allow for leap seconds. Each field is\n   * independent (e.g. there is no constraint that nanoseconds have the same\n   * sign as days or that the quantity of nanoseconds represents less than a\n   * day's worth of time).\n   */\n  MONTH_DAY_NANO: 2\n});\n\n/**\n * Union type modes.\n */\nexport const UnionMode = /** @type {const} */ ({\n  /** Sparse union layout with full arrays for each sub-type. */\n  Sparse: 0,\n  /** Dense union layout with offsets into value arrays. */\n  Dense: 1\n});\n","export const uint8Array = Uint8Array;\nexport const uint16Array = Uint16Array;\nexport const uint32Array = Uint32Array;\nexport const uint64Array = BigUint64Array;\nexport const int8Array = Int8Array;\nexport const int16Array = Int16Array;\nexport const int32Array = Int32Array;\nexport const int64Array = BigInt64Array;\nexport const float32Array = Float32Array;\nexport const float64Array = Float64Array;\n\n/**\n * Return the appropriate typed array constructor for the given\n * integer type metadata.\n * @param {number} bitWidth The integer size in bits.\n * @param {boolean} signed Flag indicating if the integer is signed.\n * @returns {import('../types.js').IntArrayConstructor}\n */\nexport function intArrayType(bitWidth, signed) {\n  const i = Math.log2(bitWidth) - 3;\n  return (\n    signed\n      ? [int8Array, int16Array, int32Array, int64Array]\n      : [uint8Array, uint16Array, uint32Array, uint64Array]\n  )[i];\n}\n\n/** Shared prototype for typed arrays. */\nconst TypedArray = Object.getPrototypeOf(Int8Array);\n\n/**\n * Check if a value is a typed array.\n * @param {*} value The value to check.\n * @returns {value is import('../types.js').TypedArray}\n *  True if value is a typed array, false otherwise.\n */\nexport function isTypedArray(value) {\n  return value instanceof TypedArray;\n}\n\n/**\n * Check if a value is either a standard array or typed array.\n * @param {*} value The value to check.\n * @returns {value is (Array | import('../types.js').TypedArray)}\n *  True if value is an array, false otherwise.\n */\nexport function isArray(value) {\n  return Array.isArray(value) || isTypedArray(value);\n}\n\n/**\n * Check if a value is an array type (constructor) for 64-bit integers,\n * one of BigInt64Array or BigUint64Array.\n * @param {*} value The value to check.\n * @returns {value is import('../types.js').Int64ArrayConstructor}\n *  True if value is a 64-bit array type, false otherwise.\n */\nexport function isInt64ArrayType(value) {\n  return value === int64Array || value === uint64Array;\n}\n\n/**\n * Determine the correct index into an offset array for a given\n * full column row index. Assumes offset indices can be manipulated\n * as 32-bit signed integers.\n * @param {import('../types.js').IntegerArray} offsets The offsets array.\n * @param {number} index The full column row index.\n */\nexport function bisect(offsets, index) {\n  let a = 0;\n  let b = offsets.length;\n  if (b <= 2147483648) { // 2 ** 31\n    // fast version, use unsigned bit shift\n    // array length fits within 32-bit signed integer\n    do {\n      const mid = (a + b) >>> 1;\n      if (offsets[mid] <= index) a = mid + 1;\n      else b = mid;\n    } while (a < b);\n  } else {\n    // slow version, use division and truncate\n    // array length exceeds 32-bit signed integer\n    do {\n      const mid = Math.trunc((a + b) / 2);\n      if (offsets[mid] <= index) a = mid + 1;\n      else b = mid;\n    } while (a < b);\n  }\n  return a;\n}\n\n/**\n * Compute a 64-bit aligned buffer size.\n * @param {number} length The starting size.\n * @param {number} bpe Bytes per element.\n * @returns {number} The aligned size.\n */\nfunction align64(length, bpe = 1) {\n  return (((length * bpe) + 7) & ~7) / bpe;\n}\n\n/**\n * Return a 64-bit aligned version of the array.\n * @template {import('../types.js').TypedArray} T\n * @param {T} array The array.\n * @param {number} length The current array length.\n * @returns {T} The aligned array.\n */\nexport function align(array, length = array.length) {\n  const alignedLength = align64(length, array.BYTES_PER_ELEMENT);\n  return array.length > alignedLength ? /** @type {T} */ (array.subarray(0, alignedLength))\n    : array.length < alignedLength ? resize(array, alignedLength)\n    : array;\n}\n\n/**\n * Resize a typed array to exactly the specified length.\n * @template {import('../types.js').TypedArray} T\n * @param {T} array The array.\n * @param {number} newLength The new length.\n * @param {number} [offset] The offset at which to copy the old array.\n * @returns {T} The resized array.\n */\nexport function resize(array, newLength, offset = 0) {\n  // @ts-ignore\n  const newArray = new array.constructor(newLength);\n  newArray.set(array, offset);\n  return newArray;\n}\n\n/**\n * Grow a typed array to accommdate a minimum index. The array size is\n * doubled until it exceeds the minimum index.\n * @template {import('../types.js').TypedArray} T\n * @param {T} array The array.\n * @param {number} index The minimum index.\n * @param {boolean} [shift] Flag to shift copied bytes to back of array.\n * @returns {T} The resized array.\n */\nexport function grow(array, index, shift) {\n  while (array.length <= index) {\n    array = resize(array, array.length << 1, shift ? array.length : 0);\n  }\n  return array;\n}\n","/**\n * Check if a value is a Date instance\n * @param {*} value The value to check.\n * @returns {value is Date} True if value is a Date, false otherwise.\n */\nexport function isDate(value) {\n  return value instanceof Date;\n}\n\n/**\n * Check if a value is iterable.\n * @param {*} value The value to check.\n * @returns {value is Iterable} True if value is iterable, false otherwise.\n */\nexport function isIterable(value) {\n  return typeof value[Symbol.iterator] === 'function';\n}\n\n/**\n * Return the input value if it passes a test.\n * Otherwise throw an error using the given message generator.\n * @template T\n * @param {T} value he value to check.\n * @param {(value: T) => boolean} test The test function.\n * @param {(value: *) => string} message Message generator.\n * @returns {T} The input value.\n * @throws if the value does not pass the test\n */\nexport function check(value, test, message) {\n  if (test(value)) return value;\n  throw new Error(message(value));\n}\n\n/**\n * Return the input value if it exists in the provided set.\n * Otherwise throw an error using the given message generator.\n * @template T\n * @param {T} value The value to check.\n * @param {T[] | Record<string,T>} set The set of valid values.\n * @param {(value: *) => string} [message] Message generator.\n * @returns {T} The input value.\n * @throws if the value is not included in the set\n */\nexport function checkOneOf(value, set, message) {\n  set = Array.isArray(set) ? set : Object.values(set);\n  return check(\n    value,\n    (value) => set.includes(value),\n    message ?? (() => `${value} must be one of ${set}`)\n  );\n}\n\n/**\n * Return the first object key that pairs with the given value.\n * @param {Record<string,any>} object The object to search.\n * @param {any} value The value to lookup.\n * @returns {string} The first matching key, or '<Unknown>' if not found.\n */\nexport function keyFor(object, value) {\n  for (const [key, val] of Object.entries(object)) {\n    if (val === value) return key;\n  }\n  return '<Unknown>';\n}\n","import { DateUnit, IntervalUnit, Precision, TimeUnit, Type, UnionMode } from './constants.js';\nimport { intArrayType, float32Array, float64Array, int32Array, int64Array, uint16Array, uint64Array } from './util/arrays.js';\nimport { check, checkOneOf, keyFor } from './util/objects.js';\n\n/**\n * @typedef {import('./types.js').Field | import('./types.js').DataType} FieldInput\n */\n\nexport const invalidDataType = (typeId) =>\n  `Unsupported data type: \"${keyFor(Type, typeId)}\" (id ${typeId})`;\n\n/**\n * Return a new field instance for use in a schema or type definition. A field\n * represents a field name, data type, and additional metadata. Fields are used\n * to represent child types within nested types like List, Struct, and Union.\n * @param {string} name The field name.\n * @param {import('./types.js').DataType} type The field data type.\n * @param {boolean} [nullable=true] Flag indicating if the field is nullable\n *  (default `true`).\n * @param {Map<string,string>|null} [metadata=null] Custom field metadata\n *  annotations (default `null`).\n * @returns {import('./types.js').Field} The field instance.\n */\nexport const field = (name, type, nullable = true, metadata = null) => ({\n  name,\n  type,\n  nullable,\n  metadata\n});\n\n/**\n * Checks if a value is a field instance.\n * @param {any} value\n * @returns {value is import('./types.js').Field}\n */\nfunction isField(value) {\n  return Object.hasOwn(value, 'name') && isDataType(value.type)\n}\n\n/**\n * Checks if a value is a data type instance.\n * @param {any} value\n * @returns {value is import('./types.js').DataType}\n */\nfunction isDataType(value) {\n  return typeof value?.typeId === 'number';\n}\n\n/**\n * Return a field instance from a field or data type input.\n * @param {FieldInput} value\n *  The value to map to a field.\n * @param {string} [defaultName] The default field name.\n * @param {boolean} [defaultNullable=true] The default nullable value.\n * @returns {import('./types.js').Field} The field instance.\n */\nfunction asField(value, defaultName = '', defaultNullable = true) {\n  return isField(value)\n    ? value\n    : field(\n        defaultName,\n        check(value, isDataType, () => `Data type expected.`),\n        defaultNullable\n      );\n}\n\n/////\n\n/**\n * Return a basic type with only a type id.\n * @template {typeof Type[keyof typeof Type]} T\n * @param {T} typeId The type id.\n */\nconst basicType = (typeId) => ({ typeId });\n\n/**\n * Return a Dictionary data type instance.  A dictionary type consists of a\n * dictionary of values (which may be of any type) and corresponding integer\n * indices that reference those values. If values are repeated, a dictionary\n * encoding can provide substantial space savings. In the IPC format,\n * dictionary indices reside alongside other columns in a record batch, while\n * dictionary values are written to special dictionary batches, linked by a\n * unique dictionary *id*.\n * @param {import('./types.js').DataType} type The data type of dictionary\n *  values.\n * @param {import('./types.js').IntType} [indexType] The data type of\n *  dictionary indices. Must be an integer type (default `int32`).\n * @param {boolean} [ordered=false] Indicates if dictionary values are\n *  ordered (default `false`).\n * @param {number} [id=-1] The dictionary id. The default value (-1) indicates\n *  the dictionary applies to a single column only. Provide an explicit id in\n *  order to reuse a dictionary across columns when building, in which case\n *  different dictionaries *must* have different unique ids. All dictionary\n *  ids are later resolved (possibly to new values) upon IPC encoding.\n * @returns {import('./types.js').DictionaryType}\n */\nexport const dictionary = (type, indexType, ordered = false, id = -1) => ({\n  typeId: Type.Dictionary,\n  id,\n  dictionary: type,\n  indices: indexType || int32(),\n  ordered\n});\n\n/**\n * Return a Null data type instance. Null data requires no storage and all\n * extracted values are `null`.\n * @returns {import('./types.js').NullType} The null data type.\n */\nexport const nullType = () => basicType(Type.Null);\n\n/**\n * Return an Int data type instance.\n * @param {import('./types.js').IntBitWidth} [bitWidth=32] The integer bit width.\n *  One of `8`, `16`, `32` (default), or `64`.\n * @param {boolean} [signed=true] Flag for signed or unsigned integers\n *  (default `true`).\n * @returns {import('./types.js').IntType} The integer data type.\n */\nexport const int = (bitWidth = 32, signed = true) => ({\n  typeId: Type.Int,\n  bitWidth: checkOneOf(bitWidth, [8, 16, 32, 64]),\n  signed,\n  values: intArrayType(bitWidth, signed)\n});\n/**\n * Return an Int data type instance for 8 bit signed integers.\n * @returns {import('./types.js').IntType} The integer data type.\n */\nexport const int8 = () => int(8);\n/**\n * Return an Int data type instance for 16 bit signed integers.\n * @returns {import('./types.js').IntType} The integer data type.\n */\nexport const int16 = () => int(16);\n/**\n * Return an Int data type instance for 32 bit signed integers.\n * @returns {import('./types.js').IntType} The integer data type.\n */\nexport const int32 = () => int(32);\n/**\n * Return an Int data type instance for 64 bit signed integers.\n * @returns {import('./types.js').IntType} The integer data type.\n */\nexport const int64 = () => int(64);\n/**\n * Return an Int data type instance for 8 bit unsigned integers.\n * @returns {import('./types.js').IntType} The integer data type.\n */\nexport const uint8 = () => int(8, false);\n/**\n * Return an Int data type instance for 16 bit unsigned integers.\n * @returns {import('./types.js').IntType} The integer data type.\n */\nexport const uint16 = () => int(16, false);\n/**\n * Return an Int data type instance for 32 bit unsigned integers.\n * @returns {import('./types.js').IntType} The integer data type.\n */\nexport const uint32 = () => int(32, false);\n/**\n * Return an Int data type instance for 64 bit unsigned integers.\n * @returns {import('./types.js').IntType} The integer data type.\n */\nexport const uint64 = () => int(64, false);\n\n/**\n * Return a Float data type instance for floating point numbers.\n * @param {import('./types.js').Precision_} [precision=2] The floating point\n *  precision. One of `Precision.HALF` (16-bit), `Precision.SINGLE` (32-bit)\n *  or `Precision.DOUBLE` (64-bit, default).\n * @returns {import('./types.js').FloatType} The floating point data type.\n */\nexport const float = (precision = 2) => ({\n  typeId: Type.Float,\n  precision: checkOneOf(precision, Precision),\n  values: [uint16Array, float32Array, float64Array][precision]\n});\n/**\n * Return a Float data type instance for half-precision (16 bit) numbers.\n * @returns {import('./types.js').FloatType} The floating point data type.\n */\nexport const float16 = () => float(Precision.HALF);\n/**\n * Return a Float data type instance for single-precision (32 bit) numbers.\n * @returns {import('./types.js').FloatType} The floating point data type.\n */\nexport const float32 = () => float(Precision.SINGLE);\n/**\n * Return a Float data type instance for double-precision (64 bit) numbers.\n * @returns {import('./types.js').FloatType} The floating point data type.\n */\nexport const float64 = () => float(Precision.DOUBLE);\n\n/**\n * Return a Binary data type instance for variably-sized opaque binary data\n * with 32-bit offsets.\n * @returns {import('./types.js').BinaryType} The binary data type.\n */\nexport const binary = () => ({\n  typeId: Type.Binary,\n  offsets: int32Array\n});\n\n/**\n * Return a Utf8 data type instance for Unicode string data.\n * [UTF-8](https://en.wikipedia.org/wiki/UTF-8) code points are stored as\n * binary data.\n * @returns {import('./types.js').Utf8Type} The utf8 data type.\n */\nexport const utf8 = () => ({\n  typeId: Type.Utf8,\n  offsets: int32Array\n});\n\n/**\n * Return a Bool data type instance. Bool values are stored compactly in\n * bitmaps with eight values per byte.\n * @returns {import('./types.js').BoolType} The bool data type.\n */\nexport const bool = () => basicType(Type.Bool);\n\n/**\n * Return a Decimal data type instance. Decimal values are represented as 32,\n * 64, 128, or 256 bit integers in two's complement. Decimals are fixed point\n * numbers with a set *precision* (total number of decimal digits) and *scale*\n * (number of fractional digits). For example, the number `35.42` can be\n * represented as `3542` with *precision*  4 and *scale* = 2.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @param {32 | 64 | 128 | 256} [bitWidth] The decimal bit width.\n *  One of 32, 64, 128 (default), or 256.\n * @returns {import('./types.js').DecimalType} The decimal data type.\n */\nexport const decimal = (precision, scale, bitWidth = 128) => ({\n  typeId: Type.Decimal,\n  precision,\n  scale,\n  bitWidth: checkOneOf(bitWidth, [32, 64, 128, 256]),\n  values: bitWidth === 32 ? int32Array : uint64Array\n});\n/**\n * Return an Decimal data type instance with a bit width of 32.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {import('./types.js').DecimalType} The decimal data type.\n */\nexport const decimal32 = (precision, scale) => decimal(precision, scale, 32);\n/**\n * Return an Decimal data type instance with a bit width of 64.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {import('./types.js').DecimalType} The decimal data type.\n */\nexport const decimal64 = (precision, scale) => decimal(precision, scale, 64);\n/**\n * Return an Decimal data type instance with a bit width of 128.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {import('./types.js').DecimalType} The decimal data type.\n */\nexport const decimal128 = (precision, scale) => decimal(precision, scale, 128);\n/**\n * Return an Decimal data type instance with a bit width of 256.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {import('./types.js').DecimalType} The decimal data type.\n */\nexport const decimal256 = (precision, scale) => decimal(precision, scale, 256);\n\n/**\n * Return a Date data type instance. Date values are 32-bit or 64-bit signed\n * integers representing elapsed time since the UNIX epoch (Jan 1, 1970 UTC),\n * either in units of days (32 bits) or milliseconds (64 bits, with values\n * evenly divisible by 86400000).\n * @param {import('./types.js').DateUnit_} unit The date unit.\n *  One of `DateUnit.DAY` or `DateUnit.MILLISECOND`.\n * @returns {import('./types.js').DateType} The date data type.\n */\nexport const date = (unit) => ({\n  typeId: Type.Date,\n  unit: checkOneOf(unit, DateUnit),\n  values: unit === DateUnit.DAY ? int32Array : int64Array\n});\n/**\n * Return a Date data type instance with units of days.\n * @returns {import('./types.js').DateType} The date data type.\n */\nexport const dateDay = () => date(DateUnit.DAY);\n/**\n * Return a Date data type instance with units of milliseconds.\n * @returns {import('./types.js').DateType} The date data type.\n */\nexport const dateMillisecond = () => date(DateUnit.MILLISECOND);\n\n/**\n * Return a Time data type instance, stored in one of four *unit*s: seconds,\n * milliseconds, microseconds or nanoseconds. The integer *bitWidth* depends\n * on the *unit* and must be 32 bits for seconds and milliseconds or 64 bits\n * for microseconds and nanoseconds. The allowed values are between 0\n * (inclusive) and 86400 (=24*60*60) seconds (exclusive), adjusted for the\n * time unit (for example, up to 86400000 exclusive for the\n * `DateUnit.MILLISECOND` unit.\n *\n * This definition doesn't allow for leap seconds. Time values from\n * measurements with leap seconds will need to be corrected when ingesting\n * into Arrow (for example by replacing the value 86400 with 86399).\n * @param {import('./types.js').TimeUnit_} unit The time unit.\n *  One of `TimeUnit.SECOND`, `TimeUnit.MILLISECOND` (default),\n *  `TimeUnit.MICROSECOND`, or `TimeUnit.NANOSECOND`.\n * @param {32 | 64} bitWidth The time bit width. One of `32` (for seconds\n *  and milliseconds) or `64` (for microseconds and nanoseconds).\n * @returns {import('./types.js').TimeType} The time data type.\n */\nexport const time = (unit = TimeUnit.MILLISECOND, bitWidth = 32) => ({\n  typeId: Type.Time,\n  unit: checkOneOf(unit, TimeUnit),\n  bitWidth: checkOneOf(bitWidth, [32, 64]),\n  values: bitWidth === 32 ? int32Array : int64Array\n});\n/**\n * Return a Time data type instance, represented as seconds.\n * @returns {import('./types.js').TimeType} The time data type.\n */\nexport const timeSecond = () => time(TimeUnit.SECOND, 32);\n/**\n * Return a Time data type instance, represented as milliseconds.\n * @returns {import('./types.js').TimeType} The time data type.\n */\nexport const timeMillisecond = () => time(TimeUnit.MILLISECOND, 32);\n/**\n * Return a Time data type instance, represented as microseconds.\n * @returns {import('./types.js').TimeType} The time data type.\n */\nexport const timeMicrosecond = () => time(TimeUnit.MICROSECOND, 64);\n/**\n * Return a Time data type instance, represented as nanoseconds.\n * @returns {import('./types.js').TimeType} The time data type.\n */\nexport const timeNanosecond = () => time(TimeUnit.NANOSECOND, 64);\n\n/**\n * Return a Timestamp data type instance. Timestamp values are 64-bit signed\n * integers representing an elapsed time since a fixed epoch, stored in either\n * of four units: seconds, milliseconds, microseconds or nanoseconds, and are\n * optionally annotated with a timezone. Timestamp values do not include any\n * leap seconds (in other words, all days are considered 86400 seconds long).\n * @param {import('./types.js').TimeUnit_} [unit] The time unit.\n *  One of `TimeUnit.SECOND`, `TimeUnit.MILLISECOND` (default),\n *  `TimeUnit.MICROSECOND`, or `TimeUnit.NANOSECOND`.\n * @param {string|null} [timezone=null] An optional string for the name of a\n *  timezone. If provided, the value should either be a string as used in the\n *  Olson timezone database (the \"tz database\" or \"tzdata\"), such as\n *  \"America/New_York\", or an absolute timezone offset of the form \"+XX:XX\" or\n *  \"-XX:XX\", such as \"+07:30\".Whether a timezone string is present indicates\n *  different semantics about the data.\n * @returns {import('./types.js').TimestampType} The time data type.\n */\nexport const timestamp = (unit = TimeUnit.MILLISECOND, timezone = null) => ({\n  typeId: Type.Timestamp,\n  unit: checkOneOf(unit, TimeUnit),\n  timezone,\n  values: int64Array\n});\n\n/**\n * Return an Interval type instance. Values represent calendar intervals stored\n * as integers for each date part. The supported *unit*s are year/moth,\n * day/time, and month/day/nanosecond intervals.\n *\n * `IntervalUnit.YEAR_MONTH` indicates the number of elapsed whole months,\n * stored as 32-bit signed integers.\n *\n * `IntervalUnit.DAY_TIME` indicates the number of elapsed days and\n * milliseconds (no leap seconds), stored as 2 contiguous 32-bit signed\n * integers (8-bytes in total).\n *\n * `IntervalUnit.MONTH_DAY_NANO` is a triple of the number of elapsed months,\n * days, and nanoseconds. The values are stored contiguously in 16-byte blocks.\n * Months and days are encoded as 32-bit signed integers and nanoseconds is\n * encoded as a 64-bit signed integer. Nanoseconds does not allow for leap\n * seconds. Each field is independent (e.g. there is no constraint that\n * nanoseconds have the same sign as days or that the quantity of nanoseconds\n * represents less than a day's worth of time).\n * @param {import('./types.js').IntervalUnit_} unit  The interval unit.\n *  One of `IntervalUnit.YEAR_MONTH`, `IntervalUnit.DAY_TIME`, or\n *  `IntervalUnit.MONTH_DAY_NANO` (default).\n * @returns {import('./types.js').IntervalType} The interval data type.\n */\nexport const interval = (unit = IntervalUnit.MONTH_DAY_NANO) => ({\n  typeId: Type.Interval,\n  unit: checkOneOf(unit, IntervalUnit),\n  values: unit === IntervalUnit.MONTH_DAY_NANO ? undefined : int32Array\n});\n\n/**\n * Return a List data type instance, representing variably-sized lists\n * (arrays) with 32-bit offsets. A list has a single child data type for\n * list entries. Lists are represented using integer offsets that indicate\n * list extents within a single child array containing all list values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {import('./types.js').ListType} The list data type.\n */\nexport const list = (child) => ({\n  typeId: Type.List,\n  children: [ asField(child) ],\n  offsets: int32Array\n});\n\n/**\n * Return a Struct data type instance. A struct consists of multiple named\n * child data types. Struct values are stored as parallel child batches, one\n * per child type, and extracted to standard JavaScript objects.\n * @param {import('./types.js').Field[] | Record<string, import('./types.js').DataType>} children\n *  An array of property fields, or an object mapping property names to data\n *  types. If an object, the instantiated fields are assumed to be nullable\n *  and have no metadata.\n * @returns {import('./types.js').StructType} The struct data type.\n */\nexport const struct = (children) => ({\n  typeId: Type.Struct,\n  children: Array.isArray(children) && isField(children[0])\n    ? /** @type {import('./types.js').Field[]} */ (children)\n    : Object.entries(children).map(([name, type]) => field(name, type))\n});\n\n/**\n * Return a Union type instance. A union is a complex type with parallel\n * *children* data types. Union values are stored in either a sparse\n * (`UnionMode.Sparse`) or dense (`UnionMode.Dense`) layout *mode*. In a\n * sparse layout, child types are stored in parallel arrays with the same\n * lengths, resulting in many unused, empty values. In a dense layout, child\n * types have variable lengths and an offsets array is used to index the\n * appropriate value.\n *\n * By default, ids in the type vector refer to the index in the children\n * array. Optionally, *typeIds* provide an indirection between the child\n * index and the type id. For each child, `typeIds[index]` is the id used\n * in the type vector. The *typeIdForValue* argument provides a lookup\n * function for mapping input data to the proper child type id, and is\n * required if using builder methods.\n * @param {import('./types.js').UnionMode_} mode The union mode.\n *  One of `UnionMode.Sparse` or `UnionMode.Dense`.\n * @param {FieldInput[]} children The children fields or data types.\n *  Types are mapped to nullable fields with no metadata.\n * @param {number[]} [typeIds]  Children type ids, in the same order as the\n *  children types. Type ids provide a level of indirection over children\n *  types. If not provided, the children indices are used as the type ids.\n * @param {(value: any, index: number) => number} [typeIdForValue]\n *  A function that takes an arbitrary value and a row index and returns a\n *  correponding union type id. Required by builder methods.\n * @returns {import('./types.js').UnionType} The union data type.\n */\nexport const union = (mode, children, typeIds, typeIdForValue) => {\n  typeIds ??= children.map((v, i) => i);\n  return {\n    typeId: Type.Union,\n    mode: checkOneOf(mode, UnionMode),\n    typeIds,\n    typeMap: typeIds.reduce((m, id, i) => ((m[id] = i), m), {}),\n    children: children.map((v, i) => asField(v, `_${i}`)),\n    typeIdForValue,\n    offsets: int32Array,\n  };\n};\n\n/**\n * Create a FixedSizeBinary data type instance for opaque binary data where\n * each entry has the same fixed size.\n * @param {number} stride The fixed size in bytes.\n * @returns {import('./types.js').FixedSizeBinaryType} The fixed size binary data type.\n */\nexport const fixedSizeBinary = (stride) => ({\n  typeId: Type.FixedSizeBinary,\n  stride\n});\n\n/**\n * Return a FixedSizeList type instance for list (array) data where every list\n * has the same fixed size. A list has a single child data type for list\n * entries. Fixed size lists are represented as a single child array containing\n * all list values, indexed using the known stride.\n * @param {FieldInput} child The list item data type.\n * @param {number} stride The fixed list size.\n * @returns {import('./types.js').FixedSizeListType} The fixed size list data type.\n */\nexport const fixedSizeList = (child, stride) => ({\n  typeId: Type.FixedSizeList,\n  stride,\n  children: [ asField(child) ]\n});\n\n/**\n * Internal method to create a Map type instance.\n * @param {boolean} keysSorted Flag indicating if the map keys are sorted.\n * @param {import('./types.js').Field} child The child fields.\n * @returns {import('./types.js').MapType} The map data type.\n */\nexport const mapType = (keysSorted, child) => ({\n  typeId: Type.Map,\n  keysSorted,\n  children: [child],\n  offsets: int32Array\n});\n\n/**\n * Return a Map data type instance representing collections of key-value pairs.\n * A Map is a logical nested type that is represented as a list of key-value\n * structs. The key and value types are not constrained, so the application is\n * responsible for ensuring that the keys are hashable and unique, and that\n * keys are properly sorted if *keysSorted* is `true`.\n * @param {FieldInput} keyField The map key field or data type.\n * @param {FieldInput} valueField The map value field or data type.\n * @param {boolean} [keysSorted=false] Flag indicating if the map keys are\n *  sorted (default `false`).\n * @returns {import('./types.js').MapType} The map data type.\n */\nexport const map = (keyField, valueField, keysSorted = false) => mapType(\n  keysSorted,\n  field(\n    'entries',\n    struct([ asField(keyField, 'key', false), asField(valueField, 'value') ]),\n    false\n  )\n);\n\n/**\n * Return a Duration data type instance. Durations represent an absolute length\n * of time unrelated to any calendar artifacts. The resolution defaults to\n * millisecond, but can be any of the other `TimeUnit` values. This type is\n * always represented as a 64-bit integer.\n * @param {import('./types.js').TimeUnit_} unit\n * @returns {import('./types.js').DurationType} The duration data type.\n */\nexport const duration = (unit = TimeUnit.MILLISECOND) => ({\n  typeId: Type.Duration,\n  unit: checkOneOf(unit, TimeUnit),\n  values: int64Array\n});\n\n/**\n * Return a LargeBinary data type instance for variably-sized opaque binary\n * data with 64-bit offsets, allowing representation of extremely large data\n * values.\n * @returns {import('./types.js').LargeBinaryType} The large binary data type.\n */\nexport const largeBinary = () => ({\n  typeId: Type.LargeBinary,\n  offsets: int64Array\n});\n\n/**\n * Return a LargeUtf8 data type instance for Unicode string data of variable\n * length with 64-bit offsets, allowing representation of extremely large data\n * values. [UTF-8](https://en.wikipedia.org/wiki/UTF-8) code points are stored\n * as binary data.\n * @returns {import('./types.js').LargeUtf8Type} The large utf8 data type.\n */\nexport const largeUtf8 = () => ({\n  typeId: Type.LargeUtf8,\n  offsets: int64Array\n});\n\n/**\n * Return a LargeList data type instance, representing variably-sized lists\n * (arrays) with 64-bit offsets, allowing representation of extremely large\n * data values. A list has a single child data type for list entries. Lists\n * are represented using integer offsets that indicate list extents within a\n * single child array containing all list values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {import('./types.js').LargeListType} The large list data type.\n */\nexport const largeList = (child) => ({\n  typeId: Type.LargeList,\n  children: [ asField(child) ],\n  offsets: int64Array\n});\n\n/**\n * Return a RunEndEncoded data type instance, which compresses data by\n * representing consecutive repeated values as a run. This data type uses two\n * child arrays, `run_ends` and `values`. The `run_ends` child array must be\n * a 16, 32, or 64 bit integer array which encodes the indices at which the\n * run with the value in each corresponding index in the values child array\n * ends. Like list and struct types, the `values` array can be of any type.\n * @param {FieldInput} runsField The run-ends field or data type.\n * @param {FieldInput} valuesField The values field or data type.\n * @returns {import('./types.js').RunEndEncodedType} The large list data type.\n */\nexport const runEndEncoded = (runsField, valuesField) => ({\n  typeId: Type.RunEndEncoded,\n  children: [\n    check(\n      asField(runsField, 'run_ends'),\n      (field) => field.type.typeId === Type.Int,\n      () => 'Run-ends must have an integer type.'\n    ),\n    asField(valuesField, 'values')\n  ]\n});\n\n/**\n * Return a BinaryView data type instance. BinaryView data is logically the\n * same as the Binary type, but the internal representation uses a view struct\n * that contains the string length and either the string's entire data inline\n * (for small strings) or an inlined prefix, an index of another buffer, and an\n * offset pointing to a slice in that buffer (for non-small strings).\n *\n * Flechette can encode and decode BinaryView data; however, Flechette does\n * not currently support building BinaryView columns from JavaScript values.\n * @returns {import('./types.js').BinaryViewType} The binary view data type.\n */\nexport const binaryView = () => /** @type{import('./types.js').BinaryViewType} */\n  (basicType(Type.BinaryView));\n\n/**\n * Return a Utf8View data type instance. Utf8View data is logically the same as\n * the Utf8 type, but the internal representation uses a view struct that\n * contains the string length and either the string's entire data inline (for\n * small strings) or an inlined prefix, an index of another buffer, and an\n * offset pointing to a slice in that buffer (for non-small strings).\n *\n * Flechette can encode and decode Utf8View data; however, Flechette does\n * not currently support building Utf8View columns from JavaScript values.\n * @returns {import('./types.js').Utf8ViewType} The utf8 view data type.\n */\nexport const utf8View = () => /** @type{import('./types.js').Utf8ViewType} */\n  (basicType(Type.Utf8View));\n\n/**\n * Return a ListView data type instance, representing variably-sized lists\n * (arrays) with 32-bit offsets. ListView data represents the same logical\n * types that List can, but contains both offsets and sizes allowing for\n * writes in any order and sharing of child values among list values.\n *\n * Flechette can encode and decode ListView data; however, Flechette does not\n * currently support building ListView columns from JavaScript values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {import('./types.js').ListViewType} The list view data type.\n */\nexport const listView = (child) => ({\n  typeId: Type.ListView,\n  children: [ asField(child, 'value') ],\n  offsets: int32Array\n});\n\n/**\n * Return a LargeListView data type instance, representing variably-sized lists\n * (arrays) with 64-bit offsets, allowing representation of extremely large\n * data values. LargeListView data represents the same logical types that\n * LargeList can, but contains both offsets and sizes allowing for writes\n * in any order and sharing of child values among list values.\n *\n * Flechette can encode and decode LargeListView data; however, Flechette does\n * not currently support building LargeListView columns from JavaScript values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {import('./types.js').LargeListViewType} The large list view data type.\n */\nexport const largeListView = (child) => ({\n  typeId: Type.LargeListView,\n  children: [ asField(child, 'value') ],\n  offsets: int64Array\n});\n","import { float64Array, int32Array, int64Array, isInt64ArrayType, uint32Array, uint8Array } from './arrays.js';\nimport { TimeUnit } from '../constants.js';\n\n// typed arrays over a shared buffer to aid binary conversion\nconst f64 = new float64Array(2);\nconst buf = f64.buffer;\nconst i64 = new int64Array(buf);\nconst u32 = new uint32Array(buf);\nconst i32 = new int32Array(buf);\nconst u8 = new uint8Array(buf);\n\n/**\n * Return a value unchanged.\n * @template T\n * @param {T} value The value.\n * @returns {T} The value.\n */\nexport function identity(value) {\n  return value;\n}\n\n/**\n * Return a value coerced to a BigInt.\n * @param {*} value The value.\n * @returns {bigint} The BigInt value.\n */\nexport function toBigInt(value) {\n  return BigInt(value);\n}\n\n/**\n * Return an offset conversion method for the given data type.\n * @param {{ offsets: import('../types.js').TypedArray}} type The array type.\n */\nexport function toOffset(type) {\n  return isInt64ArrayType(type) ? toBigInt : identity;\n}\n\n/**\n * Return the number of days from a millisecond timestamp.\n * @param {number} value The millisecond timestamp.\n * @returns {number} The number of days.\n */\nexport function toDateDay(value) {\n  return (value / 864e5) | 0;\n}\n\n/**\n * Return a timestamp conversion method for the given time unit.\n * @param {import('../types.js').TimeUnit_} unit The time unit.\n * @returns {(value: number) => bigint} The conversion method.\n */\nexport function toTimestamp(unit) {\n  return unit === TimeUnit.SECOND ? value => toBigInt(value / 1e3)\n    : unit === TimeUnit.MILLISECOND ? toBigInt\n    : unit === TimeUnit.MICROSECOND ? value => toBigInt(value * 1e3)\n    : value => toBigInt(value * 1e6);\n}\n\n/**\n * Write month/day/nanosecond interval to a byte buffer.\n * @param {Array | Float64Array} interval The interval data.\n * @returns {Uint8Array} A byte buffer with the interval data.\n *  The returned buffer is reused across calls, and so should be\n *  copied to a target buffer immediately.\n */\nexport function toMonthDayNanoBytes([m, d, n]) {\n  i32[0] = m;\n  i32[1] = d;\n  i64[1] = toBigInt(n);\n  return u8;\n}\n\n/**\n * Coerce a bigint value to a number. Throws an error if the bigint value\n * lies outside the range of what a number can precisely represent.\n * @param {bigint} value The value to check and possibly convert.\n * @returns {number} The converted number value.\n */\nexport function toNumber(value) {\n  if (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER) {\n    throw Error(`BigInt exceeds integer number representation: ${value}`);\n  }\n  return Number(value);\n}\n\n/**\n * Divide one BigInt value by another, and return the result as a number.\n * The division may involve unsafe integers and a loss of precision.\n * @param {bigint} num The numerator.\n * @param {bigint} div The divisor.\n * @returns {number} The result of the division as a floating point number.\n */\nexport function divide(num, div) {\n  return Number(num / div) + Number(num % div) / Number(div);\n}\n\n/**\n * Return a 32-bit decimal conversion method for the given decimal scale.\n * @param {number} scale The scale mapping fractional digits to integers.\n * @returns {(value: number|bigint) => number} A conversion method that maps\n *  floating point numbers to 32-bit decimals.\n */\nexport function toDecimal32(scale) {\n  return (value) => typeof value === 'bigint'\n    ? Number(value)\n    : Math.trunc(value * scale);\n}\n\n/**\n * Convert a floating point number or bigint to decimal bytes.\n * @param {number|bigint} value The number to encode. If a bigint, we assume\n *  it already represents the decimal in integer form with the correct scale.\n *  Otherwise, we assume a float that requires scaled integer conversion.\n * @param {BigUint64Array} buf The uint64 array to write to.\n * @param {number} offset The starting index offset into the array.\n * @param {number} stride The stride of an encoded decimal, in 64-bit steps.\n * @param {number} scale The scale mapping fractional digits to integers.\n */\nexport function toDecimal(value, buf, offset, stride, scale) {\n  const v = typeof value === 'bigint'\n    ? value\n    : toBigInt(Math.trunc(value * scale));\n  // assignment into uint64array performs needed truncation for us\n  buf[offset] = v;\n  if (stride > 1) {\n    buf[offset + 1] = (v >> 64n);\n    if (stride > 2) {\n      buf[offset + 2] = (v >> 128n);\n      buf[offset + 3] = (v >> 192n);\n    }\n  }\n}\n\n// helper method to extract uint64 values from bigints\nconst asUint64 = v => BigInt.asUintN(64, v);\n\n/**\n * Convert a 64-bit decimal value to a bigint.\n * @param {BigUint64Array} buf The uint64 array containing the decimal bytes.\n * @param {number} offset The starting index offset into the array.\n * @returns {bigint} The converted decimal as a bigint, such that all\n *  fractional digits are scaled up to integers (for example, 1.12 -> 112).\n */\nexport function fromDecimal64(buf, offset) {\n  return BigInt.asIntN(64, buf[offset]);\n}\n\n/**\n * Convert a 128-bit decimal value to a bigint.\n * @param {BigUint64Array} buf The uint64 array containing the decimal bytes.\n * @param {number} offset The starting index offset into the array.\n * @returns {bigint} The converted decimal as a bigint, such that all\n *  fractional digits are scaled up to integers (for example, 1.12 -> 112).\n */\nexport function fromDecimal128(buf, offset) {\n  const i = offset << 1;\n  let x;\n  if (BigInt.asIntN(64, buf[i + 1]) < 0) {\n    x = asUint64(~buf[i]) | (asUint64(~buf[i + 1]) << 64n);\n    x = -(x + 1n);\n  } else {\n    x = buf[i] | (buf[i + 1] << 64n);\n  }\n  return x;\n}\n\n/**\n * Convert a 256-bit decimal value to a bigint.\n * @param {BigUint64Array} buf The uint64 array containing the decimal bytes.\n * @param {number} offset The starting index offset into the array.\n * @returns {bigint} The converted decimal as a bigint, such that all\n *  fractional digits are scaled up to integers (for example, 1.12 -> 112).\n */\nexport function fromDecimal256(buf, offset) {\n  const i = offset << 2;\n  let x;\n  if (BigInt.asIntN(64, buf[i + 3]) < 0) {\n    x = asUint64(~buf[i])\n      | (asUint64(~buf[i + 1]) << 64n)\n      | (asUint64(~buf[i + 2]) << 128n)\n      | (asUint64(~buf[i + 3]) << 192n);\n    x = -(x + 1n);\n  } else {\n    x = buf[i]\n      | (buf[i + 1] << 64n)\n      | (buf[i + 2] << 128n)\n      | (buf[i + 3] << 192n);\n  }\n  return x;\n}\n\n/**\n * Convert a 16-bit float from integer bytes to a number.\n * Adapted from https://github.com/apache/arrow/blob/main/js/src/util/math.ts\n * @param {number} value The float as a 16-bit integer.\n * @returns {number} The converted 64-bit floating point number.\n */\nexport function fromFloat16(value) {\n  const expo = (value & 0x7C00) >> 10;\n  const sigf = (value & 0x03FF) / 1024;\n  const sign = (-1) ** ((value & 0x8000) >> 15);\n  switch (expo) {\n    case 0x1F: return sign * (sigf ? Number.NaN : 1 / 0);\n    case 0x00: return sign * (sigf ? 6.103515625e-5 * sigf : 0);\n  }\n  return sign * (2 ** (expo - 15)) * (1 + sigf);\n}\n\n/**\n * Convert a number to a 16-bit float as integer bytes..\n * Inspired by numpy's `npy_double_to_half`:\n * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L43\n * Adapted from https://github.com/apache/arrow/blob/main/js/src/util/math.ts\n * @param {number} value The 64-bit floating point number to convert.\n * @returns {number} The converted 16-bit integer.\n */\nexport function toFloat16(value) {\n  if (value !== value) return 0x7E00; // NaN\n  f64[0] = value;\n\n  // Magic numbers:\n  // 0x80000000 = 10000000 00000000 00000000 00000000 -- masks the 32nd bit\n  // 0x7ff00000 = 01111111 11110000 00000000 00000000 -- masks the 21st-31st bits\n  // 0x000fffff = 00000000 00001111 11111111 11111111 -- masks the 1st-20th bit\n  const sign = (u32[1] & 0x80000000) >> 16 & 0xFFFF;\n  let expo = (u32[1] & 0x7FF00000), sigf = 0x0000;\n\n  if (expo >= 0x40F00000) {\n    //\n    // If exponent overflowed, the float16 is either NaN or Infinity.\n    // Rules to propagate the sign bit: mantissa > 0 ? NaN : +/-Infinity\n    //\n    // Magic numbers:\n    // 0x40F00000 = 01000000 11110000 00000000 00000000 -- 6-bit exponent overflow\n    // 0x7C000000 = 01111100 00000000 00000000 00000000 -- masks the 27th-31st bits\n    //\n    // returns:\n    // qNaN, aka 32256 decimal, 0x7E00 hex, or 01111110 00000000 binary\n    // sNaN, aka 32000 decimal, 0x7D00 hex, or 01111101 00000000 binary\n    // +inf, aka 31744 decimal, 0x7C00 hex, or 01111100 00000000 binary\n    // -inf, aka 64512 decimal, 0xFC00 hex, or 11111100 00000000 binary\n    //\n    // If mantissa is greater than 23 bits, set to +Infinity like numpy\n    if (u32[0] > 0) {\n      expo = 0x7C00;\n    } else {\n      expo = (expo & 0x7C000000) >> 16;\n      sigf = (u32[1] & 0x000FFFFF) >> 10;\n    }\n  } else if (expo <= 0x3F000000) {\n    //\n    // If exponent underflowed, the float is either signed zero or subnormal.\n    //\n    // Magic numbers:\n    // 0x3F000000 = 00111111 00000000 00000000 00000000 -- 6-bit exponent underflow\n    //\n    sigf = 0x100000 + (u32[1] & 0x000FFFFF);\n    sigf = 0x100000 + (sigf << ((expo >> 20) - 998)) >> 21;\n    expo = 0;\n  } else {\n    //\n    // No overflow or underflow, rebase the exponent and round the mantissa\n    // Magic numbers:\n    // 0x200 = 00000010 00000000 -- masks off the 10th bit\n    //\n    // Ensure the first mantissa bit (the 10th one) is 1 and round\n    expo = (expo - 0x3F000000) >> 10;\n    sigf = ((u32[1] & 0x000FFFFF) + 0x200) >> 10;\n  }\n  return sign | expo | sigf & 0xFFFF;\n}\n","import { isArray } from './arrays.js';\nimport { isDate } from './objects.js';\n\nconst textDecoder = new TextDecoder('utf-8');\nconst textEncoder = new TextEncoder();\n\n/**\n * Return a UTF-8 string decoded from a byte buffer.\n * @param {Uint8Array} buf The byte buffer.\n * @returns {string} The decoded string.\n */\nexport function decodeUtf8(buf) {\n  return textDecoder.decode(buf);\n}\n\n/**\n * Return a byte buffer encoded from a UTF-8 string.\n * @param {string } str The string to encode.\n * @returns {Uint8Array} The encoded byte buffer.\n */\nexport function encodeUtf8(str) {\n  return textEncoder.encode(str);\n}\n\n/**\n * Return a string-coercible key value that uniquely identifies a value.\n * @param {*} value The input value.\n * @returns {string} The key string.\n */\nexport function keyString(value) {\n  const val = typeof value !== 'object' || !value ? (value ?? null)\n    : isDate(value) ? +value\n    // @ts-ignore\n    : isArray(value) ? `[${value.map(keyString)}]`\n    : objectKey(value);\n  return `${val}`;\n}\n\nfunction objectKey(value) {\n  let s = '';\n  let i = -1;\n  for (const k in value) {\n    if (++i > 0) s += ',';\n    s += `\"${k}\":${keyString(value[k])}`;\n  }\n  return `{${s}}`;\n}\n","import { toNumber } from './numbers.js';\nimport { decodeUtf8 } from './strings.js';\n\n/** The size in bytes of a 32-bit integer. */\nexport const SIZEOF_INT = 4;\n\n/** The size in bytes of a 16-bit integer. */\nexport const SIZEOF_SHORT = 2;\n\n/**\n * Return a boolean for a single bit in a bitmap.\n * @param {Uint8Array} bitmap The bitmap.\n * @param {number} index The bit index to read.\n * @returns {boolean} The boolean bitmap value.\n */\nexport function decodeBit(bitmap, index) {\n  return (bitmap[index >> 3] & 1 << (index % 8)) !== 0;\n}\n\n/**\n * Lookup helper for flatbuffer object (table) entries.\n * @param {Uint8Array} buf The byte buffer.\n * @param {number} index The base index of the object.\n */\nexport function readObject(buf, index) {\n  const pos = index + readInt32(buf, index);\n  const vtable = pos - readInt32(buf, pos);\n  const size = readInt16(buf, vtable);\n  /**\n   * Retrieve a value from a flatbuffer table layout.\n   * @template T\n   * @param {number} index The table entry index.\n   * @param {(buf: Uint8Array, offset: number) => T} read Read function to invoke.\n   * @param {T} [fallback=null] The default fallback value.\n   * @returns {T}\n   */\n  return (index, read, fallback = null) => {\n    if (index < size) {\n      const off = readInt16(buf, vtable + index);\n      if (off) return read(buf, pos + off);\n    }\n    return fallback;\n  };\n}\n\n/**\n * Return a buffer offset value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readOffset(buf, offset) {\n  return offset;\n}\n\n/**\n * Return a boolean value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {boolean}\n */\nexport function readBoolean(buf, offset) {\n  return !!readInt8(buf, offset);\n}\n\n/**\n * Return a signed 8-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt8(buf, offset) {\n  return readUint8(buf, offset) << 24 >> 24;\n}\n\n/**\n * Return an unsigned 8-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readUint8(buf, offset) {\n  return buf[offset];\n}\n\n/**\n * Return a signed 16-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt16(buf, offset) {\n  return readUint16(buf, offset) << 16 >> 16;\n}\n\n/**\n * Return an unsigned 16-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readUint16(buf, offset) {\n  return buf[offset] | buf[offset + 1] << 8;\n}\n\n/**\n * Return a signed 32-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt32(buf, offset) {\n  return buf[offset]\n    | buf[offset + 1] << 8\n    | buf[offset + 2] << 16\n    | buf[offset + 3] << 24;\n}\n\n/**\n * Return an unsigned 32-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readUint32(buf, offset) {\n  return readInt32(buf, offset) >>> 0;\n}\n\n/**\n * Return a signed 64-bit integer value coerced to a JS number.\n * Throws an error if the value exceeds what a JS number can represent.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt64(buf, offset) {\n  return toNumber(BigInt.asIntN(\n    64,\n    BigInt(readUint32(buf, offset)) +\n      (BigInt(readUint32(buf, offset + SIZEOF_INT)) << 32n)\n  ));\n}\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n * @param {Uint8Array} buf The byte buffer.\n * @param {number} index The index of the string entry.\n * @returns {string} The decoded string.\n */\nexport function readString(buf, index) {\n  let offset = index + readInt32(buf, index); // get the string offset\n  const length = readInt32(buf, offset);  // get the string length\n  offset += SIZEOF_INT; // skip length value\n  return decodeUtf8(buf.subarray(offset, offset + length));\n}\n\n/**\n * Extract a flatbuffer vector to an array.\n * @template T\n * @param {Uint8Array} buf The byte buffer.\n * @param {number} offset The offset location of the vector.\n * @param {number} stride The stride between vector entries.\n * @param {(buf: Uint8Array, pos: number) => T} extract Vector entry extraction function.\n * @returns {T[]} The extracted vector entries.\n */\nexport function readVector(buf, offset, stride, extract) {\n  if (!offset) return [];\n\n  // get base position by adding offset delta\n  const base = offset + readInt32(buf, offset);\n\n  // read vector size, extract entries\n  return Array.from(\n    { length: readInt32(buf, base) },\n    (_, i) => extract(buf, base + SIZEOF_INT + i * stride)\n  );\n}\n","export const RowIndex = Symbol('rowIndex');\n\n/**\n * Returns a row proxy object factory. The resulting method takes a\n * batch-level row index as input and returns an object that proxies\n * access to underlying batches.\n * @param {string[]} names The column (property) names\n * @param {import('../batch.js').Batch[]} batches The value batches.\n * @returns {(index: number) => Record<string, any>}\n */\nexport function proxyFactory(names, batches) {\n  class RowObject {\n    /**\n     * Create a new proxy row object representing a struct or table row.\n     * @param {number} index The record batch row index.\n     */\n    constructor(index) {\n      this[RowIndex] = index;\n    }\n\n    /**\n     * Return a JSON-compatible object representation.\n     */\n    toJSON() {\n      return structObject(names, batches, this[RowIndex]);\n    }\n  };\n\n  // prototype for row proxy objects\n  const proto = RowObject.prototype;\n\n  for (let i = 0; i < names.length; ++i) {\n    // skip duplicated column names\n    if (Object.hasOwn(proto, names[i])) continue;\n\n    // add a getter method for the current batch\n    const batch = batches[i];\n    Object.defineProperty(proto, names[i], {\n      get() { return batch.at(this[RowIndex]); },\n      enumerable: true\n    });\n  }\n\n  return index => new RowObject(index);\n}\n\n/**\n * Returns a row object factory. The resulting method takes a\n * batch-level row index as input and returns an object whose property\n * values have been extracted from the batches.\n * @param {string[]} names The column (property) names\n * @param {import('../batch.js').Batch[]} batches The value batches.\n * @returns {(index: number) => Record<string, any>}\n */\nexport function objectFactory(names, batches) {\n  return index => structObject(names, batches, index);\n}\n\n/**\n * Return a vanilla object representing a struct (row object) type.\n * @param {string[]} names The column (property) names\n * @param {import('../batch.js').Batch[]} batches The value batches.\n * @param {number} index The record batch row index.\n * @returns {Record<string, any>}\n */\nexport function structObject(names, batches, index) {\n  const obj = {};\n  for (let i = 0; i < names.length; ++i) {\n    obj[names[i]] = batches[i].at(index);\n  }\n  return obj;\n}\n","import { bisect, float64Array } from './util/arrays.js';\nimport { divide, fromDecimal128, fromDecimal256, fromDecimal64, toNumber } from './util/numbers.js';\nimport { decodeBit, readInt32, readInt64 } from './util/read.js';\nimport { decodeUtf8 } from './util/strings.js';\nimport { objectFactory, proxyFactory } from './util/struct.js';\n\n/**\n * Check if the input is a batch that supports direct access to\n * binary data in the form of typed arrays.\n * @param {Batch<any>?} batch The data batch to check.\n * @returns {boolean} True if a direct batch, false otherwise.\n */\nexport function isDirectBatch(batch) {\n  return batch instanceof DirectBatch;\n}\n\n/**\n * Column values from a single record batch.\n * A column may contain multiple batches.\n * @template T\n */\nexport class Batch {\n  /**\n   * The array type to use when extracting data from the batch.\n   * A null value indicates that the array type should match\n   * the type of the batch's values array.\n   * @type {ArrayConstructor | import('./types.js').TypedArrayConstructor | null}\n   */\n  static ArrayType = null;\n\n  /**\n   * Create a new column batch.\n   * @param {object} options\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {import('./types.js').DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {import('./types.js').TypedArray} [options.values] Values buffer\n   * @param {import('./types.js').OffsetArray} [options.offsets] Offsets buffer\n   * @param {import('./types.js').OffsetArray} [options.sizes] Sizes buffer\n   * @param {Batch[]} [options.children] Children batches\n   */\n  constructor({\n    length,\n    nullCount,\n    type,\n    validity,\n    values,\n    offsets,\n    sizes,\n    children\n  }) {\n    this.length = length;\n    this.nullCount = nullCount;\n    this.type = type;\n    this.validity = validity;\n    this.values = values;\n    this.offsets = offsets;\n    this.sizes = sizes;\n    this.children = children;\n\n    // optimize access if this batch has no null values\n    // some types (like union) may have null values in\n    // child batches, but no top-level validity buffer\n    if (!nullCount || !this.validity) {\n      /** @type {(index: number) => T | null} */\n      this.at = index => this.value(index);\n    }\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    return 'Batch';\n  }\n\n  /**\n   * Return the value at the given index.\n   * @param {number} index The value index.\n   * @returns {T | null} The value.\n   */\n  at(index) {\n    return this.isValid(index) ? this.value(index) : null;\n  }\n\n  /**\n   * Check if a value at the given index is valid (non-null).\n   * @param {number} index The value index.\n   * @returns {boolean} True if valid, false otherwise.\n   */\n  isValid(index) {\n    return decodeBit(this.validity, index);\n  }\n\n  /**\n   * Return the value at the given index. This method does not check the\n   * validity bitmap and is intended primarily for internal use. In most\n   * cases, callers should use the `at()` method instead.\n   * @param {number} index The value index\n   * @returns {T} The value, ignoring the validity bitmap.\n   */\n  value(index) {\n    return /** @type {T} */ (this.values[index]);\n  }\n\n  /**\n   * Extract an array of values within the given index range. Unlike\n   * Array.slice, all arguments are required and may not be negative indices.\n   * @param {number} start The starting index, inclusive\n   * @param {number} end The ending index, exclusive\n   * @returns {import('./types.js').ValueArray<T?>} The slice of values\n   */\n  slice(start, end) {\n    const n = end - start;\n    const values = Array(n);\n    for (let i = 0; i < n; ++i) {\n      values[i] = this.at(start + i);\n    }\n    return values;\n  }\n\n  /**\n   * Return an iterator over the values in this batch.\n   * @returns {Iterator<T?>}\n   */\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.length; ++i) {\n      yield this.at(i);\n    }\n  }\n}\n\n/**\n * A batch whose value buffer can be used directly, without transformation.\n * @template T\n * @extends {Batch<T>}\n */\nexport class DirectBatch extends Batch {\n  /**\n   * Create a new column batch with direct value array access.\n   * @param {object} options\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {import('./types.js').DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {import('./types.js').TypedArray} options.values Values buffer\n   */\n  constructor(options) {\n    super(options);\n    // underlying buffers may be padded, exceeding the logical batch length\n    // we trim the values array so we can safely access it directly\n    const { length, values } = this;\n    this.values = values.subarray(0, length);\n  }\n\n  /**\n   * Extract an array of values within the given index range. Unlike\n   * Array.slice, all arguments are required and may not be negative indices.\n   * When feasible, a zero-copy subarray of a typed array is returned.\n   * @param {number} start The starting index, inclusive\n   * @param {number} end The ending index, exclusive\n   * @returns {import('./types.js').ValueArray<T?>} The slice of values\n   */\n  slice(start, end) {\n    // @ts-ignore\n    return this.nullCount\n      ? super.slice(start, end)\n      : this.values.subarray(start, end);\n  }\n\n  /**\n   * Return an iterator over the values in this batch.\n   * @returns {Iterator<T?>}\n   */\n  [Symbol.iterator]() {\n    return this.nullCount\n      ? super[Symbol.iterator]()\n      : /** @type {Iterator<T?>} */ (this.values[Symbol.iterator]());\n  }\n}\n\n/**\n * A batch whose values are transformed to 64-bit numbers.\n * @extends {Batch<number>}\n */\nexport class NumberBatch extends Batch {\n  static ArrayType = float64Array;\n}\n\n/**\n * A batch whose values should be returned in a standard array.\n * @template T\n * @extends {Batch<T>}\n */\nexport class ArrayBatch extends Batch {\n  static ArrayType = Array;\n}\n\n/**\n * A batch of null values only.\n * @extends {ArrayBatch<null>}\n */\nexport class NullBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   * @returns {null}\n   */\n  value(index) { // eslint-disable-line no-unused-vars\n    return null;\n  }\n}\n\n/**\n * A batch that coerces BigInt values to 64-bit numbers.\n * @extends {NumberBatch}\n */\nexport class Int64Batch extends NumberBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return toNumber(/** @type {bigint} */ (this.values[index]));\n  }\n}\n\n/**\n * A batch of 16-bit floating point numbers, accessed as unsigned\n * 16-bit ints and transformed to 64-bit numbers.\n */\nexport class Float16Batch extends NumberBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    const v = /** @type {number} */ (this.values[index]);\n    const expo = (v & 0x7C00) >> 10;\n    const sigf = (v & 0x03FF) / 1024;\n    const sign = (-1) ** ((v & 0x8000) >> 15);\n    switch (expo) {\n      case 0x1F: return sign * (sigf ? Number.NaN : 1 / 0);\n      case 0x00: return sign * (sigf ? 6.103515625e-5 * sigf : 0);\n    }\n    return sign * (2 ** (expo - 15)) * (1 + sigf);\n  }\n}\n\n/**\n * A batch of boolean values stored as a bitmap.\n * @extends {ArrayBatch<boolean>}\n */\nexport class BoolBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return decodeBit(/** @type {Uint8Array} */ (this.values), index);\n  }\n}\n\n/**\n * A batch of 32-bit decimal numbers, returned as converted 64-bit floating\n * point numbers. Number coercion may be lossy if the decimal precision can\n * not be represented in a 64-bit floating point format.\n * @extends {NumberBatch}\n */\nexport class Decimal32NumberBatch extends NumberBatch {\n  constructor(options) {\n    super(options);\n    const { scale } = /** @type {import('./types.js').DecimalType} */ (this.type);\n    this.scale = 10 ** scale;\n  }\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return /** @type {number} */(this.values[index]) / this.scale;\n  }\n}\n\n/**\n * An abstract class for a batch of 64-, 128- or 256-bit decimal numbers,\n * accessed in strided BigUint64Arrays.\n * @template T\n * @extends {Batch<T>}\n */\nexport class DecimalBatch extends Batch {\n  constructor(options) {\n    super(options);\n    const { bitWidth, scale } = /** @type {import('./types.js').DecimalType} */ (this.type);\n    this.decimal = bitWidth === 64 ? fromDecimal64\n      : bitWidth === 128 ? fromDecimal128\n      : fromDecimal256;\n    this.scale = 10n ** BigInt(scale);\n  }\n}\n\n/**\n * A batch of 64-, 128- or 256-bit decimal numbers, returned as converted\n * 64-bit floating point numbers. Number coercion may be lossy if the decimal\n * precision can not be represented in a 64-bit floating point format.\n * @extends {DecimalBatch<number>}\n */\nexport class DecimalNumberBatch extends DecimalBatch {\n  static ArrayType = float64Array;\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return divide(\n      this.decimal(/** @type {BigUint64Array} */ (this.values), index),\n      this.scale\n    );\n  }\n}\n\n/**\n * A batch of 64-, 128- or 256-bit decimal numbers, returned as scaled\n * bigint values, such that all fractional digits have been shifted\n * to integer places by the decimal type scale factor.\n * @extends {DecimalBatch<bigint>}\n */\nexport class DecimalBigIntBatch extends DecimalBatch {\n  static ArrayType = Array;\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return this.decimal(/** @type {BigUint64Array} */ (this.values), index);\n  }\n}\n\n/**\n * A batch of date or timestamp values that are coerced to UNIX epoch timestamps\n * and returned as JS Date objects. This batch wraps a source batch that provides\n * timestamp values.\n * @extends {ArrayBatch<Date>}\n */\nexport class DateBatch extends ArrayBatch {\n  /**\n   * Create a new date batch.\n   * @param {Batch<number>} batch A batch of timestamp values.\n   */\n  constructor(batch) {\n    super(batch);\n    this.source = batch;\n  }\n\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return new Date(this.source.value(index));\n  }\n}\n\n/**\n * A batch of dates as day counts, coerced to timestamp numbers.\n */\nexport class DateDayBatch extends NumberBatch {\n  /**\n   * @param {number} index The value index\n   * @returns {number}\n   */\n  value(index) {\n    // epoch days to milliseconds\n    return 86400000 * /** @type {number} */ (this.values[index]);\n  }\n}\n\n/**\n * A batch of dates as millisecond timestamps, coerced to numbers.\n */\nexport const DateDayMillisecondBatch = Int64Batch;\n\n/**\n * A batch of timestaps in seconds, coerced to millisecond numbers.\n */\nexport class TimestampSecondBatch extends Int64Batch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return super.value(index) * 1e3; // seconds to milliseconds\n  }\n}\n\n/**\n * A batch of timestaps in milliseconds, coerced to numbers.\n */\nexport const TimestampMillisecondBatch = Int64Batch;\n\n/**\n * A batch of timestaps in microseconds, coerced to millisecond numbers.\n */\nexport class TimestampMicrosecondBatch extends Int64Batch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    // microseconds to milliseconds\n    return divide(/** @type {bigint} */ (this.values[index]), 1000n);\n  }\n}\n\n/**\n * A batch of timestaps in nanoseconds, coerced to millisecond numbers.\n */\nexport class TimestampNanosecondBatch extends Int64Batch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    // nanoseconds to milliseconds\n    return divide(/** @type {bigint} */ (this.values[index]), 1000000n);\n  }\n}\n\n/**\n * A batch of day/time intervals, returned as two-element 32-bit int arrays.\n * @extends {ArrayBatch<Int32Array>}\n */\nexport class IntervalDayTimeBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   * @returns {Int32Array}\n   */\n  value(index) {\n    const values = /** @type {Int32Array} */ (this.values);\n    return values.subarray(index << 1, (index + 1) << 1);\n  }\n}\n\n/**\n * A batch of month/day/nanosecond intervals, returned as three-element arrays.\n * @extends {ArrayBatch<Float64Array>}\n */\nexport class IntervalMonthDayNanoBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    const values = /** @type {Uint8Array} */ (this.values);\n    const base = index << 4;\n    return Float64Array.of(\n      readInt32(values, base),\n      readInt32(values, base + 4),\n      readInt64(values, base + 8)\n    );\n  }\n}\n\nconst offset32 = ({values, offsets}, index) => values.subarray(offsets[index], offsets[index + 1]);\nconst offset64 = ({values, offsets}, index) => values.subarray(toNumber(offsets[index]), toNumber(offsets[index + 1]));\n\n/**\n * A batch of binary blobs with variable offsets, returned as byte buffers of\n * unsigned 8-bit integers. The offsets are 32-bit ints.\n * @extends {ArrayBatch<Uint8Array>}\n */\nexport class BinaryBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {Uint8Array}\n   */\n  value(index) {\n    return offset32(this, index);\n  }\n}\n\n/**\n * A batch of binary blobs with variable offsets, returned as byte buffers of\n * unsigned 8-bit integers. The offsets are 64-bit ints. Value extraction will\n * fail if an offset exceeds `Number.MAX_SAFE_INTEGER`.\n * @extends {ArrayBatch<Uint8Array>}\n */\nexport class LargeBinaryBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {Uint8Array}\n   */\n  value(index) {\n    return offset64(this, index);\n  }\n}\n\n/**\n * A batch of UTF-8 strings with variable offsets. The offsets are 32-bit ints.\n * @extends {ArrayBatch<string>}\n */\nexport class Utf8Batch extends ArrayBatch {\n  /**\n   * @param {number} index\n   */\n  value(index) {\n    return decodeUtf8(offset32(this, index));\n  }\n}\n\n/**\n * A batch of UTF-8 strings with variable offsets. The offsets are 64-bit ints.\n * Value extraction will fail if an offset exceeds `Number.MAX_SAFE_INTEGER`.\n * @extends {ArrayBatch<string>}\n */\nexport class LargeUtf8Batch extends ArrayBatch {\n  /**\n   * @param {number} index\n   */\n  value(index) {\n    return decodeUtf8(offset64(this, index));\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets are\n * 32-bit ints.\n * @template V\n * @extends {ArrayBatch<import('./types.js').ValueArray<V>>}\n */\nexport class ListBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {import('./types.js').ValueArray<V>}\n   */\n  value(index) {\n    const offsets = /** @type {Int32Array} */ (this.offsets);\n    return this.children[0].slice(offsets[index], offsets[index + 1]);\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets are\n * 64-bit ints. Value extraction will fail if an offset exceeds\n * `Number.MAX_SAFE_INTEGER`.\n * @template V\n * @extends {ArrayBatch<import('./types.js').ValueArray<V>>}\n */\nexport class LargeListBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {import('./types.js').ValueArray<V>}\n   */\n  value(index) {\n    const offsets = /** @type {BigInt64Array} */ (this.offsets);\n    return this.children[0].slice(toNumber(offsets[index]), toNumber(offsets[index + 1]));\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets and\n * sizes are 32-bit ints.\n * @template V\n * @extends {ArrayBatch<import('./types.js').ValueArray<V>>}\n */\nexport class ListViewBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {import('./types.js').ValueArray<V>}\n   */\n  value(index) {\n    const a = /** @type {number} */ (this.offsets[index]);\n    const b = a + /** @type {number} */ (this.sizes[index]);\n    return this.children[0].slice(a, b);\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets and\n * sizes are 64-bit ints. Value extraction will fail if an offset or size\n * exceeds `Number.MAX_SAFE_INTEGER`.\n * @template V\n * @extends {ArrayBatch<import('./types.js').ValueArray<V>>}\n */\nexport class LargeListViewBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {import('./types.js').ValueArray<V>}\n   */\n  value(index) {\n    const a = /** @type {bigint} */ (this.offsets[index]);\n    const b = a + /** @type {bigint} */ (this.sizes[index]);\n    return this.children[0].slice(toNumber(a), toNumber(b));\n  }\n}\n\n/**\n * A batch with a fixed stride.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nclass FixedBatch extends ArrayBatch {\n  constructor(options) {\n    super(options);\n    /** @type {number} */\n    // @ts-ignore\n    this.stride = this.type.stride;\n  }\n}\n\n/**\n * A batch of binary blobs of fixed size, returned as byte buffers of unsigned\n * 8-bit integers.\n * @extends {FixedBatch<Uint8Array>}\n */\nexport class FixedBinaryBatch extends FixedBatch {\n  /**\n   * @param {number} index\n   * @returns {Uint8Array}\n   */\n  value(index) {\n    const { stride, values } = this;\n    return /** @type {Uint8Array} */ (values)\n      .subarray(index * stride, (index + 1) * stride);\n  }\n}\n\n/**\n * A batch of list (array) values of fixed length.\n * @template V\n * @extends {FixedBatch<import('./types.js').ValueArray<V>>}\n */\nexport class FixedListBatch extends FixedBatch {\n  /**\n   * @param {number} index\n   * @returns {import('./types.js').ValueArray<V>}\n   */\n  value(index) {\n    const { children, stride } = this;\n    return children[0].slice(index * stride, (index + 1) * stride);\n  }\n}\n\n/**\n * Extract Map key-value pairs from parallel child batches.\n */\nfunction pairs({ children, offsets }, index) {\n  const [ keys, vals ] = children[0].children;\n  const start = offsets[index];\n  const end = offsets[index + 1];\n  const entries = [];\n  for (let i = start; i < end; ++i) {\n    entries.push([keys.at(i), vals.at(i)]);\n  }\n  return entries;\n}\n\n/**\n * A batch of map (key, value) values. The map is represented as a list of\n * key-value structs.\n * @template K, V\n * @extends {ArrayBatch<[K, V][]>}\n */\nexport class MapEntryBatch extends ArrayBatch {\n  /**\n   * Return the value at the given index.\n   * @param {number} index The value index.\n   * @returns {[K, V][]} The map entries as an array of [key, value] arrays.\n   */\n  value(index) {\n    return /** @type {[K, V][]} */ (pairs(this, index));\n  }\n}\n\n/**\n * A batch of map (key, value) values. The map is represented as a list of\n * key-value structs.\n * @template K, V\n * @extends {ArrayBatch<Map<K, V>>}\n */\nexport class MapBatch extends ArrayBatch {\n  /**\n   * Return the value at the given index.\n   * @param {number} index The value index.\n   * @returns {Map<K, V>} The map value.\n   */\n  value(index) {\n    return new Map(/** @type {[K, V][]} */ (pairs(this, index)));\n  }\n}\n\n/**\n * A batch of union-type values with a sparse layout, enabling direct\n * lookup from the child value batches.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nexport class SparseUnionBatch extends ArrayBatch {\n  /**\n   * Create a new column batch.\n   * @param {object} options\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {import('./types.js').DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {Int32Array} [options.offsets] Offsets buffer\n   * @param {Batch[]} options.children Children batches\n   * @param {Int8Array} options.typeIds Union type ids buffer\n   * @param {Record<string, number>} options.map A typeId to children index map\n   */\n  constructor({ typeIds, ...options }) {\n    super(options);\n    /** @type {Int8Array} */\n    this.typeIds = typeIds;\n    /** @type {Record<string, number>} */\n    // @ts-ignore\n    this.typeMap = this.type.typeMap;\n  }\n\n  /**\n   * @param {number} index The value index.\n   */\n  value(index, offset = index) {\n    const { typeIds, children, typeMap } = this;\n    return children[typeMap[typeIds[index]]].at(offset);\n  }\n}\n\n/**\n * A batch of union-type values with a dense layout, reqiring offset\n * lookups from the child value batches.\n * @template T\n * @extends {SparseUnionBatch<T>}\n */\nexport class DenseUnionBatch extends SparseUnionBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return super.value(index, /** @type {number} */ (this.offsets[index]));\n  }\n}\n\n/**\n * A batch of struct values, containing a set of named properties.\n * Struct property values are extracted and returned as JS objects.\n * @extends {ArrayBatch<Record<string, any>>}\n */\nexport class StructBatch extends ArrayBatch {\n  constructor(options, factory = objectFactory) {\n    super(options);\n    /** @type {string[]} */\n    // @ts-ignore\n    this.names = this.type.children.map(child => child.name);\n    this.factory = factory(this.names, this.children);\n  }\n\n  /**\n   * @param {number} index The value index.\n   * @returns {Record<string, any>}\n   */\n  value(index) {\n    return this.factory(index);\n  }\n}\n\n/**\n * A batch of struct values, containing a set of named properties.\n * Structs are returned as proxy objects that extract data directly\n * from underlying Arrow batches.\n * @extends {StructBatch}\n */\nexport class StructProxyBatch extends StructBatch {\n  constructor(options) {\n    super(options, proxyFactory);\n  }\n}\n\n/**\n * A batch of run-end-encoded values.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nexport class RunEndEncodedBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    const [ { values: runs }, vals ] = this.children;\n    return vals.at(\n      bisect(/** @type {import('./types.js').IntegerArray} */(runs), index)\n    );\n  }\n}\n\n/**\n * A batch of dictionary-encoded values.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nexport class DictionaryBatch extends ArrayBatch {\n  /**\n   * Register the backing dictionary. Dictionaries are added\n   * after batch creation as the complete dictionary may not\n   * be finished across multiple record batches.\n   * @param {import('./column.js').Column<T>} dictionary\n   * The dictionary of column values.\n   */\n  setDictionary(dictionary) {\n    this.dictionary = dictionary;\n    this.cache = dictionary.cache();\n    return this;\n  }\n\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return this.cache[this.key(index)];\n  }\n\n  /**\n   * @param {number} index The value index.\n   * @returns {number} The dictionary key\n   */\n  key(index) {\n    return /** @type {number} */ (this.values[index]);\n  }\n}\n\n/**\n * @template T\n * @extends {ArrayBatch<T>}\n */\nclass ViewBatch extends ArrayBatch {\n  /**\n   * Create a new view batch.\n   * @param {object} options Batch options.\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {import('./types.js').DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {Uint8Array} options.values Values buffer\n   * @param {Uint8Array[]} options.data View data buffers\n   */\n  constructor({ data, ...options }) {\n    super(options);\n    this.data = data;\n  }\n\n  /**\n   * Get the binary data at the provided index.\n   * @param {number} index The value index.\n   * @returns {Uint8Array}\n   */\n  view(index) {\n    const { values, data } = this;\n    const offset = index << 4; // each entry is 16 bytes\n    let start = offset + 4;\n    let buf = /** @type {Uint8Array} */ (values);\n    const length = readInt32(buf, offset);\n    if (length > 12) {\n      // longer strings are in a data buffer\n      start = readInt32(buf, offset + 12);\n      buf = data[readInt32(buf, offset + 8)];\n    }\n    return buf.subarray(start, start + length);\n  }\n}\n\n/**\n * A batch of binary blobs from variable data buffers, returned as byte\n * buffers of unsigned 8-bit integers.\n * @extends {ViewBatch<Uint8Array>}\n */\nexport class BinaryViewBatch extends ViewBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return this.view(index);\n  }\n}\n\n/**\n * A batch of UTF-8 strings from variable data buffers.\n * @extends {ViewBatch<string>}\n */\nexport class Utf8ViewBatch extends ViewBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return decodeUtf8(this.view(index));\n  }\n}\n","import { bisect } from './util/arrays.js';\nimport { isDirectBatch } from './batch.js';\n\n/**\n * Build up a column from batches.\n */\nexport function columnBuilder(type) {\n  let data = [];\n  return {\n    add(batch) { data.push(batch); return this; },\n    clear: () => data = [],\n    done: () => new Column(data, type)\n  };\n}\n\n/**\n * A data column. A column provides a view over one or more value batches,\n * each drawn from an Arrow record batch. While this class supports random\n * access to column values by integer index; however, extracting arrays using\n * `toArray()` or iterating over values (`for (const value of column) {...}`)\n * provide more efficient ways for bulk access or scanning.\n * @template T\n */\nexport class Column {\n  /**\n   * Create a new column instance.\n   * @param {import('./batch.js').Batch<T>[]} data The value batches.\n   * @param {import('./types.js').DataType} [type] The column data type.\n   *  If not specified, the type is extracted from the batches.\n   */\n  constructor(data, type = data[0]?.type) {\n    /**\n     * The column data type.\n     * @type {import('./types.js').DataType}\n     * @readonly\n     */\n    this.type = type;\n    /**\n     * The column length.\n     * @type {number}\n     * @readonly\n     */\n    this.length = data.reduce((m, c) => m + c.length, 0);\n    /**\n     * The count of null values in the column.\n     * @type {number}\n     * @readonly\n     */\n    this.nullCount = data.reduce((m, c) => m + c.nullCount, 0);\n    /**\n     * An array of column data batches.\n     * @type {readonly import('./batch.js').Batch<T>[]}\n     * @readonly\n     */\n    this.data = data;\n\n    const n = data.length;\n    const offsets = new Int32Array(n + 1);\n    if (n === 1) {\n      const [ batch ] = data;\n      offsets[1] = batch.length;\n      // optimize access to single batch\n      this.at = index => batch.at(index);\n    } else {\n      for (let i = 0, s = 0; i < n; ++i) {\n        offsets[i + 1] = (s += data[i].length);\n      }\n    }\n\n    /**\n     * Index offsets for data batches.\n     * Used to map a column row index to a batch-specific index.\n     * @type {Int32Array}\n     * @readonly\n     */\n    this.offsets = offsets;\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    return 'Column';\n  }\n\n  /**\n   * Return an iterator over the values in this column.\n   * @returns {Iterator<T?>}\n   */\n  [Symbol.iterator]() {\n    const data = this.data;\n    return data.length === 1\n      ? data[0][Symbol.iterator]()\n      : batchedIterator(data);\n  }\n\n  /**\n   * Return the column value at the given index. If a column has multiple\n   * batches, this method performs binary search over the batch lengths to\n   * determine the batch from which to retrieve the value. The search makes\n   * lookup less efficient than a standard array access. If making a full\n   * scan of a column, consider extracting arrays via `toArray()` or using an\n   * iterator (`for (const value of column) {...}`).\n   * @param {number} index The row index.\n   * @returns {T | null} The value.\n   */\n  at(index) {\n    // NOTE: if there is only one batch, this method is replaced with an\n    // optimized version in the Column constructor.\n    const { data, offsets } = this;\n    const i = bisect(offsets, index) - 1;\n    return data[i]?.at(index - offsets[i]); // undefined if out of range\n  }\n\n  /**\n   * Return the column value at the given index. This method is the same as\n   * `at()` and is provided for better compatibility with Apache Arrow JS.\n   * @param {number} index The row index.\n   * @returns {T | null} The value.\n   */\n  get(index) {\n    return this.at(index);\n  }\n\n  /**\n   * Extract column values into a single array instance. When possible,\n   * a zero-copy subarray of the input Arrow data is returned.\n   * @returns {import('./types.js').ValueArray<T?>}\n   */\n  toArray() {\n    const { length, nullCount, data } = this;\n    const copy = !nullCount && isDirectBatch(data[0]);\n    const n = data.length;\n\n    if (copy && n === 1) {\n      // use batch array directly\n      // @ts-ignore\n      return data[0].values;\n    }\n\n    // determine output array type\n    const ArrayType = !n || nullCount > 0 ? Array\n      // @ts-ignore\n      : (data[0].constructor.ArrayType ?? data[0].values.constructor);\n\n    const array = new ArrayType(length);\n    return copy ? copyArray(array, data) : extractArray(array, data);\n  }\n\n  /**\n   * Return an array of cached column values.\n   * Used internally to accelerate dictionary types.\n   */\n  cache() {\n    return this._cache ?? (this._cache = this.toArray());\n  }\n}\n\nfunction *batchedIterator(data) {\n  for (let i = 0; i < data.length; ++i) {\n    const iter = data[i][Symbol.iterator]();\n    for (let next = iter.next(); !next.done; next = iter.next()) {\n      yield next.value;\n    }\n  }\n}\n\nfunction copyArray(array, data) {\n  for (let i = 0, offset = 0; i < data.length; ++i) {\n    const { values } = data[i];\n    array.set(values, offset);\n    offset += values.length;\n  }\n  return array;\n}\n\nfunction extractArray(array, data) {\n  let index = -1;\n  for (let i = 0; i < data.length; ++i) {\n    const batch = data[i];\n    for (let j = 0; j < batch.length; ++j) {\n      array[++index] = batch.at(j);\n    }\n  }\n  return array;\n}\n","import { bisect } from './util/arrays.js';\nimport { objectFactory, proxyFactory } from './util/struct.js';\n\n/**\n * A table consists of a collection of named columns (or 'children').\n * To work with table data directly in JavaScript, use `toColumns()`\n * to extract an object that maps column names to extracted value arrays,\n * or `toArray()` to extract an array of row objects. For random access\n * by row index, use `getChild()` to access data for a specific column.\n */\nexport class Table {\n  /**\n   * Create a new table with the given schema and columns (children).\n   * @param {import('./types.js').Schema} schema The table schema.\n   * @param {import('./column.js').Column[]} children The table columns.\n   * @param {boolean} [useProxy=false] Flag indicating if row proxy\n   *  objects should be used to represent table rows (default `false`).\n   */\n  constructor(schema, children, useProxy = false) {\n    const names = schema.fields.map(f => f.name);\n\n    /** @readonly */\n    this.schema = schema;\n    /** @readonly */\n    this.names = names;\n    /**\n     * @type {import('./column.js').Column[]}\n     * @readonly\n     */\n    this.children = children;\n    /**\n     * @type {import('./types.js').StructFactory}\n     * @readonly\n     */\n    this.factory = useProxy ? proxyFactory : objectFactory;\n\n    // lazily created row object generators\n    const gen = [];\n\n    /**\n     * Returns a row object generator for the given batch index.\n     * @private\n     * @readonly\n     * @param {number} b The batch index.\n     * @returns {(index: number) => Record<string,any>}\n     */\n    this.getFactory = b => gen[b]\n      ?? (gen[b] = this.factory(names, children.map(c => c.data[b])));\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    return 'Table';\n  }\n\n  /**\n   * The number of columns in this table.\n   * @return {number} The number of columns.\n   */\n  get numCols() {\n    return this.names.length;\n  }\n\n  /**\n   * The number of rows in this table.\n   * @return {number} The number of rows.\n   */\n  get numRows() {\n    return this.children[0]?.length ?? 0;\n  }\n\n  /**\n   * Return the child column at the given index position.\n   * @param {number} index The column index.\n   * @returns {import('./column.js').Column<any>}\n   */\n  getChildAt(index) {\n    return this.children[index];\n  }\n\n  /**\n   * Return the first child column with the given name.\n   * @param {string} name The column name.\n   * @returns {import('./column.js').Column<any>}\n   */\n  getChild(name) {\n    const i = this.names.findIndex(x => x === name);\n    return i > -1 ? this.children[i] : undefined;\n  }\n\n  /**\n   * Construct a new table containing only columns at the specified indices.\n   * The order of columns in the new table matches the order of input indices.\n   * @param {number[]} indices The indices of columns to keep.\n   * @param {string[]} [as] Optional new names for selected columns.\n   * @returns {Table} A new table with columns at the specified indices.\n   */\n  selectAt(indices, as = []) {\n    const { children, factory, schema } = this;\n    const { fields } = schema;\n    return new Table(\n      {\n        ...schema,\n        fields: indices.map((i, j) => renameField(fields[i], as[j]))\n      },\n      indices.map(i => children[i]),\n      factory === proxyFactory\n    );\n  }\n\n  /**\n   * Construct a new table containing only columns with the specified names.\n   * If columns have duplicate names, the first (with lowest index) is used.\n   * The order of columns in the new table matches the order of input names.\n   * @param {string[]} names Names of columns to keep.\n   * @param {string[]} [as] Optional new names for selected columns.\n   * @returns {Table} A new table with columns matching the specified names.\n   */\n  select(names, as) {\n    const all = this.names;\n    const indices = names.map(name => all.indexOf(name));\n    return this.selectAt(indices, as);\n  }\n\n  /**\n   * Return an object mapping column names to extracted value arrays.\n   * @returns {Record<string, import('./types.js').ValueArray<any>>}\n   */\n  toColumns() {\n    const { children, names } = this;\n    /** @type {Record<string, import('./types.js').ValueArray<any>>} */\n    const cols = {};\n    names.forEach((name, i) => cols[name] = children[i]?.toArray() ?? [] );\n    return cols;\n  }\n\n  /**\n   * Return an array of objects representing the rows of this table.\n   * @returns {Record<string, any>[]}\n   */\n  toArray() {\n    const { children, getFactory, numRows } = this;\n    const data = children[0]?.data ?? [];\n    const output = Array(numRows);\n    for (let b = 0, row = -1; b < data.length; ++b) {\n      const f = getFactory(b);\n      for (let i = 0; i < data[b].length; ++i) {\n        output[++row] = f(i);\n      }\n    }\n    return output;\n  }\n\n  /**\n   * Return an iterator over objects representing the rows of this table.\n   * @returns {Generator<Record<string, any>, any, null>}\n   */\n  *[Symbol.iterator]() {\n    const { children, getFactory } = this;\n    const data = children[0]?.data ?? [];\n    for (let b = 0; b < data.length; ++b) {\n      const f = getFactory(b);\n      for (let i = 0; i < data[b].length; ++i) {\n        yield f(i);\n      }\n    }\n  }\n\n  /**\n   * Return a row object for the given index.\n   * @param {number} index The row index.\n   * @returns {Record<string, any>} The row object.\n   */\n  at(index) {\n    const { children, getFactory, numRows } = this;\n    if (index < 0 || index >= numRows) return null;\n    const [{ offsets }] = children;\n    const b = bisect(offsets, index) - 1;\n    return getFactory(b)(index - offsets[b]);\n  }\n\n  /**\n   * Return a row object for the given index. This method is the same as\n   * `at()` and is provided for better compatibility with Apache Arrow JS.\n   * @param {number} index The row index.\n   * @returns {Record<string, any>} The row object.\n   */\n  get(index) {\n    return this.at(index);\n  }\n}\n\nfunction renameField(field, name) {\n  return (name != null && name !== field.name)\n    ? { ...field, name }\n    : field;\n}\n","import { BinaryBatch, BinaryViewBatch, BoolBatch, DateBatch, DateDayBatch, DateDayMillisecondBatch, Decimal32NumberBatch, DecimalBigIntBatch, DecimalNumberBatch, DenseUnionBatch, DictionaryBatch, DirectBatch, FixedBinaryBatch, FixedListBatch, Float16Batch, Int64Batch, IntervalDayTimeBatch, IntervalMonthDayNanoBatch, LargeBinaryBatch, LargeListBatch, LargeListViewBatch, LargeUtf8Batch, ListBatch, ListViewBatch, MapBatch, MapEntryBatch, NullBatch, RunEndEncodedBatch, SparseUnionBatch, StructBatch, StructProxyBatch, TimestampMicrosecondBatch, TimestampMillisecondBatch, TimestampNanosecondBatch, TimestampSecondBatch, Utf8Batch, Utf8ViewBatch } from './batch.js';\nimport { DateUnit, IntervalUnit, TimeUnit, Type } from './constants.js';\nimport { invalidDataType } from './data-types.js';\n\nexport function batchType(type, options = {}) {\n  const { typeId, bitWidth, precision, unit } = type;\n  const { useBigInt, useDate, useDecimalInt, useMap, useProxy } = options;\n\n  switch (typeId) {\n    case Type.Null: return NullBatch;\n    case Type.Bool: return BoolBatch;\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n      return useBigInt || bitWidth < 64 ? DirectBatch : Int64Batch;\n    case Type.Float:\n      return precision ? DirectBatch : Float16Batch;\n    case Type.Date:\n      return wrap(\n        unit === DateUnit.DAY ? DateDayBatch : DateDayMillisecondBatch,\n        useDate && DateBatch\n      );\n    case Type.Timestamp:\n      return wrap(\n        unit === TimeUnit.SECOND ? TimestampSecondBatch\n          : unit === TimeUnit.MILLISECOND ? TimestampMillisecondBatch\n          : unit === TimeUnit.MICROSECOND ? TimestampMicrosecondBatch\n          : TimestampNanosecondBatch,\n        useDate && DateBatch\n      );\n    case Type.Decimal:\n      return bitWidth === 32\n        ? (useDecimalInt ? DirectBatch : Decimal32NumberBatch)\n        : (useDecimalInt ? DecimalBigIntBatch : DecimalNumberBatch);\n    case Type.Interval:\n      return unit === IntervalUnit.DAY_TIME ? IntervalDayTimeBatch\n        : unit === IntervalUnit.YEAR_MONTH ? DirectBatch\n        : IntervalMonthDayNanoBatch;\n    case Type.FixedSizeBinary: return FixedBinaryBatch;\n    case Type.Utf8: return Utf8Batch;\n    case Type.LargeUtf8: return LargeUtf8Batch;\n    case Type.Binary: return BinaryBatch;\n    case Type.LargeBinary: return LargeBinaryBatch;\n    case Type.BinaryView: return BinaryViewBatch;\n    case Type.Utf8View: return Utf8ViewBatch;\n    case Type.List: return ListBatch;\n    case Type.LargeList: return LargeListBatch;\n    case Type.Map: return useMap ? MapBatch : MapEntryBatch;\n    case Type.ListView: return ListViewBatch;\n    case Type.LargeListView: return LargeListViewBatch;\n    case Type.FixedSizeList: return FixedListBatch;\n    case Type.Struct: return useProxy ? StructProxyBatch : StructBatch;\n    case Type.RunEndEncoded: return RunEndEncodedBatch;\n    case Type.Dictionary: return DictionaryBatch;\n    case Type.Union: return type.mode ? DenseUnionBatch : SparseUnionBatch;\n  }\n  throw new Error(invalidDataType(typeId));\n}\n\nfunction wrap(BaseClass, WrapperClass) {\n  return WrapperClass\n    ? class WrapBatch extends WrapperClass {\n        constructor(options) {\n          super(new BaseClass(options));\n        }\n      }\n    : BaseClass;\n}\n","import { readInt32, readInt64, readVector } from '../util/read.js';\n\n/**\n * Decode a block that points to messages within an Arrow 'file' format.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns The file block.\n */\nexport function decodeBlock(buf, index) {\n  //  0: offset\n  //  8: metadataLength\n  // 16: bodyLength\n  return {\n    offset: readInt64(buf, index),\n    metadataLength: readInt32(buf, index + 8),\n    bodyLength: readInt64(buf, index + 16)\n  }\n}\n\n/**\n * Decode a vector of blocks.\n * @param {Uint8Array} buf\n * @param {number} index\n * @returns An array of file blocks.\n */\nexport function decodeBlocks(buf, index) {\n  return readVector(buf, index, 24, decodeBlock);\n}\n","import { Version } from '../constants.js';\nimport { readInt64, readObject, readOffset, readVector } from '../util/read.js';\n\n/**\n * Decode a record batch.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @param {import('../types.js').Version_} version Arrow version value\n * @returns {import('../types.js').RecordBatch} The record batch\n */\nexport function decodeRecordBatch(buf, index, version) {\n  //  4: length\n  //  6: nodes\n  //  8: buffers\n  // 10: compression (not supported)\n  // 12: variadicBuffers (buffer counts for view-typed fields)\n  const get = readObject(buf, index);\n  if (get(10, readOffset, 0)) {\n    throw new Error('Record batch compression not implemented');\n  }\n\n  // If an Arrow buffer was written before version 4,\n  // advance 8 bytes to skip the now-removed page_id field\n  const offset = version < Version.V4 ? 8 : 0;\n\n  return {\n    length: get(4, readInt64, 0),\n    nodes: readVector(buf, get(6, readOffset), 16, (buf, pos) => ({\n      length: readInt64(buf, pos),\n      nullCount: readInt64(buf, pos + 8)\n    })),\n    regions: readVector(buf, get(8, readOffset), 16 + offset, (buf, pos) => ({\n      offset: readInt64(buf, pos + offset),\n      length: readInt64(buf, pos + offset + 8)\n    })),\n    variadic: readVector(buf, get(12, readOffset), 8, readInt64)\n  };\n}\n","import { readBoolean, readInt64, readObject } from '../util/read.js';\nimport { decodeRecordBatch } from './record-batch.js';\n\n/**\n * Decode a dictionary batch.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @param {import('../types.js').Version_} version Arrow version value\n * @returns {import('../types.js').DictionaryBatch} The dictionary batch\n */\nexport function decodeDictionaryBatch(buf, index, version) {\n  //  4: id\n  //  6: data\n  //  8: isDelta\n  const get = readObject(buf, index);\n  return {\n    id: get(4, readInt64, 0),\n    data: get(6, (buf, off) => decodeRecordBatch(buf, off, version)),\n    /**\n     * If isDelta is true the values in the dictionary are to be appended to a\n     * dictionary with the indicated id. If isDelta is false this dictionary\n     * should replace the existing dictionary.\n     */\n    isDelta: get(8, readBoolean, false)\n  };\n}\n","import { DateUnit, IntervalUnit, Precision, TimeUnit, Type, UnionMode } from '../constants.js';\nimport { binary, date, decimal, duration, fixedSizeBinary, fixedSizeList, float, int, interval, invalidDataType, largeBinary, largeList, largeListView, largeUtf8, list, listView, mapType, runEndEncoded, struct, time, timestamp, union, utf8 } from '../data-types.js';\nimport { checkOneOf } from '../util/objects.js';\nimport { readBoolean, readInt16, readInt32, readObject, readOffset, readString, readVector } from '../util/read.js';\n\n/**\n * Decode a data type definition for a field.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data.\n * @param {number} index The starting index in the byte buffer.\n * @param {number} typeId The data type id.\n * @param {import('../types.js').Field[]} [children] A list of parsed child fields.\n * @returns {import('../types.js').DataType} The data type.\n */\nexport function decodeDataType(buf, index, typeId, children) {\n  checkOneOf(typeId, Type, invalidDataType);\n  const get = readObject(buf, index);\n\n  switch (typeId) {\n    // types without flatbuffer objects\n    case Type.Binary: return binary();\n    case Type.Utf8: return utf8();\n    case Type.LargeBinary: return largeBinary();\n    case Type.LargeUtf8: return largeUtf8();\n    case Type.List: return list(children[0]);\n    case Type.ListView: return listView(children[0]);\n    case Type.LargeList: return largeList(children[0]);\n    case Type.LargeListView: return largeListView(children[0]);\n    case Type.Struct: return struct(children);\n    case Type.RunEndEncoded: return runEndEncoded(children[0], children[1]);\n\n    // types with flatbuffer objects\n    case Type.Int: return int(\n      // @ts-ignore\n      get(4, readInt32, 0), // bitwidth\n      get(6, readBoolean, false) // signed\n    );\n    case Type.Float: return float(\n      // @ts-ignore\n      get(4, readInt16, Precision.HALF) // precision\n    );\n    case Type.Decimal: return decimal(\n      get(4, readInt32, 0), // precision\n      get(6, readInt32, 0), // scale\n      // @ts-ignore\n      get(8, readInt32, 128) // bitwidth\n    );\n    case Type.Date: return date(\n      // @ts-ignore\n      get(4, readInt16, DateUnit.MILLISECOND) // unit\n    );\n    case Type.Time: return time(\n      // @ts-ignore\n      get(4, readInt16, TimeUnit.MILLISECOND), // unit\n      get(6, readInt32, 32) // bitWidth\n    );\n    case Type.Timestamp: return timestamp(\n      // @ts-ignore\n      get(4, readInt16, TimeUnit.SECOND), // unit\n      get(6, readString) // timezone\n    );\n    case Type.Interval: return interval(\n      // @ts-ignore\n      get(4, readInt16, IntervalUnit.YEAR_MONTH) // unit\n    );\n    case Type.Duration: return duration(\n      // @ts-ignore\n      get(4, readInt16, TimeUnit.MILLISECOND) // unit\n    );\n\n    case Type.FixedSizeBinary: return fixedSizeBinary(\n      get(4, readInt32, 0) // stride\n    );\n    case Type.FixedSizeList: return fixedSizeList(\n      children[0],\n      get(4, readInt32, 0), // stride\n    );\n    case Type.Map: return mapType(\n      get(4, readBoolean, false), // keysSorted\n      children[0]\n    );\n\n    case Type.Union: return union(\n      // @ts-ignore\n      get(4, readInt16, UnionMode.Sparse), // mode\n      children,\n      readVector(buf, get(6, readOffset), 4, readInt32) // type ids\n    );\n  }\n  // case Type.NONE:\n  // case Type.Null:\n  // case Type.Bool:\n  // case Type.BinaryView:\n  // case Type.Utf8View:\n  // @ts-ignore\n  return { typeId };\n}\n","import { readObject, readString, readVector } from '../util/read.js';\n\n/**\n * Decode custom metadata consisting of key-value string pairs.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns {import('../types.js').Metadata | null} The custom metadata map\n */\nexport function decodeMetadata(buf, index) {\n  const entries = readVector(buf, index, 4, (buf, pos) => {\n    const get = readObject(buf, pos);\n    return /** @type {[string, string]} */ ([\n      get(4, readString), // 4: key (string)\n      get(6, readString)  // 6: key (string)\n    ]);\n  });\n  return entries.length ? new Map(entries) : null;\n}\n","import { Type } from '../constants.js';\nimport { dictionary, int32 } from '../data-types.js';\nimport { readBoolean, readInt16, readInt64, readObject, readOffset, readString, readUint8, readVector } from '../util/read.js';\nimport { decodeDataType } from './data-type.js';\nimport { decodeMetadata } from './metadata.js';\n\n/**\n * Decode a table schema describing the fields and their data types.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @param {import('../types.js').Version_} version Arrow version value\n * @returns {import('../types.js').Schema} The schema\n */\nexport function decodeSchema(buf, index, version) {\n  //  4: endianness (int16)\n  //  6: fields (vector)\n  //  8: metadata (vector)\n  // 10: features (int64[])\n  const get = readObject(buf, index);\n  return {\n    version,\n    endianness: /** @type {import('../types.js').Endianness_} */ (get(4, readInt16, 0)),\n    fields: get(6, decodeSchemaFields, []),\n    metadata: get(8, decodeMetadata)\n  };\n}\n\n/**\n * @returns {import('../types.js').Field[] | null}\n */\nfunction decodeSchemaFields(buf, fieldsOffset) {\n  return readVector(buf, fieldsOffset, 4, decodeField);\n}\n\n/**\n * @returns {import('../types.js').Field}\n */\nfunction decodeField(buf, index) {\n  //  4: name (string)\n  //  6: nullable (bool)\n  //  8: type id (uint8)\n  // 10: type (union)\n  // 12: dictionary (table)\n  // 14: children (vector)\n  // 16: metadata (vector)\n  const get = readObject(buf, index);\n  const typeId = get(8, readUint8, Type.NONE);\n  const typeOffset = get(10, readOffset, 0);\n  const dict = get(12, decodeDictionary);\n  const children = get(14, (buf, off) => decodeFieldChildren(buf, off));\n\n  let type = decodeDataType(buf, typeOffset, typeId, children);\n  if (dict) {\n    dict.dictionary = type;\n    type = dict;\n  }\n\n  return {\n    name: get(4, readString),\n    type,\n    nullable: get(6, readBoolean, false),\n    metadata: get(16, decodeMetadata)\n  };\n}\n\n/**\n * @returns {import('../types.js').Field[] | null}\n */\nfunction decodeFieldChildren(buf, fieldOffset) {\n  const children = readVector(buf, fieldOffset, 4, decodeField);\n  return children.length ? children : null;\n}\n\n/**\n * @param {Uint8Array} buf\n * @param {number} index\n * @returns {import('../types.js').DictionaryType}\n */\nfunction decodeDictionary(buf, index) {\n  if (!index) return null;\n  //  4: id (int64)\n  //  6: indexType (Int type)\n  //  8: isOrdered (boolean)\n  // 10: kind (int16) currently only dense array is supported\n  const get = readObject(buf, index);\n  return dictionary(\n    null, // data type will be populated by caller\n    get(6, decodeInt, int32()), // index type\n    get(8, readBoolean, false), // ordered\n    get(4, readInt64, 0), // id\n  );\n}\n\n/**\n * Decode an integer data type.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data.\n * @param {number} index The starting index in the byte buffer.\n * @returns {import('../types.js').IntType}\n */\nfunction decodeInt(buf, index) {\n  return /** @type {import('../types.js').IntType} */ (\n    decodeDataType(buf, index, Type.Int)\n  );\n}\n","import { MessageHeader, Version } from '../constants.js';\nimport { keyFor } from '../util/objects.js';\nimport { SIZEOF_INT, readInt16, readInt32, readInt64, readObject, readOffset, readUint8 } from '../util/read.js';\nimport { decodeDictionaryBatch } from './dictionary-batch.js';\nimport { decodeRecordBatch } from './record-batch.js';\nimport { decodeSchema } from './schema.js';\n\nconst invalidMessageMetadata = (expected, actual) =>\n  `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\n\nconst invalidMessageBodyLength = (expected, actual) =>\n  `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\n\nconst invalidMessageType = (type) =>\n  `Unsupported message type: ${type} (${keyFor(MessageHeader, type)})`;\n\n/**\n * A \"message\" contains a block of Apache Arrow data, such as a schema,\n * record batch, or dictionary batch. This message decodes a single\n * message, returning its associated metadata and content.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns {import('../types.js').Message} The decoded message.\n */\nexport function decodeMessage(buf, index) {\n  // get message start\n  let metadataLength = readInt32(buf, index) || 0;\n  index += SIZEOF_INT;\n\n  // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n  // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n  // pre-v0.15 message, where the first 4 bytes are the metadata length.\n  if (metadataLength === -1) {\n    metadataLength = readInt32(buf, index) || 0;\n    index += SIZEOF_INT;\n  }\n  if (metadataLength === 0) return null;\n\n  const head = buf.subarray(index, index += metadataLength);\n  if (head.byteLength < metadataLength) {\n    throw new Error(invalidMessageMetadata(metadataLength, head.byteLength));\n  }\n\n  // decode message metadata\n  //  4: version\n  //  6: headerType\n  //  8: headerIndex\n  // 10: bodyLength\n  const get = readObject(head, 0);\n  const version = /** @type {import('../types.js').Version_} */\n    (get(4, readInt16, Version.V1));\n  const type = /** @type {import('../types.js').MessageHeader_} */\n    (get(6, readUint8, MessageHeader.NONE));\n  const offset = get(8, readOffset, 0);\n  const bodyLength = get(10, readInt64, 0);\n  let content;\n\n  if (offset) {\n    // decode message header\n    const decoder = type === MessageHeader.Schema ? decodeSchema\n      : type === MessageHeader.DictionaryBatch ? decodeDictionaryBatch\n      : type === MessageHeader.RecordBatch ? decodeRecordBatch\n      : null;\n    if (!decoder) throw new Error(invalidMessageType(type));\n    content = decoder(head, offset, version);\n\n    // extract message body\n    if (bodyLength > 0) {\n      const body = buf.subarray(index, index += bodyLength);\n      if (body.byteLength < bodyLength) {\n        throw new Error(invalidMessageBodyLength(bodyLength, body.byteLength));\n      }\n      // @ts-ignore\n      content.body = body;\n    }\n  }\n\n  return { version, type, index, content };\n}\n","import { MAGIC, MessageHeader, Version } from '../constants.js';\nimport { readInt16, readInt32, readObject } from '../util/read.js';\nimport { decodeBlocks } from './block.js';\nimport { decodeMessage } from './message.js';\nimport { decodeMetadata } from './metadata.js';\nimport { decodeSchema } from './schema.js';\n\n/**\n * Decode [Apache Arrow IPC data][1] and return parsed schema, record batch,\n * and dictionary batch definitions. The input binary data may be either\n * an `ArrayBuffer` or `Uint8Array`. For Arrow data in the IPC 'stream' format,\n * an array of `Uint8Array` instances is also supported.\n *\n * This method stops short of generating views over field buffers. Use the\n * `createData()` method on the result to enable column data access.\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#serialization-and-interprocess-communication-ipc\n * @param {ArrayBuffer | Uint8Array | Uint8Array[]} data\n *  The source byte buffer, or an array of buffers. If an array, each byte\n *  array may contain one or more self-contained messages. Messages may NOT\n *  span multiple byte arrays.\n * @returns {import('../types.js').ArrowData}\n */\nexport function decodeIPC(data) {\n  const source = data instanceof ArrayBuffer\n    ? new Uint8Array(data)\n    : data;\n  return source instanceof Uint8Array && isArrowFileFormat(source)\n    ? decodeIPCFile(source)\n    : decodeIPCStream(source);\n}\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isArrowFileFormat(buf) {\n  if (!buf || buf.length < 4) return false;\n  for (let i = 0; i < 6; ++i) {\n    if (MAGIC[i] !== buf[i]) return false;\n  }\n  return true;\n}\n\n/**\n * Decode data in the [Arrow IPC 'stream' format][1].\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format\n * @param {Uint8Array | Uint8Array[]} data The source byte buffer, or an\n *  array of buffers. If an array, each byte array may contain one or more\n *  self-contained messages. Messages may NOT span multiple byte arrays.\n * @returns {import('../types.js').ArrowData}\n */\nexport function decodeIPCStream(data) {\n  const stream = [data].flat();\n\n  let schema;\n  const records = [];\n  const dictionaries = [];\n\n  // consume each message in the stream\n  for (const buf of stream) {\n    if (!(buf instanceof Uint8Array)) {\n      throw new Error(`IPC data batch was not a Uint8Array.`);\n    }\n    let offset = 0;\n\n    // decode all messages in current buffer\n    while (true) {\n      const m = decodeMessage(buf, offset);\n      if (m === null) break; // end of messages\n      offset = m.index;\n      if (!m.content) continue;\n      switch (m.type) {\n        case MessageHeader.Schema:\n          // ignore repeated schema messages\n          if (!schema) schema = m.content;\n          break;\n        case MessageHeader.RecordBatch:\n          records.push(m.content);\n          break;\n        case MessageHeader.DictionaryBatch:\n          dictionaries.push(m.content);\n          break;\n      }\n    }\n  }\n\n  return /** @type {import('../types.js').ArrowData} */ (\n    { schema, dictionaries, records, metadata: null }\n  );\n}\n\n/**\n * Decode data in the [Arrow IPC 'file' format][1].\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#ipc-file-format\n * @param {Uint8Array} data The source byte buffer.\n * @returns {import('../types.js').ArrowData}\n */\nexport function decodeIPCFile(data) {\n  // find footer location\n  const offset = data.byteLength - (MAGIC.length + 4);\n  const length = readInt32(data, offset);\n\n  // decode file footer\n  //  4: version\n  //  6: schema\n  //  8: dictionaries (vector)\n  // 10: batches (vector)\n  // 12: metadata\n  const get = readObject(data, offset - length);\n  const version = /** @type {import('../types.js').Version_} */\n    (get(4, readInt16, Version.V1));\n  const dicts = get(8, decodeBlocks, []);\n  const recs = get(10, decodeBlocks, []);\n\n  return /** @type {import('../types.js').ArrowData} */ ({\n    schema: get(6, (buf, index) => decodeSchema(buf, index, version)),\n    dictionaries: dicts.map(({ offset }) => decodeMessage(data, offset).content),\n    records: recs.map(({ offset }) => decodeMessage(data, offset).content),\n    metadata: get(12, decodeMetadata)\n  });\n}\n","import { batchType } from '../batch-type.js';\nimport { columnBuilder } from '../column.js';\nimport { Type, UnionMode, Version } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { Table } from '../table.js';\nimport { int8Array } from '../util/arrays.js';\nimport { decodeIPC } from './decode-ipc.js';\n\n/**\n * Decode [Apache Arrow IPC data][1] and return a new Table. The input binary\n * data may be either an `ArrayBuffer` or `Uint8Array`. For Arrow data in the\n * [IPC 'stream' format][2], an array of `Uint8Array` values is also supported.\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#serialization-and-interprocess-communication-ipc\n * [2]: https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format\n * @param {ArrayBuffer | Uint8Array | Uint8Array[]} data\n *  The source byte buffer, or an array of buffers. If an array, each byte\n *  array may contain one or more self-contained messages. Messages may NOT\n *  span multiple byte arrays.\n * @param {import('../types.js').ExtractionOptions} [options]\n *  Options for controlling how values are transformed when extracted\n *  from an Arrow binary representation.\n * @returns {Table} A Table instance.\n */\nexport function tableFromIPC(data, options) {\n  return createTable(decodeIPC(data), options);\n}\n\n/**\n * Create a table from parsed IPC data.\n * @param {import('../types.js').ArrowData} data\n *  The IPC data, as returned by parseIPC.\n * @param {import('../types.js').ExtractionOptions} [options]\n *  Options for controlling how values are transformed when extracted\n *  from am Arrow binary representation.\n * @returns {Table} A Table instance.\n */\nexport function createTable(data, options = {}) {\n  const { schema = { fields: [] }, dictionaries, records } = data;\n  const { version, fields } = schema;\n  const dictionaryMap = new Map;\n  const context = contextGenerator(options, version, dictionaryMap);\n\n  // build dictionary type map\n  const dictionaryTypes = new Map;\n  visitSchemaFields(schema, field => {\n    const type = field.type;\n    if (type.typeId === Type.Dictionary) {\n      dictionaryTypes.set(type.id, type.dictionary);\n    }\n  });\n\n  // decode dictionaries, build dictionary column map\n  const dicts = new Map;\n  for (const dict of dictionaries) {\n    const { id, data, isDelta, body } = dict;\n    const type = dictionaryTypes.get(id);\n    const batch = visit(type, context({ ...data, body }));\n    if (!dicts.has(id)) {\n      if (isDelta) {\n        throw new Error('Delta update can not be first dictionary batch.');\n      }\n      dicts.set(id, columnBuilder(type).add(batch));\n    } else {\n      const dict = dicts.get(id);\n      if (!isDelta) dict.clear();\n      dict.add(batch);\n    }\n  }\n  dicts.forEach((value, key) => dictionaryMap.set(key, value.done()));\n\n  // decode column fields\n  const cols = fields.map(f => columnBuilder(f.type));\n  for (const batch of records) {\n    const ctx = context(batch);\n    fields.forEach((f, i) => cols[i].add(visit(f.type, ctx)));\n  }\n\n  return new Table(schema, cols.map(c => c.done()), options.useProxy);\n}\n\n/**\n * Visit all fields within a schema.\n * @param {import('../types.js').Schema} schema\n * @param {(field: import('../types.js').Field) => void} visitor\n */\nfunction visitSchemaFields(schema, visitor) {\n  schema.fields.forEach(function visitField(field) {\n    visitor(field);\n    // @ts-ignore\n    field.type.dictionary?.children?.forEach(visitField);\n    // @ts-ignore\n    field.type.children?.forEach(visitField);\n  });\n}\n\n/**\n * Context object generator for field visitation and buffer definition.\n */\nfunction contextGenerator(options, version, dictionaryMap) {\n  const base = {\n    version,\n    options,\n    dictionary: id => dictionaryMap.get(id),\n  };\n\n  /**\n   * Return a context generator.\n   * @param {import('../types.js').RecordBatch} batch\n   */\n  return batch => {\n    const { length, nodes, regions, variadic, body } = batch;\n    let nodeIndex = -1;\n    let bufferIndex = -1;\n    let variadicIndex = -1;\n    return {\n      ...base,\n      length,\n      node: () => nodes[++nodeIndex],\n      buffer: (ArrayType) => {\n        const { length, offset } = regions[++bufferIndex];\n        return ArrayType\n          ? new ArrayType(body.buffer, body.byteOffset + offset, length / ArrayType.BYTES_PER_ELEMENT)\n          : body.subarray(offset, offset + length)\n      },\n      variadic: () => variadic[++variadicIndex],\n      visit(children) { return children.map(f => visit(f.type, this)); }\n    };\n  };\n}\n\n/**\n * Visit a field, instantiating views of buffer regions.\n */\nfunction visit(type, ctx) {\n  const { typeId } = type;\n  const { length, options, node, buffer, variadic, version } = ctx;\n  const BatchType = batchType(type, options);\n\n  if (typeId === Type.Null) {\n    // no field node, no buffers\n    return new BatchType({ length, nullCount: length, type });\n  }\n\n  // extract the next { length, nullCount } field node\n  const base = { ...node(), type };\n\n  switch (typeId) {\n    // validity and data value buffers\n    case Type.Bool:\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n    case Type.Float:\n    case Type.Decimal:\n    case Type.Date:\n    case Type.Timestamp:\n    case Type.Interval:\n    case Type.FixedSizeBinary:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        values: buffer(type.values)\n      });\n\n    // validity, offset, and value buffers\n    case Type.Utf8:\n    case Type.LargeUtf8:\n    case Type.Binary:\n    case Type.LargeBinary:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        offsets: buffer(type.offsets),\n        values: buffer()\n      });\n\n    // views with variadic buffers\n    case Type.BinaryView:\n    case Type.Utf8View:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        values: buffer(), // views buffer\n        data: Array.from({ length: variadic() }, () => buffer()) // data buffers\n      });\n\n    // validity, offset, and list child\n    case Type.List:\n    case Type.LargeList:\n    case Type.Map:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        offsets: buffer(type.offsets),\n        children: ctx.visit(type.children)\n      });\n\n    // validity, offset, size, and list child\n    case Type.ListView:\n    case Type.LargeListView:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        offsets: buffer(type.offsets),\n        sizes: buffer(type.offsets),\n        children: ctx.visit(type.children)\n      });\n\n    // validity and children\n    case Type.FixedSizeList:\n    case Type.Struct:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        children: ctx.visit(type.children)\n      });\n\n    // children only\n    case Type.RunEndEncoded:\n      return new BatchType({\n        ...base,\n        children: ctx.visit(type.children)\n      });\n\n    // dictionary\n    case Type.Dictionary: {\n      const { id, indices } = type;\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        values: buffer(indices.values),\n      }).setDictionary(ctx.dictionary(id));\n    }\n\n    // union\n    case Type.Union: {\n      if (version < Version.V5) {\n        buffer(); // skip unused null bitmap\n      }\n      return new BatchType({\n        ...base,\n        typeIds: buffer(int8Array),\n        offsets: type.mode === UnionMode.Sparse ? null : buffer(type.offsets),\n        children: ctx.visit(type.children)\n      });\n    }\n\n    // unsupported type\n    default:\n      throw new Error(invalidDataType(typeId));\n  }\n}\n","import { grow } from '../util/arrays.js';\nimport { SIZEOF_INT, SIZEOF_SHORT, readInt16 } from '../util/read.js';\nimport { encodeUtf8 } from '../util/strings.js';\n\nexport function writeInt32(buf, index, value) {\n  buf[index] = value;\n  buf[index + 1] = value >> 8;\n  buf[index + 2] = value >> 16;\n  buf[index + 3] = value >> 24;\n}\n\nconst INIT_SIZE = 1024;\n\n/** Flatbuffer binary builder. */\nexport class Builder {\n  /**\n   * Create a new builder instance.\n   * @param {import('./sink.js').Sink} sink The byte consumer.\n   */\n  constructor(sink) {\n    /**\n     * Sink that consumes built byte buffers;\n     * @type {import('./sink.js').Sink}\n     */\n    this.sink = sink;\n    /**\n     * Minimum alignment encountered so far.\n     * @type {number}\n     */\n    this.minalign = 1;\n    /**\n     * Current byte buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = new Uint8Array(INIT_SIZE);\n    /**\n     * Remaining space in the current buffer.\n     * @type {number}\n     */\n    this.space = INIT_SIZE;\n    /**\n     * List of offsets of all vtables. Used to find and\n     * reuse tables upon duplicated table field schemas.\n     * @type {number[]}\n     */\n    this.vtables = [];\n    /**\n     * Total bytes written to sink thus far.\n     */\n    this.outputBytes = 0;\n  }\n\n  /**\n   * Returns the flatbuffer offset, relative to the end of the current buffer.\n   * @returns {number} Offset relative to the end of the buffer.\n   */\n  offset() {\n    return this.buf.length - this.space;\n  }\n\n  /**\n   * Write a flatbuffer int8 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt8(value) {\n    this.buf[this.space -= 1] = value;\n  }\n\n  /**\n   * Write a flatbuffer int16 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt16(value) {\n    this.buf[this.space -= 2] = value;\n    this.buf[this.space + 1] = value >> 8;\n  }\n\n  /**\n   * Write a flatbuffer int32 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt32(value) {\n    writeInt32(this.buf, this.space -= 4, value);\n  }\n\n  /**\n   * Write a flatbuffer int64 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt64(value) {\n    const v = BigInt(value);\n    this.writeInt32(Number(BigInt.asIntN(32, v >> BigInt(32))));\n    this.writeInt32(Number(BigInt.asIntN(32, v)));\n  }\n\n  /**\n   * Add a flatbuffer int8 value, properly aligned,\n   * @param value The int8 value to add the buffer.\n   */\n  addInt8(value) {\n    prep(this, 1, 0);\n    this.writeInt8(value);\n  }\n\n  /**\n   * Add a flatbuffer int16 value, properly aligned,\n   * @param value The int16 value to add the buffer.\n   */\n  addInt16(value) {\n    prep(this, 2, 0);\n    this.writeInt16(value);\n  }\n\n  /**\n   * Add a flatbuffer int32 value, properly aligned,\n   * @param value The int32 value to add the buffer.\n   */\n  addInt32(value) {\n    prep(this, 4, 0);\n    this.writeInt32(value);\n  }\n\n  /**\n   * Add a flatbuffer int64 values, properly aligned.\n   * @param value The int64 value to add the buffer.\n   */\n  addInt64(value) {\n    prep(this, 8, 0);\n    this.writeInt64(value);\n  }\n\n  /**\n   * Add a flatbuffer offset, relative to where it will be written.\n   * @param {number} offset The offset to add.\n   */\n  addOffset(offset) {\n    prep(this, SIZEOF_INT, 0); // Ensure alignment is already done.\n    this.writeInt32(this.offset() - offset + SIZEOF_INT);\n  }\n\n  /**\n   * Add a flatbuffer object (vtable).\n   * @param {number} numFields The maximum number of fields\n   *  this object may include.\n   * @param {(tableBuilder: ReturnType<objectBuilder>) => void} [addFields]\n   *  A callback function that writes all fields using an object builder.\n   * @returns {number} The object offset.\n   */\n  addObject(numFields, addFields) {\n    const b = objectBuilder(this, numFields);\n    addFields?.(b);\n    return b.finish();\n  }\n\n  /**\n   * Add a flatbuffer vector (list).\n   * @template T\n   * @param {T[]} items An array of items to write.\n   * @param {number} itemSize The size in bytes of a serialized item.\n   * @param {number} alignment The desired byte alignment value.\n   * @param {(builder: this, item: T) => void} writeItem A callback\n   *  function that writes a vector item to this builder.\n   * @returns {number} The vector offset.\n   */\n  addVector(items, itemSize, alignment, writeItem) {\n    const n = items?.length;\n    if (!n) return 0;\n    prep(this, SIZEOF_INT, itemSize * n);\n    prep(this, alignment, itemSize * n); // Just in case alignment > int.\n    for (let i = n; --i >= 0;) {\n      writeItem(this, items[i]);\n    }\n    this.writeInt32(n);\n    return this.offset();\n  }\n\n  /**\n   * Convenience method for writing a vector of byte buffer offsets.\n   * @param {number[]} offsets\n   * @returns {number} The vector offset.\n   */\n  addOffsetVector(offsets) {\n    return this.addVector(offsets, 4, 4, (b, off) => b.addOffset(off));\n  }\n\n  /**\n   * Add a flatbuffer UTF-8 string.\n   * @param {string} s The string to encode.\n   * @return {number} The string offset.\n   */\n  addString(s) {\n    if (s == null) return 0;\n    const utf8 = encodeUtf8(s);\n    const n = utf8.length;\n    this.addInt8(0); // string null terminator\n    prep(this, SIZEOF_INT, n);\n    this.buf.set(utf8, this.space -= n);\n    this.writeInt32(n);\n    return this.offset();\n  }\n\n  /**\n   * Finish the current flatbuffer by adding a root offset.\n   * @param {number} rootOffset The root offset.\n   */\n  finish(rootOffset) {\n    prep(this, this.minalign, SIZEOF_INT);\n    this.addOffset(rootOffset);\n  }\n\n  /**\n   * Flush the current flatbuffer byte buffer content to the sink,\n   * and reset the flatbuffer builder state.\n   */\n  flush() {\n    const { buf, sink } = this;\n    const bytes = buf.subarray(this.space, buf.length);\n    sink.write(bytes);\n    this.outputBytes += bytes.byteLength;\n    this.minalign = 1;\n    this.vtables = [];\n    this.buf = new Uint8Array(INIT_SIZE);\n    this.space = INIT_SIZE;\n  }\n\n  /**\n   * Add a byte buffer directly to the builder sink. This method bypasses\n   * any unflushed flatbuffer state and leaves it unchanged, writing the\n   * buffer to the sink *before* the flatbuffer.\n   * The buffer will be padded for 64-bit (8-byte) alignment as needed.\n   * @param {Uint8Array} buffer The buffer to add.\n   * @returns {number} The total byte count of the buffer and padding.\n   */\n  addBuffer(buffer) {\n    const size = buffer.byteLength;\n    if (!size) return 0;\n    this.sink.write(buffer);\n    this.outputBytes += size;\n    const pad = ((size + 7) & ~7) - size;\n    this.addPadding(pad);\n    return size + pad;\n  }\n\n  /**\n   * Write padding bytes directly to the builder sink. This method bypasses\n   * any unflushed flatbuffer state and leaves it unchanged, writing the\n   * padding bytes to the sink *before* the flatbuffer.\n   * @param {number} byteCount The number of padding bytes.\n   */\n  addPadding(byteCount) {\n    if (byteCount > 0) {\n      this.sink.write(new Uint8Array(byteCount));\n      this.outputBytes += byteCount;\n    }\n  }\n}\n\n/**\n * Prepare to write an element of `size` after `additionalBytes` have been\n * written, e.g. if we write a string, we need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * we need to do is alignment, `additionalBytes` will be 0.\n * @param {Builder} builder The builder to prep.\n * @param {number} size The size of the new element to write.\n * @param {number} additionalBytes Additional padding size.\n */\nexport function prep(builder, size, additionalBytes) {\n  let { buf, space, minalign } = builder;\n\n  // track the biggest thing we've ever aligned to\n  if (size > minalign) {\n    builder.minalign = size;\n  }\n\n  // find alignment needed so that `size` aligns after `additionalBytes`\n  const bufSize = buf.length;\n  const used = bufSize - space + additionalBytes;\n  const alignSize = (~used + 1) & (size - 1);\n\n  // reallocate the buffer if needed\n  buf = grow(buf, used + alignSize + size - 1, true);\n  space += buf.length - bufSize;\n\n  // add padding\n  for (let i = 0; i < alignSize; ++i) {\n    buf[--space] = 0;\n  }\n\n  // update builder state\n  builder.buf = buf;\n  builder.space = space;\n}\n\n/**\n * Returns a builder object for flatbuffer objects (vtables).\n * @param {Builder} builder The underlying flatbuffer builder.\n * @param {number} numFields The expected number of fields, not\n *  including the standard size fields.\n */\nfunction objectBuilder(builder, numFields) {\n  /** @type {number[]} */\n  const vtable = Array(numFields).fill(0);\n  const startOffset = builder.offset();\n\n  function slot(index) {\n    vtable[index] = builder.offset();\n  }\n\n  return {\n    /**\n     * Add an int8-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt8(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt8(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add an int16-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt16(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt16(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add an int32-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt32(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt32(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add an int64-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt64(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt64(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add a buffer offset-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addOffset(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addOffset(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Write the vtable to the buffer and return the table offset.\n     * @returns {number} The buffer offset to the vtable.\n     */\n    finish() {\n      // add offset entry, will overwrite later with actual offset\n      builder.addInt32(0);\n      const vtableOffset = builder.offset();\n\n      // trim zero-valued fields (indicating default value)\n      let i = numFields;\n      while (--i >= 0 && vtable[i] === 0) {} // eslint-disable-line no-empty\n      const size = i + 1;\n\n      // Write out the current vtable.\n      for (; i >= 0; --i) {\n        // Offset relative to the start of the table.\n        builder.addInt16(vtable[i] ? (vtableOffset - vtable[i]) : 0);\n      }\n\n      const standardFields = 2; // size fields\n      builder.addInt16(vtableOffset - startOffset);\n      const len = (size + standardFields) * SIZEOF_SHORT;\n      builder.addInt16(len);\n\n      // Search for an existing vtable that matches the current one.\n      let existingTable = 0;\n      const { buf, vtables, space: vt1 } = builder;\n    outer_loop:\n      for (i = 0; i < vtables.length; ++i) {\n        const vt2 = buf.length - vtables[i];\n        if (len == readInt16(buf, vt2)) {\n          for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n            if (readInt16(buf, vt1 + j) != readInt16(buf, vt2 + j)) {\n              continue outer_loop;\n            }\n          }\n          existingTable = vtables[i];\n          break;\n        }\n      }\n\n      if (existingTable) {\n        // Found a match: remove the current vtable.\n        // Point table to existing vtable.\n        builder.space = buf.length - vtableOffset;\n        writeInt32(buf, builder.space, existingTable - vtableOffset);\n      } else {\n        // No match: add the location of the current vtable to the vtables list.\n        // Point table to current vtable.\n        const off = builder.offset();\n        vtables.push(off);\n        writeInt32(buf, buf.length - vtableOffset, off - vtableOffset);\n      }\n\n      return vtableOffset;\n    }\n  }\n}\n","/**\n * @param {import('./builder.js').Builder} builder\n * @param {import('../types.js').RecordBatch} batch\n * @returns {number}\n */\nexport function encodeRecordBatch(builder, batch) {\n  const { nodes, regions, variadic } = batch;\n  const nodeVector = builder.addVector(nodes, 16, 8,\n    (builder, node) => {\n      builder.writeInt64(node.nullCount);\n      builder.writeInt64(node.length);\n      return builder.offset();\n    }\n  );\n  const regionVector = builder.addVector(regions, 16, 8,\n    (builder, region) => {\n      builder.writeInt64(region.length);\n      builder.writeInt64(region.offset);\n      return builder.offset();\n    }\n  );\n  const variadicVector = builder.addVector(variadic, 8, 8,\n    (builder, count) => builder.addInt64(count)\n  );\n  return builder.addObject(5, b => {\n    b.addInt64(0, nodes[0].length, 0);\n    b.addOffset(1, nodeVector, 0);\n    b.addOffset(2, regionVector, 0);\n    // NOT SUPPORTED: 3, compression offset\n    b.addOffset(4, variadicVector, 0);\n  });\n}\n","import { encodeRecordBatch } from './record-batch.js';\n\n/**\n * @param {import('./builder.js').Builder} builder\n * @param {import('../types.js').DictionaryBatch} dictionaryBatch\n * @returns {number}\n */\nexport function encodeDictionaryBatch(builder, dictionaryBatch) {\n  const dataOffset = encodeRecordBatch(builder, dictionaryBatch.data);\n  return builder.addObject(3, b => {\n    b.addInt64(0, dictionaryBatch.id, 0);\n    b.addOffset(1, dataOffset, 0);\n    b.addInt8(2, +dictionaryBatch.isDelta, 0);\n  });\n}\n","/**\n * @param {import('./builder.js').Builder} builder\n * @param {Map<string, string>} metadata\n * @returns {number}\n */\nexport function encodeMetadata(builder, metadata) {\n  return metadata?.size > 0\n     ? builder.addOffsetVector(Array.from(metadata, ([k, v]) => {\n        const key = builder.addString(`${k}`);\n        const val = builder.addString(`${v}`);\n        return builder.addObject(2, b => {\n          b.addOffset(0, key, 0);\n          b.addOffset(1, val, 0);\n        });\n      }))\n    : 0;\n}\n","import { DateUnit, IntervalUnit, Precision, TimeUnit, Type, UnionMode } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { checkOneOf } from '../util/objects.js';\n\n/**\n * Encode a data type into a flatbuffer.\n * @param {import('./builder.js').Builder} builder\n * @param {import('../types.js').DataType} type\n * @returns {number} The offset at which the data type is written.\n */\nexport function encodeDataType(builder, type) {\n  const typeId = checkOneOf(type.typeId, Type, invalidDataType);\n\n  switch (typeId) {\n    case Type.Dictionary:\n      return encodeDictionary(builder, type);\n    case Type.Int:\n      return encodeInt(builder, type);\n    case Type.Float:\n      return encodeFloat(builder, type);\n    case Type.Decimal:\n      return encodeDecimal(builder, type);\n    case Type.Date:\n      return encodeDate(builder, type);\n    case Type.Time:\n      return encodeTime(builder, type);\n    case Type.Timestamp:\n      return encodeTimestamp(builder, type);\n    case Type.Interval:\n      return encodeInterval(builder, type);\n    case Type.Duration:\n      return encodeDuration(builder, type);\n    case Type.FixedSizeBinary:\n    case Type.FixedSizeList:\n      return encodeFixedSize(builder, type);\n    case Type.Map:\n      return encodeMap(builder, type);\n    case Type.Union:\n      return encodeUnion(builder, type);\n  }\n  // case Type.Null:\n  // case Type.Binary:\n  // case Type.LargeBinary:\n  // case Type.BinaryView:\n  // case Type.Bool:\n  // case Type.Utf8:\n  // case Type.Utf8View:\n  // case Type.LargeUtf8:\n  // case Type.List:\n  // case Type.ListView:\n  // case Type.LargeList:\n  // case Type.LargeListView:\n  // case Type.RunEndEncoded:\n  // case Type.Struct:\n  return builder.addObject(0);\n}\n\nfunction encodeDate(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.unit, DateUnit.MILLISECOND);\n  });\n}\n\nfunction encodeDecimal(builder, type) {\n  return builder.addObject(3, b => {\n    b.addInt32(0, type.precision, 0);\n    b.addInt32(1, type.scale, 0);\n    b.addInt32(2, type.bitWidth, 128);\n  });\n}\n\nfunction encodeDuration(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.unit, TimeUnit.MILLISECOND);\n  });\n}\n\nfunction encodeFixedSize(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt32(0, type.stride, 0);\n  });\n}\n\nfunction encodeFloat(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.precision, Precision.HALF);\n  });\n}\n\nfunction encodeInt(builder, type) {\n  return builder.addObject(2, b => {\n    b.addInt32(0, type.bitWidth, 0);\n    b.addInt8(1, +type.signed, 0);\n  });\n}\n\nfunction encodeInterval(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.unit, IntervalUnit.YEAR_MONTH);\n  });\n}\n\nfunction encodeMap(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt8(0, +type.keysSorted, 0);\n  });\n}\n\nfunction encodeTime(builder, type) {\n  return builder.addObject(2, b => {\n    b.addInt16(0, type.unit, TimeUnit.MILLISECOND);\n    b.addInt32(1, type.bitWidth, 32);\n  });\n}\n\nfunction encodeTimestamp(builder, type) {\n  const timezoneOffset = builder.addString(type.timezone);\n  return builder.addObject(2, b => {\n    b.addInt16(0, type.unit, TimeUnit.SECOND);\n    b.addOffset(1, timezoneOffset, 0);\n  });\n}\n\nfunction encodeUnion(builder, type) {\n  const typeIdsOffset = builder.addVector(\n    type.typeIds, 4, 4,\n    (builder, value) => builder.addInt32(value)\n  );\n  return builder.addObject(2, b => {\n    b.addInt16(0, type.mode, UnionMode.Sparse);\n    b.addOffset(1, typeIdsOffset, 0);\n  });\n}\n\nfunction encodeDictionary(builder, type) {\n  // The Arrow spec uses signed 32-bit integers as the default index type.\n  // However, multiple 3rd party tools fail on a null (default) index type,\n  // so we always encode the index data type explicitly here.\n  return builder.addObject(4, b => {\n    b.addInt64(0, type.id, 0);\n    b.addOffset(1, encodeDataType(builder, type.indices), 0);\n    b.addInt8(2, +type.ordered, 0);\n    // NOT SUPPORTED: 3, dictionaryKind (defaults to dense array)\n  });\n}\n","import { Type } from '../constants.js';\nimport { encodeDataType } from './data-type.js';\nimport { encodeMetadata } from './metadata.js';\n\nconst isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n/**\n * @param {import('./builder.js').Builder} builder\n * @param {import('../types.js').Schema} schema\n * @returns {number}\n */\nexport function encodeSchema(builder, schema) {\n  const { fields, metadata } = schema;\n  const fieldOffsets = fields.map(f => encodeField(builder, f));\n  const fieldsVectorOffset = builder.addOffsetVector(fieldOffsets);\n  const metadataOffset = encodeMetadata(builder, metadata);\n  return builder.addObject(4, b => {\n    b.addInt16(0, +(!isLittleEndian), 0);\n    b.addOffset(1, fieldsVectorOffset, 0);\n    b.addOffset(2, metadataOffset, 0);\n    // NOT SUPPORTED: 3, features\n  });\n}\n\n/**\n * @param {import('./builder.js').Builder} builder\n * @param {import('../types.js').Field} field\n * @returns {number}\n */\nfunction encodeField(builder, field) {\n  const { name, nullable, type, metadata } = field;\n  let { typeId } = type;\n\n  // encode field data type\n  let typeOffset = 0;\n  let dictionaryOffset = 0;\n  if (typeId !== Type.Dictionary) {\n    typeOffset = encodeDataType(builder, type);\n  } else {\n    const dict = /** @type {import('../types.js').DictionaryType} */ (type).dictionary;\n    typeId = dict.typeId;\n    dictionaryOffset = encodeDataType(builder, type);\n    typeOffset = encodeDataType(builder, dict);\n  }\n\n  // encode children, metadata, name, and field object\n  // @ts-ignore\n  const childOffsets = (type.children || []).map(f => encodeField(builder, f));\n  const childrenVectorOffset = builder.addOffsetVector(childOffsets);\n  const metadataOffset = encodeMetadata(builder, metadata);\n  const nameOffset = builder.addString(name);\n  return builder.addObject(7, b => {\n    b.addOffset(0, nameOffset, 0);\n    b.addInt8(1, +nullable, +false);\n    b.addInt8(2, typeId, Type.NONE);\n    b.addOffset(3, typeOffset, 0);\n    b.addOffset(4, dictionaryOffset, 0);\n    b.addOffset(5, childrenVectorOffset, 0);\n    b.addOffset(6, metadataOffset, 0);\n  });\n}\n","import { MAGIC, Version } from '../constants.js';\nimport { encodeMetadata } from './metadata.js';\nimport { encodeSchema } from './schema.js';\n\n/**\n * Write a file footer.\n * @param {import('./builder.js').Builder} builder The binary builder.\n * @param {import('../types.js').Schema} schema The table schema.\n * @param {import('../types.js').Block[]} dictBlocks Dictionary batch file blocks.\n * @param {import('../types.js').Block[]} recordBlocks Record batch file blocks.\n * @param {Map<string,string> | null} metadata File-level metadata.\n */\nexport function writeFooter(builder, schema, dictBlocks, recordBlocks, metadata) {\n  // encode footer flatbuffer\n  const metadataOffset = encodeMetadata(builder, metadata);\n  const recsOffset = builder.addVector(recordBlocks, 24, 8, encodeBlock);\n  const dictsOffset = builder.addVector(dictBlocks, 24, 8, encodeBlock);\n  const schemaOffset = encodeSchema(builder, schema);\n  builder.finish(\n    builder.addObject(5, b => {\n      b.addInt16(0, Version.V5, Version.V1);\n      b.addOffset(1, schemaOffset, 0);\n      b.addOffset(2, dictsOffset, 0);\n      b.addOffset(3, recsOffset, 0);\n      b.addOffset(4, metadataOffset, 0);\n    })\n  );\n  const size = builder.offset();\n\n  // add eos with continuation indicator\n  builder.addInt32(0);\n  builder.addInt32(-1);\n\n  // write builder contents\n  builder.flush();\n\n  // write file tail\n  builder.sink.write(new Uint8Array(Int32Array.of(size).buffer));\n  builder.sink.write(MAGIC);\n}\n\n/**\n * Encode a file pointer block.\n * @param {import('./builder.js').Builder} builder\n * @param {import('../types.js').Block} block\n * @returns {number} the current block offset\n */\nfunction encodeBlock(builder, { offset, metadataLength, bodyLength }) {\n  builder.writeInt64(bodyLength);\n  builder.writeInt32(0);\n  builder.writeInt32(metadataLength);\n  builder.writeInt64(offset);\n  return builder.offset();\n}\n","import { MessageHeader, Version } from '../constants.js';\n\n/**\n * Write an IPC message to the builder sink.\n * @param {import('./builder.js').Builder} builder\n * @param {import('../types.js').MessageHeader_} headerType\n * @param {number} headerOffset\n * @param {number} bodyLength\n * @param {import('../types.js').Block[]} [blocks]\n */\nexport function writeMessage(builder, headerType, headerOffset, bodyLength, blocks) {\n  builder.finish(\n    builder.addObject(5, b => {\n      b.addInt16(0, Version.V5, Version.V1);\n      b.addInt8(1, headerType, MessageHeader.NONE);\n      b.addOffset(2, headerOffset, 0);\n      b.addInt64(3, bodyLength, 0);\n      // NOT SUPPORTED: 4, message-level metadata\n    })\n  );\n\n  const prefixSize = 8; // continuation indicator + message size\n  const messageSize = builder.offset();\n  const alignedSize = (messageSize + prefixSize + 7) & ~7;\n\n  // track blocks for file footer\n  blocks?.push({\n    offset: builder.outputBytes,\n    metadataLength: alignedSize,\n    bodyLength\n  });\n\n  // write size prefix (including padding)\n  builder.addInt32(alignedSize - prefixSize);\n\n  // write the stream continuation indicator\n  builder.addInt32(-1);\n\n  // flush the builder content\n  builder.flush();\n\n  // add alignment padding as needed\n  builder.addPadding(alignedSize - messageSize - prefixSize);\n}\n","export class Sink {\n  /**\n   * Write bytes to this sink.\n   * @param {Uint8Array} bytes The byte buffer to write.\n   */\n  write(bytes) { // eslint-disable-line no-unused-vars\n  }\n\n  /**\n   * Write padding bytes (zeroes) to this sink.\n   * @param {number} byteCount The number of padding bytes.\n   */\n  pad(byteCount) {\n    this.write(new Uint8Array(byteCount));\n  }\n\n  /**\n   * @returns {Uint8Array | null}\n   */\n  finish() {\n    return null;\n  }\n}\n\nexport class MemorySink extends Sink {\n  /**\n   * A sink that collects bytes in memory.\n   */\n  constructor() {\n    super();\n    this.buffers = [];\n  }\n\n  /**\n   * Write bytes\n   * @param {Uint8Array} bytes\n   */\n  write(bytes) {\n    this.buffers.push(bytes);\n  }\n\n  /**\n   * @returns {Uint8Array}\n   */\n  finish() {\n    const bufs = this.buffers;\n    const size = bufs.reduce((sum, b) => sum + b.byteLength, 0);\n    const buf = new Uint8Array(size);\n    for (let i = 0, off = 0; i < bufs.length; ++i) {\n      buf.set(bufs[i], off);\n      off += bufs[i].byteLength;\n    }\n    return buf;\n  }\n}\n","import { EOS, MAGIC, MessageHeader } from '../constants.js';\nimport { Builder } from './builder.js';\nimport { encodeDictionaryBatch } from './dictionary-batch.js';\nimport { writeFooter } from './footer.js';\nimport { encodeRecordBatch } from './record-batch.js';\nimport { encodeSchema } from './schema.js';\nimport { writeMessage } from './message.js';\nimport { MemorySink } from './sink.js';\n\nconst STREAM = 'stream';\nconst FILE = 'file';\n\n/**\n * Encode assembled data into Arrow IPC binary format.\n * @param {any} data Assembled table data.\n * @param {object} options Encoding options.\n * @param {import('./sink.js').Sink} [options.sink] IPC byte consumer.\n * @param {'stream' | 'file'} [options.format] Arrow stream or file format.\n * @returns {import('./sink.js').Sink} The sink that was passed in.\n */\nexport function encodeIPC(data, { sink, format = STREAM } = {}) {\n  if (format !== STREAM && format !== FILE) {\n    throw new Error(`Unrecognized Arrow IPC format: ${format}`);\n  }\n  const { schema, dictionaries = [], records = [], metadata } = data;\n  const builder = new Builder(sink || new MemorySink());\n  const file = format === FILE;\n  const dictBlocks = [];\n  const recordBlocks = [];\n\n  if (file) {\n    builder.addBuffer(MAGIC);\n  }\n\n  // both stream and file start with the schema\n  if (schema) {\n    writeMessage(\n      builder,\n      MessageHeader.Schema,\n      encodeSchema(builder, schema),\n      0\n    );\n  }\n\n  // write dictionary messages\n  for (const dict of dictionaries) {\n    const { data } = dict;\n    writeMessage(\n      builder,\n      MessageHeader.DictionaryBatch,\n      encodeDictionaryBatch(builder, dict),\n      data.byteLength,\n      dictBlocks\n    );\n    writeBuffers(builder, data.buffers);\n  }\n\n  // write record batch messages\n  for (const batch of records) {\n    writeMessage(\n      builder,\n      MessageHeader.RecordBatch,\n      encodeRecordBatch(builder, batch),\n      batch.byteLength,\n      recordBlocks\n    );\n    writeBuffers(builder, batch.buffers);\n  }\n\n  // both stream and file include end-of-stream message\n  builder.addBuffer(EOS);\n\n  if (file) {\n    writeFooter(builder, schema, dictBlocks, recordBlocks, metadata);\n  }\n\n  return builder.sink;\n}\n\n/**\n * Write byte buffers to the builder sink.\n * Buffers are aligned to 64 bits (8 bytes) as needed.\n * @param {import('./builder.js').Builder} builder\n * @param {Uint8Array[]} buffers\n */\nfunction writeBuffers(builder, buffers) {\n  for (let i = 0; i < buffers.length; ++i) {\n    builder.addBuffer(buffers[i]); // handles alignment for us\n  }\n}\n","import { Type, UnionMode } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { encodeIPC } from './encode-ipc.js';\n\n/**\n * Encode an Arrow table into Arrow IPC binary format.\n * @param {import('../table.js').Table} table The Arrow table to encode.\n * @param {object} options Encoding options.\n * @param {import('./sink.js').Sink} [options.sink] IPC byte consumer.\n * @param {'stream' | 'file'} [options.format] Arrow stream or file format.\n * @returns {Uint8Array | null} The generated bytes (for an in-memory sink)\n *  or null (if using a sink that writes bytes elsewhere).\n */\nexport function tableToIPC(table, options) {\n  // accept a format string option for Arrow-JS compatibility\n  if (typeof options === 'string') {\n    options = { format: options };\n  }\n\n  const columns = table.children;\n  checkBatchLengths(columns);\n\n  const { dictionaries, idMap } = assembleDictionaryBatches(columns);\n  const records = assembleRecordBatches(columns);\n  const schema = assembleSchema(table.schema, idMap);\n  const data = { schema, dictionaries, records };\n  return encodeIPC(data, options).finish();\n}\n\nfunction checkBatchLengths(columns) {\n  const n = columns[0]?.data.map(d => d.length);\n  columns.forEach(({ data }) => {\n    if (data.length !== n.length || data.some((b, i) => b.length !== n[i])) {\n      throw new Error('Columns have inconsistent batch sizes.');\n    }\n  });\n}\n\n/**\n * Create a new assembly context.\n */\nfunction assembleContext() {\n  let byteLength = 0;\n  const nodes = [];\n  const regions = [];\n  const buffers = [];\n  const variadic = [];\n  return {\n    /**\n     * @param {number} length\n     * @param {number} nullCount\n     */\n    node(length, nullCount) {\n      nodes.push({ length, nullCount });\n    },\n    /**\n     * @param {import('../types.js').TypedArray} b\n     */\n    buffer(b) {\n      const size = b.byteLength;\n      const length = ((size + 7) & ~7);\n      regions.push({ offset: byteLength, length });\n      byteLength += length;\n      buffers.push(new Uint8Array(b.buffer, b.byteOffset, size));\n    },\n    /**\n     * @param {number} length\n     */\n    variadic(length) {\n      variadic.push(length);\n    },\n    /**\n     * @param {import('../types.js').DataType} type\n     * @param {import('../batch.js').Batch} batch\n     */\n    children(type, batch) {\n      // @ts-ignore\n      type.children.forEach((field, index) => {\n        visit(field.type, batch.children[index], this);\n      });\n    },\n    /**\n     * @returns {import('../types.js').RecordBatch}\n     */\n    done() {\n      return { byteLength, nodes, regions, variadic, buffers };\n    }\n  };\n}\n\n/**\n * Assemble dictionary batches and their unique ids.\n * @param {import('../column.js').Column[]} columns The table columns.\n * @returns {{\n *    dictionaries: import('../types.js').DictionaryBatch[],\n *    idMap: Map<import('../types.js').DataType, number>\n *  }}\n *  The assembled dictionary batches and a map from dictionary column\n *  instances to dictionary ids.\n */\nfunction assembleDictionaryBatches(columns) {\n  const dictionaries = [];\n  const dictMap = new Map;\n  const idMap = new Map;\n  let id = -1;\n\n  // track dictionaries, key by dictionary column, assign ids\n  const visitor = dictionaryColumn => {\n    if (!dictMap.has(dictionaryColumn)) {\n      dictMap.set(dictionaryColumn, ++id);\n      for (let i = 0; i < dictionaryColumn.data.length; ++i) {\n        dictionaries.push({\n          id,\n          isDelta: i > 0,\n          data: assembleRecordBatch([dictionaryColumn], i)\n        });\n      }\n      idMap.set(dictionaryColumn.type, id);\n    } else {\n      idMap.set(dictionaryColumn.type, dictMap.get(dictionaryColumn));\n    }\n  };\n\n  // recurse through column batches to find dictionaries\n  // it is sufficient to visit the first batch only,\n  // as all batches have the same dictionary column\n  columns.forEach(col => visitDictionaries(col.data[0], visitor));\n\n  return { dictionaries, idMap };\n}\n\n/**\n * Traverse column batches to visit dictionary columns.\n * @param {import('../batch.js').Batch} batch\n * @param {(column: import('../column.js').Column) => void} visitor\n */\nfunction visitDictionaries(batch, visitor) {\n  if (batch?.type.typeId === Type.Dictionary) {\n    // @ts-ignore - batch has type DictionaryBatch\n    const dictionary = batch.dictionary;\n    visitor(dictionary);\n    visitDictionaries(dictionary.data[0], visitor);\n  }\n  batch?.children?.forEach(child => visitDictionaries(child, visitor));\n}\n\n/**\n * Assemble a schema with resolved dictionary ids.\n * @param {import('../types.js').Schema} schema The schema.\n * @param {Map<import('../types.js').DataType, number>} idMap A map\n *  from dictionary value types to dictionary ids.\n * @returns {import('../types.js').Schema} A new schema with resolved\n *  dictionary ids. If there are no dictionaries, the input schema is\n *  returned unchanged.\n */\nfunction assembleSchema(schema, idMap) {\n  // early exit if no dictionaries\n  if (!idMap.size) return schema;\n\n  const visit = type => {\n    if (type.typeId === Type.Dictionary) {\n      type.id = idMap.get(type.dictionary); // lookup and set id\n      visitDictType(type);\n    }\n    if (type.children) {\n      (type.children = type.children.slice()).forEach(visitFields);\n    }\n  };\n\n  // visit a field in a field array\n  const visitFields = (field, index, array) => {\n    const type = { ...field.type };\n    array[index] = { ...field, type };\n    visit(type);\n  };\n\n  // visit a dictionary values type\n  const visitDictType = (parentType) => {\n    const type = { ...parentType.dictionary };\n    parentType.dictionary = type;\n    visit(type);\n  };\n\n  schema = { ...schema, fields: schema.fields.slice() };\n  schema.fields.forEach(visitFields);\n  return schema;\n}\n\n/**\n * Assemble record batches with marshalled buffers.\n * @param {import('../column.js').Column[]} columns The table columns.\n * @returns {import('../types.js').RecordBatch[]} The assembled record batches.\n */\nfunction assembleRecordBatches(columns) {\n  return (columns[0]?.data || [])\n    .map((_, index) => assembleRecordBatch(columns, index));\n}\n\n/**\n * Assemble a record batch with marshalled buffers.\n * @param {import('../column.js').Column[]} columns The table columns.\n * @param {number} batchIndex The batch index.\n * @returns {import('../types.js').RecordBatch} The assembled record batch.\n */\nfunction assembleRecordBatch(columns, batchIndex = 0) {\n  const ctx = assembleContext();\n  columns.forEach(column => {\n    visit(column.type, column.data[batchIndex], ctx);\n  });\n  return ctx.done();\n}\n\n/**\n * Visit a column batch, assembling buffer data.\n * @param {import('../types.js').DataType} type The data type.\n * @param {import('../batch.js').Batch} batch The column batch.\n * @param {ReturnType<assembleContext>} ctx The assembly context.\n */\nfunction visit(type, batch, ctx) {\n  const { typeId } = type;\n\n  // no field node, no buffers\n  if (typeId === Type.Null) return;\n\n  // record field node info\n  ctx.node(batch.length, batch.nullCount);\n\n  switch (typeId) {\n    // validity and value buffers\n    // backing dictionaries handled elsewhere\n    case Type.Bool:\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n    case Type.Float:\n    case Type.Date:\n    case Type.Timestamp:\n    case Type.Decimal:\n    case Type.Interval:\n    case Type.FixedSizeBinary:\n    case Type.Dictionary: // dict key values\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.values);\n      return;\n\n    // validity, offset, and value buffers\n    case Type.Utf8:\n    case Type.LargeUtf8:\n    case Type.Binary:\n    case Type.LargeBinary:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.offsets);\n      ctx.buffer(batch.values);\n      return;\n\n    // views with variadic buffers\n    case Type.BinaryView:\n    case Type.Utf8View:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.values);\n      // @ts-ignore\n      ctx.variadic(batch.data.length);\n      // @ts-ignore\n      batch.data.forEach(b => ctx.buffer(b));\n      return;\n\n    // validity, offset, and list child\n    case Type.List:\n    case Type.LargeList:\n    case Type.Map:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.offsets);\n      ctx.children(type, batch);\n      return;\n\n    // validity, offset, size, and list child\n    case Type.ListView:\n    case Type.LargeListView:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.offsets);\n      ctx.buffer(batch.sizes);\n      ctx.children(type, batch);\n      return;\n\n    // validity and children\n    case Type.FixedSizeList:\n    case Type.Struct:\n      ctx.buffer(batch.validity);\n      ctx.children(type, batch);\n      return;\n\n    // children only\n    case Type.RunEndEncoded:\n      ctx.children(type, batch);\n      return;\n\n    // union\n    case Type.Union: {\n      // @ts-ignore\n      ctx.buffer(batch.typeIds);\n      if (type.mode === UnionMode.Dense) {\n        ctx.buffer(batch.offsets);\n      }\n      ctx.children(type, batch);\n      return;\n    }\n\n    // unsupported type\n    default:\n      throw new Error(invalidDataType(typeId));\n  }\n}\n","import { align, grow, uint8Array } from '../util/arrays.js';\n\n/**\n * Create a new resizable buffer instance.\n * @param {import('../types.js').TypedArrayConstructor} [arrayType]\n *  The array type.\n * @returns {Buffer} The buffer.\n */\nexport function buffer(arrayType) {\n  return new Buffer(arrayType);\n}\n\n/**\n * Resizable byte buffer.\n */\nexport class Buffer {\n  /**\n   * Create a new resizable buffer instance.\n   * @param {import('../types.js').TypedArrayConstructor} arrayType\n   */\n  constructor(arrayType = uint8Array) {\n    this.buf = new arrayType(512);\n  }\n  /**\n   * Return the underlying data as a 64-bit aligned array of minimum size.\n   * @param {number} size The desired minimum array size.\n   * @returns {import('../types.js').TypedArray} The 64-bit aligned array.\n   */\n  array(size) {\n    return align(this.buf, size);\n  }\n  /**\n   * Prepare for writes to the given index, resizing as necessary.\n   * @param {number} index The array index to prepare to write to.\n   */\n  prep(index) {\n    if (index >= this.buf.length) {\n      this.buf = grow(this.buf, index);\n    }\n  }\n  /**\n   * Return the value at the given index.\n   * @param {number} index The array index.\n   */\n  get(index) {\n    return this.buf[index];\n  }\n  /**\n   * Set a value at the given index.\n   * @param {number | bigint} value The value to set.\n   * @param {number} index The index to write to.\n   */\n  set(value, index) {\n    this.prep(index);\n    this.buf[index] = value;\n  }\n  /**\n   * Write a byte array at the given index. The method should be called\n   * only when the underlying buffer is of type Uint8Array.\n   * @param {Uint8Array} bytes The byte array.\n   * @param {number} index The starting index to write to.\n   */\n  write(bytes, index) {\n    this.prep(index + bytes.length);\n    /** @type {Uint8Array} */ (this.buf).set(bytes, index);\n  }\n}\n\n/**\n * Create a new resizable bitmap instance.\n * @returns {Bitmap} The bitmap buffer.\n */\nexport function bitmap() {\n  return new Bitmap();\n}\n\n/**\n * Resizable bitmap buffer.\n */\nexport class Bitmap extends Buffer {\n  /**\n   * Set a bit to true at the given bitmap index.\n   * @param {number} index The index to write to.\n   */\n  set(index) {\n    const i = index >> 3;\n    this.prep(i);\n    /** @type {Uint8Array} */ (this.buf)[i] |= (1 << (index % 8));\n  }\n}\n","/**\n * Abstract class for building a column data batch.\n */\nexport class BatchBuilder {\n  constructor(type, ctx) {\n    this.type = type;\n    this.ctx = ctx;\n    this.batchClass = ctx.batchType(type);\n  }\n\n  /**\n   * Initialize the builder state.\n   * @returns {this} This builder.\n   */\n  init() {\n    this.index = -1;\n    return this;\n  }\n\n  /**\n   * Write a value to the builder.\n   * @param {*} value\n   * @param {number} index\n   * @returns {boolean | void}\n   */\n  set(value, index) {\n    this.index = index;\n    return false;\n  }\n\n  /**\n   * Returns a batch constructor options object.\n   * Used internally to marshal batch data.\n   * @returns {Record<string, any>}\n   */\n  done() {\n    return null;\n  }\n\n  /**\n   * Returns a completed batch and reinitializes the builder state.\n   * @returns {import('../../batch.js').Batch}\n   */\n  batch() {\n    const b = new this.batchClass(this.done());\n    this.init();\n    return b;\n  }\n}\n","import { uint8Array } from '../../util/arrays.js';\nimport { bitmap } from '../buffer.js';\nimport { BatchBuilder } from './batch.js';\n\n/**\n * Builder for validity bitmaps within batches.\n */\nexport class ValidityBuilder extends BatchBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n  }\n\n  init() {\n    this.nullCount = 0;\n    this.validity = bitmap();\n    return super.init();\n  }\n\n  /**\n   * @param {*} value\n   * @param {number} index\n   * @returns {boolean | void}\n   */\n  set(value, index) {\n    this.index = index;\n    const isValid = value != null;\n    if (isValid) {\n      this.validity.set(index);\n    } else {\n      this.nullCount++;\n    }\n    return isValid;\n  }\n\n  done() {\n    const { index, nullCount, type, validity } = this;\n    return {\n      length: index + 1,\n      nullCount,\n      type,\n      validity: nullCount\n        ? validity.array((index >> 3) + 1)\n        : new uint8Array(0)\n    };\n  }\n}\n","import { Column } from '../../column.js';\nimport { keyString } from '../../util/strings.js';\nimport { batchType } from '../../batch-type.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Create a context object for managing dictionary builders.\n */\nexport function dictionaryContext() {\n  const idMap = new Map;\n  const dicts = new Set;\n  return {\n    /**\n     * Get a dictionary values builder for the given dictionary type.\n     * @param {import('../../types.js').DictionaryType} type\n     *  The dictionary type.\n     * @param {*} ctx The builder context.\n     * @returns {ReturnType<dictionaryValues>}\n     */\n    get(type, ctx) {\n      // if a dictionary has a non-negative id, assume it was set\n      // intentionally and track it for potential reuse across columns\n      // otherwise the dictionary is used for a single column only\n      const id = type.id;\n      if (id >= 0 && idMap.has(id)) {\n        return idMap.get(id);\n      } else {\n        const dict = dictionaryValues(type, ctx);\n        if (id >= 0) idMap.set(id, dict);\n        dicts.add(dict);\n        return dict;\n      }\n    },\n    /**\n     * Finish building dictionary values columns and assign them to\n     * their corresponding dictionary batches.\n     * @param {import('../../types.js').ExtractionOptions} options\n     */\n    finish(options) {\n      dicts.forEach(dict => dict.finish(options));\n    }\n  };\n}\n\n/**\n * Builder helper for creating dictionary values.\n * @param {import('../../types.js').DictionaryType} type\n *  The dictionary data type.\n * @param {ReturnType<import('../builder.js').builderContext>} ctx\n *  The builder context.\n */\nexport function dictionaryValues(type, ctx) {\n  const keys = Object.create(null);\n  const values = ctx.builder(type.dictionary);\n  const batches = [];\n\n  values.init();\n  let index = -1;\n\n  return {\n    type,\n    values,\n\n    add(batch) {\n      batches.push(batch);\n      return batch;\n    },\n\n    key(value) {\n      const v = keyString(value);\n      let k = keys[v];\n      if (k === undefined) {\n        keys[v] = k = ++index;\n        values.set(value, k);\n      }\n      return k;\n    },\n\n    finish(options) {\n      const valueType = type.dictionary;\n      const batch = new (batchType(valueType, options))(values.done());\n      const dictionary = new Column([batch]);\n      batches.forEach(batch => batch.setDictionary(dictionary));\n    }\n  };\n}\n\n/**\n * Builder for dictionary-typed data batches.\n */\nexport class DictionaryBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.dict = ctx.dictionary(type);\n  }\n\n  init() {\n    this.values = buffer(this.type.indices.values);\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.set(this.dict.key(value), index);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array(this.index + 1)\n    };\n  }\n\n  batch() {\n    // register batch with dictionary\n    // batch will be updated when the dictionary is finished\n    return this.dict.add(super.batch());\n  }\n}\n","import { bool, dateDay, dictionary, field, fixedSizeList, float64, int16, int32, int64, int8, list, nullType, struct, timestamp, utf8 } from '../data-types.js';\nimport { isArray } from '../util/arrays.js';\n\n/**\n * Infer the data type for a given input array.\n * @param {(visitor: (value: any) => void) => void} visit\n *  A function that applies a callback to successive data values.\n * @returns {import('../types.js').DataType} The data type.\n */\nexport function inferType(visit) {\n  const profile = profiler();\n  visit(value => profile.add(value));\n  return profile.type();\n}\n\nfunction profiler() {\n  let length = 0;\n  let nullCount = 0;\n  let boolCount = 0;\n  let numberCount = 0;\n  let intCount = 0;\n  let bigintCount = 0;\n  let dateCount = 0;\n  let dayCount = 0;\n  let stringCount = 0;\n  let arrayCount = 0;\n  let structCount = 0;\n  let min = Infinity;\n  let max = -Infinity;\n  let minLength = Infinity;\n  let maxLength = -Infinity;\n  let minBigInt;\n  let maxBigInt;\n  let arrayProfile;\n  let structProfiles = {};\n\n  return {\n    add(value) {\n      length++;\n      if (value == null) {\n        nullCount++;\n        return;\n      }\n      switch (typeof value) {\n        case 'string':\n          stringCount++;\n          break;\n        case 'number':\n          numberCount++;\n          if (value < min) min = value;\n          if (value > max) max = value;\n          if (Number.isInteger(value)) intCount++;\n          break;\n        case 'bigint':\n          bigintCount++;\n          if (minBigInt === undefined) {\n            minBigInt = maxBigInt = value;\n          } else {\n            if (value < minBigInt) minBigInt = value;\n            if (value > maxBigInt) maxBigInt = value;\n          }\n          break;\n        case 'boolean':\n          boolCount++;\n          break;\n        case 'object':\n          if (value instanceof Date) {\n            dateCount++;\n            // 1 day = 1000ms * 60s * 60min * 24hr = 86400000\n            if ((+value % 864e5) === 0) dayCount++;\n          } else if (isArray(value)) {\n            arrayCount++;\n            const len = value.length;\n            if (len < minLength) minLength = len;\n            if (len > maxLength) maxLength = len;\n            arrayProfile ??= profiler();\n            value.forEach(arrayProfile.add);\n          } else {\n            structCount++;\n            for (const key in value) {\n              const fieldProfiler = structProfiles[key]\n                ?? (structProfiles[key] = profiler());\n              fieldProfiler.add(value[key]);\n            }\n          }\n      }\n    },\n    type() {\n      const valid = length - nullCount;\n      return valid === 0 ? nullType()\n        : intCount === valid ? intType(min, max)\n        : numberCount === valid ? float64()\n        : bigintCount === valid ? bigintType(minBigInt, maxBigInt)\n        : boolCount === valid ? bool()\n        : dayCount === valid ? dateDay()\n        : dateCount === valid ? timestamp()\n        : stringCount === valid ? dictionary(utf8())\n        : arrayCount === valid ? arrayType(arrayProfile.type(), minLength, maxLength)\n        : structCount === valid ? struct(\n            Object.entries(structProfiles).map(_ => field(_[0], _[1].type()))\n          )\n        : unionType();\n    }\n  };\n}\n\n/**\n * Return a list or fixed list type.\n * @param {import('../types.js').DataType} type The child data type.\n * @param {number} minLength The minumum list length.\n * @param {number} maxLength The maximum list length.\n * @returns {import('../types.js').DataType} The data type.\n */\nfunction arrayType(type, minLength, maxLength) {\n  return maxLength === minLength\n    ? fixedSizeList(type, minLength)\n    : list(type);\n}\n\n/**\n * @param {number} min\n * @param {number} max\n * @returns {import('../types.js').DataType}\n */\nfunction intType(min, max) {\n  const v = Math.max(Math.abs(min) - 1, max);\n  return v < (1 << 7) ? int8()\n    : v < (1 << 15) ? int16()\n    : v < (2 ** 31) ? int32()\n    : float64();\n}\n\n/**\n * @param {bigint} min\n * @param {bigint} max\n * @returns {import('../types.js').IntType}\n */\nfunction bigintType(min, max) {\n  const v = -min > max ? -min - 1n : max;\n  if (v >= 2 ** 63) {\n    throw new Error(`BigInt exceeds 64 bits: ${v}`);\n  }\n  return int64();\n}\n\n/**\n * @returns {import('../types.js').UnionType}\n */\nfunction unionType() {\n  throw new Error('Mixed types detected, please define a union type.');\n}\n","import { toOffset } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for batches of binary-typed data.\n */\nexport class BinaryBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.toOffset = toOffset(type.offsets);\n  }\n\n  init() {\n    this.offsets = buffer(this.type.offsets);\n    this.values = buffer();\n    this.pos = 0;\n    return super.init();\n  }\n\n  set(value, index) {\n    const { offsets, values, toOffset } = this;\n    if (super.set(value, index)) {\n      values.write(value, this.pos);\n      this.pos += value.length;\n    }\n    offsets.set(toOffset(this.pos), index + 1);\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      offsets: this.offsets.array(this.index + 2),\n      values: this.values.array(this.pos + 1)\n    };\n  }\n}\n","import { bitmap } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for batches of bool-typed data.\n */\nexport class BoolBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n  }\n\n  init() {\n    this.values = bitmap();\n    return super.init();\n  }\n\n  set(value, index) {\n    super.set(value, index);\n    if (value) this.values.set(index);\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array((this.index >> 3) + 1)\n    }\n  }\n}\n","import { toDecimal } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for batches of decimal-typed data (64-bits or more).\n */\nexport class DecimalBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.scale = 10 ** type.scale;\n    this.stride = type.bitWidth >> 6;\n  }\n\n  init() {\n    this.values = buffer(this.type.values);\n    return super.init();\n  }\n\n  set(value, index) {\n    const { scale, stride, values } = this;\n    if (super.set(value, index)) {\n      values.prep((index + 1) * stride);\n      // @ts-ignore\n      toDecimal(value, values.buf, index * stride, stride, scale);\n    }\n  }\n\n  done() {\n    const { index, stride, values } = this;\n    return {\n      ...super.done(),\n      values: values.array((index + 1) * stride)\n    };\n  }\n}\n","import { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for fixed-size-binary-typed data batches.\n */\nexport class FixedSizeBinaryBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.stride = type.stride;\n  }\n\n  init() {\n    this.values = buffer();\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.write(value, index * this.stride);\n    }\n  }\n\n  done() {\n    const { stride, values } = this;\n    return {\n      ...super.done(),\n      values: values.array(stride * (this.index + 1))\n    };\n  }\n}\n","import { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for fixed-size-list-typed data batches.\n */\nexport class FixedSizeListBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.child = ctx.builder(this.type.children[0].type);\n    this.stride = type.stride;\n  }\n\n  init() {\n    this.child.init();\n    return super.init();\n  }\n\n  set(value, index) {\n    const { child, stride } = this;\n    const base = index * stride;\n    if (super.set(value, index)) {\n      for (let i = 0; i < stride; ++i) {\n        child.set(value[i], base + i);\n      }\n    } else {\n      child.index = base + stride;\n    }\n  }\n\n  done() {\n    const { child } = this;\n    return {\n      ...super.done(),\n      children: [ child.batch() ]\n    };\n  }\n}\n","import { toMonthDayNanoBytes } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for day/time interval-typed data batches.\n */\nexport class IntervalDayTimeBuilder extends ValidityBuilder {\n  init() {\n    this.values = buffer(this.type.values);\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      const i = index << 1;\n      this.values.set(value[0], i);\n      this.values.set(value[1], i + 1);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array((this.index + 1) << 1)\n    }\n  }\n}\n\n/**\n * Builder for month/day/nano interval-typed data batches.\n */\nexport class IntervalMonthDayNanoBuilder extends ValidityBuilder {\n  init() {\n    this.values = buffer();\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.write(toMonthDayNanoBytes(value), index << 4);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array((this.index + 1) << 4)\n    }\n  }\n}\n","import { toOffset } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Abstract class for building list data batches.\n */\nexport class AbstractListBuilder extends ValidityBuilder {\n  constructor(type, ctx, child) {\n    super(type, ctx);\n    this.child = child;\n  }\n\n  init() {\n    this.child.init();\n    const offsetType = this.type.offsets;\n    this.offsets = buffer(offsetType);\n    this.toOffset = toOffset(offsetType);\n    this.pos = 0;\n    return super.init();\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      offsets: this.offsets.array(this.index + 2),\n      children: [ this.child.batch() ]\n    };\n  }\n}\n\n/**\n * Builder for list-typed data batches.\n */\nexport class ListBuilder extends AbstractListBuilder {\n  constructor(type, ctx) {\n    super(type, ctx, ctx.builder(type.children[0].type));\n  }\n\n  set(value, index) {\n    const { child, offsets, toOffset } = this;\n    if (super.set(value, index)) {\n      value.forEach(v => child.set(v, this.pos++));\n    }\n    offsets.set(toOffset(this.pos), index + 1);\n  }\n}\n","import { ValidityBuilder } from './validity.js';\n\n/**\n * Abstract class for building list-typed data batches.\n */\nexport class AbstractStructBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.children = type.children.map(c => ctx.builder(c.type));\n  }\n\n  init() {\n    this.children.forEach(c => c.init());\n    return super.init();\n  }\n\n  done() {\n    const { children } = this;\n    children.forEach(c => c.index = this.index);\n    return {\n      ...super.done(),\n      children: children.map(c => c.batch())\n    };\n  }\n}\n\n/**\n * Builder for struct-typed data batches.\n */\nexport class StructBuilder extends AbstractStructBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.setters = this.children.map((child, i) => {\n      const name = type.children[i].name;\n      return (value, index) => child.set(value?.[name], index);\n    });\n  }\n\n  set(value, index) {\n    super.set(value, index);\n    const setters = this.setters;\n    for (let i = 0; i < setters.length; ++i) {\n      setters[i](value, index);\n    }\n  }\n}\n","import { AbstractListBuilder } from './list.js';\nimport { AbstractStructBuilder } from './struct.js';\n\n/**\n * Builder for map-typed data batches.\n */\nexport class MapBuilder extends AbstractListBuilder {\n  constructor(type, ctx) {\n    super(type, ctx, new MapStructBuilder(type.children[0].type, ctx));\n  }\n\n  set(value, index) {\n    const { child, offsets, toOffset } = this;\n    if (super.set(value, index)) {\n      for (const keyValuePair of value) {\n        child.set(keyValuePair, this.pos++);\n      }\n    }\n    offsets.set(toOffset(this.pos), index + 1);\n  }\n}\n\n/**\n * Builder for key-value struct batches within a map.\n */\nclass MapStructBuilder extends AbstractStructBuilder {\n  set(value, index) {\n    super.set(value, index);\n    const [key, val] = this.children;\n    key.set(value[0], index);\n    val.set(value[1], index);\n  }\n}\n","import { keyString } from '../../util/strings.js';\nimport { BatchBuilder } from './batch.js';\n\nconst NO_VALUE = {}; // empty object that fails strict equality\n\n/**\n * Builder for run-end-encoded-typed data batches.\n */\nexport class RunEndEncodedBuilder extends BatchBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.children = type.children.map(c => ctx.builder(c.type));\n  }\n\n  init() {\n    this.pos = 0;\n    this.key = null;\n    this.value = NO_VALUE;\n    this.children.forEach(c => c.init());\n    return super.init();\n  }\n\n  next() {\n    const [runs, vals] = this.children;\n    runs.set(this.index + 1, this.pos);\n    vals.set(this.value, this.pos++);\n  }\n\n  set(value, index) {\n    // perform fast strict equality test\n    if (value !== this.value) {\n      // if no match, fallback to key string test\n      const key = keyString(value);\n      if (key !== this.key) {\n        // if key doesn't match, write prior run and update\n        if (this.key) this.next();\n        this.key = key;\n        this.value = value;\n      }\n    }\n    this.index = index;\n  }\n\n  done() {\n    this.next();\n    const { children, index, type } = this;\n    return {\n      length: index + 1,\n      nullCount: 0,\n      type,\n      children: children.map(c => c.batch())\n    };\n  }\n}\n","import { int8Array } from '../../util/arrays.js';\nimport { BatchBuilder } from './batch.js';\nimport { buffer } from '../buffer.js';\n\n/**\n * Abstract class for building union-typed data batches.\n */\nexport class AbstractUnionBuilder extends BatchBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.children = type.children.map(c => ctx.builder(c.type));\n    this.typeMap = type.typeMap;\n    this.lookup = type.typeIdForValue;\n  }\n\n  init() {\n    this.nullCount = 0;\n    this.typeIds = buffer(int8Array);\n    this.children.forEach(c => c.init());\n    return super.init();\n  }\n\n  set(value, index) {\n    const { children, lookup, typeMap, typeIds } = this;\n    this.index = index;\n    const typeId = lookup(value, index);\n    const child = children[typeMap[typeId]];\n    typeIds.set(typeId, index);\n    if (value == null) ++this.nullCount;\n    // @ts-ignore\n    this.update(value, index, child);\n  }\n\n  done() {\n    const { children, nullCount, type, typeIds } = this;\n    const length = this.index + 1;\n    return {\n      length,\n      nullCount,\n      type,\n      typeIds: typeIds.array(length),\n      children: children.map(c => c.batch())\n    };\n  }\n}\n\n/**\n * Builder for sparse union-typed data batches.\n */\nexport class SparseUnionBuilder extends AbstractUnionBuilder {\n  update(value, index, child) {\n    // update selected child with value\n    // then set all other children to null\n    child.set(value, index);\n    this.children.forEach(c => { if (c !== child) c.set(null, index) });\n  }\n}\n\n/**\n * Builder for dense union-typed data batches.\n */\nexport class DenseUnionBuilder extends AbstractUnionBuilder {\n  init() {\n    this.offsets = buffer(this.type.offsets);\n    return super.init();\n  }\n\n  update(value, index, child) {\n    const offset = child.index + 1;\n    child.set(value, offset);\n    this.offsets.set(offset, index);\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      offsets: this.offsets.array(this.index + 1)\n    };\n  }\n}\n","import { encodeUtf8 } from '../../util/strings.js';\nimport { BinaryBuilder } from './binary.js';\n\n/**\n * Builder for utf8-typed data batches.\n */\nexport class Utf8Builder extends BinaryBuilder {\n  set(value, index) {\n    super.set(value && encodeUtf8(value), index);\n  }\n}\n","import { toBigInt } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for data batches that can be accessed directly as typed arrays.\n */\nexport class DirectBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.values = buffer(type.values);\n  }\n\n  init() {\n    this.values = buffer(this.type.values);\n    return super.init();\n  }\n\n  /**\n   * @param {*} value\n   * @param {number} index\n   * @returns {boolean | void}\n   */\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.set(value, index);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array(this.index + 1)\n    };\n  }\n}\n\n/**\n * Builder for int64/uint64 data batches written as bigints.\n */\nexport class Int64Builder extends DirectBuilder {\n  set(value, index) {\n    super.set(value == null ? value : toBigInt(value), index);\n  }\n}\n\n/**\n * Builder for data batches whose values must pass through a transform\n * function prior to be written to a backing buffer.\n */\nexport class TransformBuilder extends DirectBuilder {\n  constructor(type, ctx, transform) {\n    super(type, ctx);\n    this.transform = transform;\n  }\n  set(value, index) {\n    super.set(value == null ? value : this.transform(value), index);\n  }\n}\n","import { batchType } from '../batch-type.js';\nimport { IntervalUnit, Type } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { isInt64ArrayType } from '../util/arrays.js';\nimport { toBigInt, toDateDay, toDecimal32, toFloat16, toTimestamp } from '../util/numbers.js';\nimport { BinaryBuilder } from './builders/binary.js';\nimport { BoolBuilder } from './builders/bool.js';\nimport { DecimalBuilder } from './builders/decimal.js';\nimport { DictionaryBuilder, dictionaryContext } from './builders/dictionary.js';\nimport { FixedSizeBinaryBuilder } from './builders/fixed-size-binary.js';\nimport { FixedSizeListBuilder } from './builders/fixed-size-list.js';\nimport { IntervalDayTimeBuilder, IntervalMonthDayNanoBuilder } from './builders/interval.js';\nimport { ListBuilder } from './builders/list.js';\nimport { MapBuilder } from './builders/map.js';\nimport { RunEndEncodedBuilder } from './builders/run-end-encoded.js';\nimport { StructBuilder } from './builders/struct.js';\nimport { DenseUnionBuilder, SparseUnionBuilder } from './builders/union.js';\nimport { Utf8Builder } from './builders/utf8.js';\nimport { DirectBuilder, Int64Builder, TransformBuilder } from './builders/values.js';\n\n/**\n * Create a context object for shared builder state.\n * @param {import('../types.js').ExtractionOptions} [options]\n *  Batch extraction options.\n* @param {ReturnType<dictionaryContext>} [dictionaries]\n *  Context object for tracking dictionaries.\n */\nexport function builderContext(\n  options = {},\n  dictionaries = dictionaryContext()\n) {\n  return {\n    batchType: type => batchType(type, options),\n    builder(type) { return builder(type, this); },\n    dictionary(type) { return dictionaries.get(type, this); },\n    finish: () => dictionaries.finish(options)\n  };\n}\n\n/**\n * Returns a batch builder for the given type and builder context.\n * @param {import('../types.js').DataType} type A data type.\n * @param {ReturnType<builderContext>} [ctx] A builder context.\n * @returns {import('./builders/batch.js').BatchBuilder}\n */\nexport function builder(type, ctx = builderContext()) {\n  const { typeId } = type;\n  switch (typeId) {\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n      return isInt64ArrayType(type.values)\n        ? new Int64Builder(type, ctx)\n        : new DirectBuilder(type, ctx);\n    case Type.Float:\n      return type.precision\n        ? new DirectBuilder(type, ctx)\n        : new TransformBuilder(type, ctx, toFloat16)\n    case Type.Binary:\n    case Type.LargeBinary:\n      return new BinaryBuilder(type, ctx);\n    case Type.Utf8:\n    case Type.LargeUtf8:\n      return new Utf8Builder(type, ctx);\n    case Type.Bool:\n      return new BoolBuilder(type, ctx);\n    case Type.Decimal:\n      return type.bitWidth === 32\n        ? new TransformBuilder(type, ctx, toDecimal32(type.scale))\n        : new DecimalBuilder(type, ctx);\n    case Type.Date:\n      return new TransformBuilder(type, ctx, type.unit ? toBigInt : toDateDay);\n    case Type.Timestamp:\n      return new TransformBuilder(type, ctx, toTimestamp(type.unit));\n    case Type.Interval:\n      switch (type.unit) {\n        case IntervalUnit.DAY_TIME:\n          return new IntervalDayTimeBuilder(type, ctx);\n        case IntervalUnit.MONTH_DAY_NANO:\n          return new IntervalMonthDayNanoBuilder(type, ctx);\n      }\n      // case IntervalUnit.YEAR_MONTH:\n      return new DirectBuilder(type, ctx);\n    case Type.List:\n    case Type.LargeList:\n      return new ListBuilder(type, ctx);\n    case Type.Struct:\n      return new StructBuilder(type, ctx);\n    case Type.Union:\n      return type.mode\n        ? new DenseUnionBuilder(type, ctx)\n        : new SparseUnionBuilder(type, ctx);\n    case Type.FixedSizeBinary:\n      return new FixedSizeBinaryBuilder(type, ctx);\n    case Type.FixedSizeList:\n      return new FixedSizeListBuilder(type, ctx);\n    case Type.Map:\n      return new MapBuilder(type, ctx);\n    case Type.RunEndEncoded:\n      return new RunEndEncodedBuilder(type, ctx);\n\n    case Type.Dictionary:\n      return new DictionaryBuilder(type, ctx);\n  }\n  // case Type.BinaryView:\n  // case Type.Utf8View:\n  // case Type.ListView:\n  // case Type.LargeListView:\n  throw new Error(invalidDataType(typeId));\n}\n","import { NullBatch } from '../batch.js';\nimport { Column } from '../column.js';\nimport { inferType } from './infer-type.js';\nimport { builder, builderContext } from './builder.js';\nimport { Type } from '../constants.js';\nimport { isIterable } from '../util/objects.js';\n\n/**\n * Create a new column by iterating over provided values.\n * @template T\n * @param {Iterable | ((callback: (value: any) => void) => void)} values\n *  Either an iterable object or a visitor function that applies a callback\n *  to successive data values (akin to Array.forEach).\n * @param {import('../types.js').DataType} [type] The data type.\n * @param {import('../types.js').ColumnBuilderOptions} [options]\n *  Builder options for the generated column.\n * @param {ReturnType<\n *    import('./builders/dictionary.js').dictionaryContext\n *  >} [dicts] Dictionary context object, for internal use only.\n * @returns {Column<T>} The generated column.\n */\nexport function columnFromValues(values, type, options = {}, dicts) {\n  const visit = isIterable(values)\n    ? callback => { for (const value of values) callback(value); }\n    : values;\n\n  type ??= inferType(visit);\n  const { maxBatchRows = Infinity, ...opt } = options;\n  let data;\n\n  if (type.typeId === Type.Null) {\n    let length = 0;\n    visit(() => ++length);\n    data = nullBatches(type, length, maxBatchRows);\n  } else {\n    const ctx = builderContext(opt, dicts);\n    const b = builder(type, ctx).init();\n    const next = b => data.push(b.batch());\n    data = [];\n\n    let row = 0;\n    visit(value => {\n      b.set(value, row++);\n      if (row >= maxBatchRows) {\n        next(b);\n        row = 0;\n      }\n    });\n    if (row) next(b);\n\n    // resolve dictionaries\n    ctx.finish();\n  }\n\n  return new Column(data, type);\n}\n\n/**\n * Create null batches with the given batch size limit.\n * @param {import('../types.js').NullType} type The null data type.\n * @param {number} length The total column length.\n * @param {number} limit The maximum batch size.\n * @returns {import('../batch.js').NullBatch[]} The null batches.\n */\nfunction nullBatches(type, length, limit) {\n  const data = [];\n  const batch = length => new NullBatch({ length, nullCount: length, type });\n  const numBatches = Math.floor(length / limit);\n  for (let i = 0; i < numBatches; ++i) {\n    data.push(batch(limit));\n  }\n  const rem = length % limit;\n  if (rem) data.push(batch(rem));\n  return data;\n}\n","import { float32Array, float64Array, int16Array, int32Array, int64Array, int8Array, isInt64ArrayType, isTypedArray, uint16Array, uint32Array, uint64Array, uint8Array } from '../util/arrays.js';\nimport { DirectBatch, Int64Batch } from '../batch.js';\nimport { Column } from '../column.js';\nimport { float32, float64, int16, int32, int64, int8, uint16, uint32, uint64, uint8 } from '../data-types.js';\nimport { columnFromValues } from './column-from-values.js';\n\n/**\n * Create a new column from a provided data array.\n * @template T\n * @param {Array | import('../types.js').TypedArray} array The input data.\n * @param {import('../types.js').DataType} [type] The data type.\n *  If not specified, type inference is attempted.\n * @param {import('../types.js').ColumnBuilderOptions} [options]\n *  Builder options for the generated column.\n * @param {ReturnType<import('./builders/dictionary.js').dictionaryContext>} [dicts]\n *  Builder context object, for internal use only.\n * @returns {Column<T>} The generated column.\n */\nexport function columnFromArray(array, type, options = {}, dicts) {\n  return !type && isTypedArray(array)\n    ? columnFromTypedArray(array, options)\n    : columnFromValues(v => array.forEach(v), type, options, dicts);\n}\n\n/**\n * Create a new column from a typed array input.\n * @template T\n * @param {import('../types.js').TypedArray} values The input data.\n * @param {import('../types.js').ColumnBuilderOptions} options\n *  Builder options for the generated column.\n * @returns {Column<T>} The generated column.\n */\nfunction columnFromTypedArray(values, { maxBatchRows, useBigInt }) {\n  const arrayType = /** @type {import('../types.js').TypedArrayConstructor} */ (\n    values.constructor\n  );\n  const type = typeForTypedArray(arrayType);\n  const length = values.length;\n  const limit = Math.min(maxBatchRows || Infinity, length);\n  const numBatches = Math.floor(length / limit);\n\n  const batches = [];\n  const batchType = isInt64ArrayType(arrayType) && !useBigInt ? Int64Batch : DirectBatch;\n  const add = (start, end) => batches.push(new batchType({\n    length: end - start,\n    nullCount: 0,\n    type,\n    validity: new uint8Array(0),\n    values: values.subarray(start, end)\n  }));\n\n  let idx = 0;\n  for (let i = 0; i < numBatches; ++i) add(idx, idx += limit);\n  if (idx < length) add(idx, length);\n\n  return new Column(batches);\n}\n\n/**\n * Return an Arrow data type for a given typed array type.\n * @param {import('../types.js').TypedArrayConstructor} arrayType\n *  The typed array type.\n * @returns {import('../types.js').DataType} The data type.\n */\nfunction typeForTypedArray(arrayType) {\n  switch (arrayType) {\n    case float32Array: return float32();\n    case float64Array: return float64();\n    case int8Array: return int8();\n    case int16Array: return int16();\n    case int32Array: return int32();\n    case int64Array: return int64();\n    case uint8Array: return uint8();\n    case uint16Array: return uint16();\n    case uint32Array: return uint32();\n    case uint64Array: return uint64();\n  }\n}\n","import { isFunction } from '../../util/is-function.js';\n\n/**\n * Return a potentially filtered list of column names.\n * @param {import('../../table/Table.js').Table} table A data table.\n * @param {import('../types.js').ColumnSelectOptions} names The column names to select.\n * @returns {string[]} The selected column names.\n */\nexport function columns(table, names) {\n  // @ts-ignore\n  return isFunction(names) ? names(table)\n    : names || table.columnNames();\n}\n","import { columnFromArray, columnFromValues, tableFromColumns } from '@uwdata/flechette';\nimport { isArrayType } from '../util/is-array-type.js';\nimport { isFunction } from '../util/is-function.js';\nimport { columns as select } from './util/columns.js';\n\n/**\n * Create an Apache Arrow table for an input table.\n * @param {import('../table/Table.js').Table} table\n *  An input Arquero table to convert to Arrow format.\n * @param {import('./types.js').ArrowFormatOptions} [options]\n *  Encoding options, including column data types.\n * @return {import('@uwdata/flechette').Table} An Arrow Table instance.\n */\nexport function toArrow(table, options = {}) {\n  const { columns, limit = Infinity, offset = 0, types = {}, ...opt } = options;\n  const names = select(table, columns);\n  const data = table.data();\n\n  // make a full table scan with no indirection?\n  const fullScan = offset === 0\n    && table.numRows() <= limit\n    && !table.isFiltered()\n    && !table.isOrdered();\n\n  return tableFromColumns(names.map(name => {\n    const values = data[name];\n    const type = types[name];\n    const isArray = isArrayType(values);\n    let col;\n    if (fullScan && (isArray || isFunction(values.toArray))) {\n      // @ts-ignore - use faster path, takes advantange of typed arrays\n      col = columnFromArray(isArray ? values : values.toArray(), type, opt);\n    } else {\n      // use table scan method to visit column values\n      const get = isArray\n        ? row => values[row]\n        : row => values.at(row);\n      col = columnFromValues(\n        visit => table.scan(row => visit(get(row)), true, limit, offset),\n        type,\n        opt\n      );\n    }\n    return [name, col];\n  }));\n}\n","import { Endianness, Version } from '../constants.js';\nimport { field } from '../data-types.js';\nimport { Table } from '../table.js';\n\n/**\n * Create a new table from a collection of columns. Columns are assumed\n * to have the same record batch sizes.\n * @param {[string, import('../column.js').Column][]\n *  | Record<string, import('../column.js').Column>} data The columns,\n *  as an object with name keys, or an array of [name, column] pairs.\n * @param {boolean} [useProxy] Flag indicating if row proxy\n *  objects should be used to represent table rows (default `false`).\n * @returns {Table} The new table.\n */\nexport function tableFromColumns(data, useProxy) {\n  const fields = [];\n  const entries = Array.isArray(data) ? data : Object.entries(data);\n  const length = entries[0]?.[1].length;\n\n  const columns = entries.map(([name, col]) => {\n    if (col.length !== length) {\n      throw new Error('All columns must have the same length.');\n    }\n    fields.push(field(name, col.type));\n    return col;\n  });\n\n  const schema = {\n    version: Version.V5,\n    endianness: Endianness.Little,\n    fields,\n    metadata: null\n  };\n\n  return new Table(schema, columns, useProxy);\n}\n","import { tableToIPC } from '@uwdata/flechette';\nimport { toArrow } from './to-arrow.js';\n\n/**\n * Format a table as binary data in the Apache Arrow IPC format.\n * @param {import('../table/Table.js').Table} data The table data\n * @param {import('./types.js').ArrowIPCFormatOptions} [options]\n *  The Arrow IPC formatting options. Set the *format* option to `'stream'`\n *  or `'file'` to specify the IPC format.\n * @return {Uint8Array} A new Uint8Array of Arrow-encoded binary data.\n */\nexport function toArrowIPC(data, options = {}) {\n  const { format = 'stream', ...toArrowOptions } = options;\n  return tableToIPC(toArrow(data, toArrowOptions), { format });\n}\n","export function identity(x) {\n  return x;\n}\n","import { identity } from '../../util/identity.js';\n\nexport function scan(table, names, limit = 100, offset, ctx) {\n  const { start = identity, cell, end = identity } = ctx;\n  const data = table.data();\n  const n = names.length;\n  table.scan(row => {\n    start(row);\n    for (let i = 0; i < n; ++i) {\n      const name = names[i];\n      cell(data[name].at(row), name, i);\n    }\n    end(row);\n  }, true, limit, offset);\n}\n","import { formatUTCDate } from '../util/format-date.js';\nimport { isDate } from '../util/is-date.js';\nimport { columns } from './util/columns.js';\nimport { scan } from './util/scan.js';\n\n/**\n * Options for CSV formatting.\n * @typedef {object} CSVFormatOptions\n * @property {string} [delimiter=','] The delimiter between values.\n * @property {boolean} [header=true] Flag to specify presence of header row.\n *  If true, includes a header row with column names.\n *  If false, the header is omitted.\n * @property {number} [limit=Infinity] The maximum number of rows to print.\n * @property {number} [offset=0] The row offset indicating how many initial rows to skip.\n * @property {import('./types.js').ColumnSelectOptions} [columns] Ordered list\n *  of column names to include. If function-valued, the function should\n *  accept a table as input and return an array of column name strings.\n * @property {Object.<string, (value: any) => any>} [format] Object of column\n *  format options. The object keys should be column names. The object values\n *  should be formatting functions to invoke to transform column values prior\n *  to output. If specified, these override automatically inferred options.\n */\n\n/**\n * Format a table as a comma-separated values (CSV) string. Other\n * delimiters, such as tabs or pipes ('|'), can be specified using\n * the options argument.\n * @param {import('../table/Table.js').Table} table The table to format.\n * @param {CSVFormatOptions} options The formatting options.\n * @return {string} A delimited-value format string.\n */\nexport function toCSV(table, options = {}) {\n  const names = columns(table, options.columns);\n  const format = options.format || {};\n  const delim = options.delimiter || ',';\n  const header = options.header ?? true;\n  const reFormat = new RegExp(`[\"${delim}\\n\\r]`);\n\n  const formatValue = value => value == null ? ''\n    : isDate(value) ? formatUTCDate(value, true)\n    : reFormat.test(value += '') ? '\"' + value.replace(/\"/g, '\"\"') + '\"'\n    : value;\n\n  const vals = names.map(formatValue);\n  let text = header ? (vals.join(delim) + '\\n') : '';\n\n  scan(table, names, options.limit || Infinity, options.offset, {\n    cell(value, name, index) {\n      vals[index] = formatValue(format[name] ? format[name](value) : value);\n    },\n    end() {\n      text += vals.join(delim) + '\\n';\n    }\n  });\n\n  return text;\n}\n","import { inferFormat } from './infer.js';\n\nexport function formats(table, names, options) {\n  const formatOpt = options.format || {};\n  const alignOpt = options.align || {};\n  const format = {};\n  const align = {};\n\n  names.forEach(name => {\n    const auto = inferFormat(values(table, name), options);\n    align[name] = alignOpt[name] || auto.align;\n    format[name] = formatOpt[name] || auto.format;\n  });\n\n  return { align, format };\n}\n\nfunction values(table, columnName) {\n  const column = table.column(columnName);\n  return fn => table.scan(row => fn(column.at(row)));\n}\n","import { isDate } from '../../util/is-date.js';\n\nfunction isExactDateUTC(d) {\n  return d.getUTCHours() === 0\n    && d.getUTCMinutes() === 0\n    && d.getUTCSeconds() === 0\n    && d.getUTCMilliseconds() === 0;\n}\n\nexport function inferFormat(scan, options = {}) {\n  let count = 0;\n  let nulls = 0;\n  let dates = 0;\n  let dutcs = 0;\n  let nums = 0;\n  let digits = 0;\n\n  scan(value => {\n    ++count;\n    if (value == null) {\n      ++nulls;\n      return;\n    }\n\n    const type = typeof value;\n    if (type === 'object' && isDate(value)) {\n      ++dates;\n      if (isExactDateUTC(value)) ++dutcs;\n    } else if (type === 'number') {\n      ++nums;\n      if (value === value &&  (value | 0) !== value) {\n        const s = value + '';\n        const p = s.indexOf('.');\n        if (p >= 0) {\n          const e = s.indexOf('e');\n          const l = e > 0 ? e : s.length;\n          digits = Math.max(digits, l - p - 1);\n        }\n      }\n    }\n  });\n\n  return {\n    align:  (nulls + nums + dates) / count > 0.5 ? 'r' : 'l',\n    format: {\n      utc:    dates === dutcs,\n      digits: Math.min(digits, options.maxdigits || 6)\n    }\n  };\n}\n","import { formatDate, formatUTCDate } from '../../util/format-date.js';\nimport { isDate } from '../../util/is-date.js';\nimport { isFunction } from '../../util/is-function.js';\nimport { isTypedArray } from '../../util/is-typed-array.js';\n\n/**\n * Format a value as a string.\n * @param {*} v The value to format.\n * @param {import('../types.js').ValueFormatOptions} options Formatting options.\n * @return {string} The formatted string.\n */\nexport function formatValue(v, options = {}) {\n  if (isFunction(options)) {\n    // @ts-ignore\n    return options(v) + '';\n  }\n\n  const type = typeof v;\n\n  if (type === 'object') {\n    if (isDate(v)) {\n      // @ts-ignore\n      return options.utc ? formatUTCDate(v) : formatDate(v);\n    } else {\n      const s = JSON.stringify(\n        v,\n        // @ts-ignore\n        (k, v) => isTypedArray(v) ? Array.from(v) : v\n      );\n      // @ts-ignore\n      const maxlen = options.maxlen || 30;\n      return s.length > maxlen\n        ? s.slice(0, 28) + '\\u2026' + (s[0] === '[' ? ']' : '}')\n        : s;\n    }\n  } else if (type === 'number') {\n    // @ts-ignore\n    const digits = options.digits || 0;\n    let a;\n    return v !== 0 && ((a = Math.abs(v)) >= 1e18 || a < Math.pow(10, -digits))\n      ? v.toExponential(digits)\n      : v.toFixed(digits);\n  } else {\n    return v + '';\n  }\n}\n","import { isFunction } from '../util/is-function.js';\nimport { mapObject } from '../util/map-object.js';\nimport { columns } from './util/columns.js';\nimport { formats } from './util/formats.js';\nimport { formatValue } from './util/format-value.js';\nimport { scan } from './util/scan.js';\n\n/**\n * Null format function.\n * @callback NullFormat\n * @param {null|undefined} [value] The value to format.\n * @return {string} The formatted HTML string.\n */\n\n/**\n * CSS style function.\n * @callback StyleFunction\n * @param {string} name The column name.\n * @param {number} row The table row index.\n * @return {string} A CSS style string.\n */\n\n/**\n * CSS style options.\n * @typedef {Object.<string, string | StyleFunction>} StyleOptions\n */\n\n/**\n * Options for HTML formatting.\n * @typedef {object} HTMLFormatOptions\n * @property {number} [limit=Infinity] The maximum number of rows to print.\n * @property {number} [offset=0] The row offset indicating how many initial rows to skip.\n * @property {import('./types.js').ColumnSelectOptions} [columns] Ordered list\n *  of column names to include. If function-valued, the function should\n *  accept a table as input and return an array of column name strings.\n * @property {import('./types.js').ColumnAlignOptions} [align] Object of column\n *  alignment options. The object keys should be column names. The object\n *  values should be aligment strings, one of 'l' (left), 'c' (center), or\n *  'r' (right). If specified, these override automatically inferred options.\n * @property {import('./types.js').ColumnFormatOptions} [format] Object of column\n *  format options. The object keys should be column names. The object values\n *  should be formatting functions or specification objects. If specified,\n *  these override automatically inferred options.\n * @property {NullFormat} [null] Format function for null or undefined values.\n *  If specified, this function will be invoked with the null or undefined\n *  value as the sole input, and the return value will be used as the HTML\n *  output for the value.\n * @property {StyleOptions} [style] CSS styles to include in HTML output.\n *  The object keys should be HTML table tag names: 'table', 'thead',\n *  'tbody', 'tr', 'th', or 'td'. The object values should be strings of\n *  valid CSS style directives (such as \"font-weight: bold;\") or functions\n *  that take a column name and row as inputs and return a CSS string.\n * @property {number} [maxdigits=6] The maximum number of fractional digits\n *  to include when formatting numbers. This option is passed to the format\n *  inference method and is overridden by any explicit format options.\n */\n\n/**\n * Format a table as an HTML table string.\n * @param {import('../table/Table.js').Table} table The table to format.\n * @param {HTMLFormatOptions} options The formatting options.\n * @return {string} An HTML table string.\n */\nexport function toHTML(table, options = {}) {\n  const names = columns(table, options.columns);\n  const { align, format } = formats(table, names, options);\n  const style = styles(options);\n  const nullish = options.null;\n\n  const alignValue = a => a === 'c' ? 'center' : a === 'r' ? 'right' : 'left';\n  const escape = s => s.replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n  const baseFormat = (value, opt) => escape(formatValue(value, opt));\n  const formatter = nullish\n    ? (value, opt) => value == null ? nullish(value) : baseFormat(value, opt)\n    : baseFormat;\n\n  let r = -1;\n  let idx = -1;\n\n  const tag = (tag, name, shouldAlign) => {\n    const a = shouldAlign ? alignValue(align[name]) : '';\n    const s = style[tag] ? (style[tag](name, idx, r) || '') : '';\n    const css = (a ? (`text-align: ${a};` + (s ? ' ' : '')) : '') + s;\n    return `<${tag}${css ? ` style=\"${css}\"` : ''}>`;\n  };\n\n  let text = tag('table')\n    + tag('thead')\n    + tag('tr', r)\n    + names.map(name => `${tag('th', name, 1)}${name}</th>`).join('')\n    + '</tr></thead>'\n    + tag('tbody');\n\n  scan(table, names, options.limit, options.offset, {\n    start(row) {\n      r = row;\n      ++idx;\n      text += tag('tr');\n    },\n    cell(value, name) {\n      text += tag('td', name, 1)\n        + formatter(value, format[name])\n        + '</td>';\n    },\n    end() {\n      text += '</tr>';\n    }\n  });\n\n  return text + '</tbody></table>';\n}\n\nfunction styles(options) {\n  return mapObject(\n    options.style,\n    value => isFunction(value) ? value : () => value\n  );\n}\n","export function mapObject(obj, fn, output = {}) {\n  for (const key in obj) {\n    output[key] = fn(obj[key], key);\n  }\n  return output;\n}\n","export const EOL = {};\nexport const BREAK = {};\nexport const QUOTE = 34;\nexport const NEWLINE = 10;\nexport const RETURN = 13;\n\nexport const COLUMNS = 'columns';\nexport const NDJSON = 'ndjson';\nexport const ROWS = 'rows';\n","import { formatUTCDate } from '../util/format-date.js';\nimport { identity } from '../util/identity.js';\nimport { isDate } from '../util/is-date.js';\nimport { COLUMNS, NDJSON } from './stream/constants.js';\nimport { columns } from './util/columns.js';\n\n/**\n * Options for JSON formatting.\n * @typedef {object} JSONFormatOptions\n * @property {'columns' | 'rows' | 'ndjson' | null} [type] The format type.\n *  One of `'columns'` (for an object with named column arrays)`, 'rows'` (for\n *  an array for row objects), or `'ndjson'` for [newline-delimited JSON][1]\n *  rows. For `'ndjson'`, each line of text will contain a JSON row object\n *  (with no trailing comma) and string properties will be stripped of any\n *  newline characters. If no format type is specified, defaults to `'rows'`.\n *\n *  [1]: https://github.com/ndjson/ndjson-spec\n * @property {number} [limit=Infinity] The maximum number of rows to print.\n * @property {number} [offset=0] The row offset indicating how many initial\n *  rows to skip.\n * @property {import('./types.js').ColumnSelectOptions} [columns] Ordered list\n *  of column names to include. If function-valued, the function should\n *  accept a table as input and return an array of column name strings.\n * @property {Object.<string, (value: any) => any>} [format] Object of column\n *  format options. The object keys should be column names. The object values\n *  should be formatting functions to invoke to transform column values prior\n *  to output. If specified, these override automatically inferred options.\n */\n\nconst defaultFormatter = value => isDate(value)\n  ? formatUTCDate(value, true)\n  : value;\n\n/**\n * Format a table as a JavaScript Object Notation (JSON) string.\n * @param {import('../table/Table.js').Table} table The table to format.\n * @param {JSONFormatOptions} options The formatting options.\n * @return {string} A JSON string.\n */\nexport function toJSON(table, {\n  type,\n  columns: cols,\n  format = {},\n  limit,\n  offset\n} = {}) {\n  const names = columns(table, cols);\n  const fmt = names.map(name => format[name] || defaultFormatter);\n  const scan = fn => table.scan(fn, true, limit, offset);\n\n  return type === COLUMNS\n    ? toColumns(table, names, fmt, scan)\n    : toRows(table, names, fmt, scan, type === NDJSON);\n}\n\nfunction toColumns(table, names, format, scan) {\n  let text = '{';\n\n  names.forEach((name, i) => {\n    text += (i ? ',' : '') + JSON.stringify(name) + ':[';\n\n    const column = table.column(name);\n    const formatter = format[i];\n    let r = -1;\n    scan(row => {\n      const value = column.at(row);\n      text += (++r ? ',' : '') + JSON.stringify(formatter(value));\n    });\n\n    text += ']';\n  });\n\n  return text + '}';\n}\n\nfunction toRows(table, names, format, scan, nd = false) {\n  const n = names.length;\n  const keys = names.map(name => `\"${name}\":`);\n  const cols = names.map(name => table.column(name));\n\n  const finish = nd ? o => o.replaceAll('\\n', '') : identity;\n  const sep = nd ? '\\n' : ',';\n  let text = nd ? '' : '[';\n\n  let r = -1;\n  scan(row => {\n    const props = [];\n    for (let i = 0; i < n; ++i) {\n      props.push(keys[i] + JSON.stringify(format[i](cols[i].at(row))));\n    }\n    text += (++r ? sep : '') + finish(`{${props.join(',')}}`);\n  });\n\n  return text + (nd ? '' : ']');\n}\n","import { columns } from './util/columns.js';\nimport { formats } from './util/formats.js';\nimport { formatValue } from './util/format-value.js';\nimport { scan } from './util/scan.js';\n\n/**\n * Options for Markdown formatting.\n * @typedef {object} MarkdownFormatOptions\n * @property {number} [limit=Infinity] The maximum number of rows to print.\n * @property {number} [offset=0] The row offset indicating how many initial\n *  rows to skip.\n * @property {import('./types.js').ColumnSelectOptions} [columns] Ordered list\n *  of column names to include. If function-valued, the function should\n *  accept a table as input and return an array of column name strings.\n * @property {import('./types.js').ColumnAlignOptions} [align] Object of column\n *  alignment options. The object keys should be column names. The object\n *  values should be aligment strings, one of 'l' (left), 'c' (center), or\n *  'r' (right). If specified, these override automatically inferred options.\n * @property {import('./types.js').ColumnFormatOptions} [format] Object of column\n *  format options. The object keys should be column names. The object values\n *  should be formatting functions or specification objects. If specified,\n *  these override automatically inferred options.\n * @property {number} [maxdigits=6] The maximum number of fractional digits\n *  to include when formatting numbers. This option is passed to the format\n *  inference method and is overridden by any explicit format options.\n */\n\n/**\n * Format a table as a GitHub-Flavored Markdown table string.\n * @param {import('../table/Table.js').Table} table The table to format.\n * @param {MarkdownFormatOptions} options The formatting options.\n * @return {string} A GitHub-Flavored Markdown table string.\n */\nexport function toMarkdown(table, options = {}) {\n  const names = columns(table, options.columns);\n  const { align, format } = formats(table, names, options);\n\n  const alignValue = a => a === 'c' ? ':-:' : a === 'r' ? '-:' : ':-';\n  const escape = s => s.replace(/\\|/g, '\\\\|');\n\n  let text = '|'\n    + names.map(escape).join('|')\n    + '|\\n|'\n    + names.map(name => alignValue(align[name])).join('|')\n    + '|\\n';\n\n  scan(table, names, options.limit, options.offset, {\n    start() {\n      text += '|';\n    },\n    cell(value, name) {\n      text += escape(formatValue(value, format[name])) + '|';\n    },\n    end() {\n      text += '\\n';\n    }\n  });\n\n  return text;\n}\n","import { Table } from './Table.js';\nimport {\n  antijoin,\n  assign,\n  concat,\n  cross,\n  dedupe,\n  derive,\n  except,\n  filter,\n  fold,\n  groupby,\n  impute,\n  intersect,\n  join,\n  lookup,\n  orderby,\n  pivot,\n  reduce,\n  relocate,\n  rename,\n  rollup,\n  sample,\n  select,\n  semijoin,\n  slice,\n  spread,\n  ungroup,\n  union,\n  unorder,\n  unroll\n} from '../verbs/index.js';\nimport { count } from '../op/op-api.js';\nimport { toArrow } from '../format/to-arrow.js';\nimport { toArrowIPC } from '../format/to-arrow-ipc.js';\nimport { toCSV } from '../format/to-csv.js';\nimport { toHTML } from '../format/to-html.js';\nimport { toJSON } from '../format/to-json.js';\nimport { toMarkdown } from '../format/to-markdown.js';\nimport { toArray } from '../util/to-array.js';\n\n/**\n * A data table with transformation verbs.\n */\nexport class ColumnTable extends Table {\n  /**\n   * Create a new table with additional columns drawn from one or more input\n   * tables. All tables must have the same numer of rows and are reified\n   * prior to assignment. In the case of repeated column names, input table\n   * columns overwrite existing columns.\n   * @param {...(Table|import('./types.js').ColumnData)} tables\n   *  The tables to merge with this table.\n   * @return {this} A new table with merged columns.\n   * @example table.assign(table1, table2)\n   */\n  assign(...tables) {\n    return assign(this, ...tables);\n  }\n\n  /**\n   * Count the number of values in a group. This method is a shorthand\n   * for *rollup* with a count aggregate function.\n   * @param {import('./types.js').CountOptions} [options]\n   *  Options for the count.\n   * @return {this} A new table with groupby and count columns.\n   * @example table.groupby('colA').count()\n   * @example table.groupby('colA').count({ as: 'num' })\n   */\n  count(options = {}) {\n    const { as = 'count' } = options;\n    return rollup(this, { [as]: count() });\n  }\n\n  /**\n   * Derive new column values based on the provided expressions. By default,\n   * new columns are added after (higher indices than) existing columns. Use\n   * the before or after options to place new columns elsewhere.\n   * @param {import('./types.js').ExprObject} values\n   *  Object of name-value pairs defining the columns to derive. The input\n   *  object should have output column names for keys and table expressions\n   *  for values.\n   * @param {import('./types.js').DeriveOptions} [options]\n   *  Options for dropping or relocating derived columns. Use either a before\n   *  or after property to indicate where to place derived columns. Specifying\n   *  both before and after is an error. Unlike the *relocate* verb, this\n   *  option affects only new columns; updated columns with existing names\n   *  are excluded from relocation.\n   * @return {this} A new table with derived columns added.\n   * @example table.derive({ sumXY: d => d.x + d.y })\n   * @example table.derive({ z: d => d.x * d.y }, { before: 'x' })\n   */\n  derive(values, options) {\n    return derive(this, values, options);\n  }\n\n  /**\n   * Filter a table to a subset of rows based on the input criteria.\n   * The resulting table provides a filtered view over the original data; no\n   * data copy is made. To create a table that copies only filtered data to\n   * new data structures, call *reify* on the output table.\n   * @param {import('./types.js').TableExpr} criteria\n   *  Filter criteria as a table expression. Both aggregate and window\n   *  functions are permitted, taking into account *groupby* or *orderby*\n   *  settings.\n   * @return {this} A new table with filtered rows.\n   * @example table.filter(d => abs(d.value) < 5)\n   */\n  filter(criteria) {\n    return filter(this, criteria);\n  }\n\n  /**\n   * Extract rows with indices from start to end (end not included), where\n   * start and end represent per-group ordered row numbers in the table.\n   * @param {number} [start] Zero-based index at which to start extraction.\n   *  A negative index indicates an offset from the end of the group.\n   *  If start is undefined, slice starts from the index 0.\n   * @param {number} [end] Zero-based index before which to end extraction.\n   *  A negative index indicates an offset from the end of the group.\n   *  If end is omitted, slice extracts through the end of the group.\n   * @return {this} A new table with sliced rows.\n   * @example table.slice(1, -1)\n   */\n  slice(start, end) {\n    return slice(this, start, end);\n  }\n\n  /**\n   * Group table rows based on a set of column values.\n   * Subsequent operations that are sensitive to grouping (such as\n   * aggregate functions) will operate over the grouped rows.\n   * To undo grouping, use *ungroup*.\n   * @param  {...import('./types.js').ExprList} keys\n   *  Key column values to group by. The keys may be specified using column\n   *  name strings, column index numbers, value objects with output column\n   *  names for keys and table expressions for values, or selection helper\n   *  functions.\n   * @return {this} A new table with grouped rows.\n   * @example table.groupby('colA', 'colB')\n   * @example table.groupby({ key: d => d.colA + d.colB })\n   */\n  groupby(...keys) {\n    return groupby(this, ...keys);\n  }\n\n  /**\n   * Order table rows based on a set of column values. Subsequent operations\n   * sensitive to ordering (such as window functions) will operate over sorted\n   * values. The resulting table provides an view over the original data,\n   * without any copying. To create a table with sorted data copied to new\n   * data strucures, call *reify* on the result of this method. To undo\n   * ordering, use *unorder*.\n   * @param  {...import('./types.js').OrderKeys} keys\n   *  Key values to sort by, in precedence order.\n   *  By default, sorting is done in ascending order.\n   *  To sort in descending order, wrap values using *desc*.\n   *  If a string, order by the column with that name.\n   *  If a number, order by the column with that index.\n   *  If a function, must be a valid table expression; aggregate functions\n   *  are permitted, but window functions are not.\n   *  If an object, object values must be valid values parameters\n   *  with output column names for keys and table expressions\n   *  for values (the output names will be ignored).\n   *  If an array, array values must be valid key parameters.\n   * @return {this} A new ordered table.\n   * @example table.orderby('a', desc('b'))\n   * @example table.orderby({ a: 'a', b: desc('b') )})\n   * @example table.orderby(desc(d => d.a))\n   */\n  orderby(...keys) {\n    return orderby(this, ...keys);\n  }\n\n  /**\n   * Relocate a subset of columns to change their positions, also\n   * potentially renaming them.\n   * @param {import('./types.js').Select} columns\n   *  An ordered selection of columns to relocate.\n   *  The input may consist of column name strings, column integer indices,\n   *  rename objects with current column names as keys and new column names\n   *  as values, or functions that take a table as input and returns a valid\n   *  selection parameter (typically the output of selection helper functions\n   *  such as *all*, *not*, or *range*).\n   * @param {import('./types.js').RelocateOptions} options\n   *  Options for relocating. Must include either the before or after property\n   *  to indicate where to place the relocated columns. Specifying both before\n   *  and after is an error.\n   * @return {this} A new table with relocated columns.\n   * @example table.relocate(['colY', 'colZ'], { after: 'colX' })\n   * @example table.relocate(not('colB', 'colC'), { before: 'colA' })\n   * @example table.relocate({ colA: 'newA', colB: 'newB' }, { after: 'colC' })\n   */\n  relocate(columns, options) {\n    return relocate(this, toArray(columns), options);\n  }\n\n  /**\n   * Rename one or more columns, preserving column order.\n   * @param {...import('./types.js').Select} columns\n   *  One or more rename objects with current column names as keys and new\n   *  column names as values.\n   * @return {this} A new table with renamed columns.\n   * @example table.rename({ oldName: 'newName' })\n   * @example table.rename({ a: 'a2', b: 'b2' })\n   */\n  rename(...columns) {\n    return rename(this, ...columns);\n  }\n\n  /**\n   * Reduce a table, processing all rows to produce a new table.\n   * To produce standard aggregate summaries, use the rollup verb.\n   * This method allows the use of custom reducer implementations,\n   * for example to produce multiple rows for an aggregate.\n   * @param {import('../verbs/reduce/reducer.js').Reducer} reducer\n   *  The reducer to apply.\n   * @return {this} A new table of reducer outputs.\n   */\n  reduce(reducer) {\n    return reduce(this, reducer);\n  }\n\n  /**\n   * Rollup a table to produce an aggregate summary.\n   * Often used in conjunction with *groupby*.\n   * To produce counts only, *count* is a shortcut.\n   * @param {import('./types.js').ExprObject} [values]\n   *  Object of name-value pairs defining aggregate output columns. The input\n   *  object should have output column names for keys and table expressions\n   *  for values. The expressions must be valid aggregate expressions: window\n   *  functions are not allowed and column references must be arguments to\n   *  aggregate functions.\n   * @return {this} A new table of aggregate summary values.\n   * @example table.groupby('colA').rollup({ mean: d => mean(d.colB) })\n   * @example table.groupby('colA').rollup({ mean: op.median('colB') })\n   */\n  rollup(values) {\n    return rollup(this, values);\n  }\n\n  /**\n   * Generate a table from a random sample of rows.\n   * If the table is grouped, performs a stratified sample by\n   * sampling from each group separately.\n   * @param {number | import('./types.js').TableExpr} size\n   *  The number of samples to draw per group.\n   *  If number-valued, the same sample size is used for each group.\n   *  If function-valued, the input should be an aggregate table\n   *  expression compatible with *rollup*.\n   * @param {import('./types.js').SampleOptions} [options]\n   *  Options for sampling.\n   * @return {this} A new table with sampled rows.\n   * @example table.sample(50)\n   * @example table.sample(100, { replace: true })\n   * @example table.groupby('colA').sample(() => op.floor(0.5 * op.count()))\n   */\n  sample(size, options) {\n    return sample(this, size, options);\n  }\n\n  /**\n   * Select a subset of columns into a new table, potentially renaming them.\n   * @param {...import('./types.js').Select} columns\n   *  An ordered selection of columns.\n   *  The input may consist of column name strings, column integer indices,\n   *  rename objects with current column names as keys and new column names\n   *  as values, or functions that take a table as input and returns a valid\n   *  selection parameter (typically the output of selection helper functions\n   *  such as *all*, *not*, or *range*.).\n   * @return {this} A new table of selected columns.\n   * @example table.select('colA', 'colB')\n   * @example table.select(not('colB', 'colC'))\n   * @example table.select({ colA: 'newA', colB: 'newB' })\n   */\n  select(...columns) {\n    return select(this, ...columns);\n  }\n\n  /**\n   * Ungroup a table, removing any grouping criteria.\n   * Undoes the effects of *groupby*.\n   * @return {this} A new ungrouped table, or this table if not grouped.\n   * @example table.ungroup()\n   */\n  ungroup() {\n    return ungroup(this);\n  }\n\n  /**\n   * Unorder a table, removing any sorting criteria.\n   * Undoes the effects of *orderby*.\n   * @return {this} A new unordered table, or this table if not ordered.\n   * @example table.unorder()\n   */\n  unorder() {\n    return unorder(this);\n  }\n\n  // -- Cleaning Verbs ------------------------------------------------------\n\n  /**\n   * De-duplicate table rows by removing repeated row values.\n   * @param {...import('./types.js').ExprList} keys\n   *  Key columns to check for duplicates.\n   *  Two rows are considered duplicates if they have matching values for\n   *  all keys. If keys are unspecified, all columns are used.\n   *  The keys may be specified using column name strings, column index\n   *  numbers, value objects with output column names for keys and table\n   *  expressions for values, or selection helper functions.\n   * @return {this} A new de-duplicated table.\n   * @example table.dedupe()\n   * @example table.dedupe('a', 'b')\n   * @example table.dedupe({ abs: d => op.abs(d.a) })\n   */\n  dedupe(...keys) {\n    return dedupe(this, ...keys);\n  }\n\n  /**\n   * Impute missing values or rows. Accepts a set of column-expression pairs\n   * and evaluates the expressions to replace any missing (null, undefined,\n   * or NaN) values in the original column.\n   * If the expand option is specified, imputes new rows for missing\n   * combinations of values. All combinations of key values (a full cross\n   * product) are considered for each level of grouping (specified by\n   * *groupby*). New rows will be added for any combination\n   * of key and groupby values not already contained in the table. For all\n   * non-key and non-group columns the new rows are populated with imputation\n   * values (first argument) if specified, otherwise undefined.\n   * If the expand option is specified, any filter or orderby settings are\n   * removed from the output table, but groupby settings persist.\n   * @param {import('./types.js').ExprObject} values\n   *  Object of name-value pairs for the column values to impute. The input\n   *  object should have existing column names for keys and table expressions\n   *  for values. The expressions will be evaluated to determine replacements\n   *  for any missing values.\n   * @param {import('./types.js').ImputeOptions} [options] Imputation options.\n   *  The expand property specifies a set of column values to consider for\n   *  imputing missing rows. All combinations of expanded values are\n   *  considered, and new rows are added for each combination that does not\n   *  appear in the input table.\n   * @return {this} A new table with imputed values and/or rows.\n   * @example table.impute({ v: () => 0 })\n   * @example table.impute({ v: d => op.mean(d.v) })\n   * @example table.impute({ v: () => 0 }, { expand: ['x', 'y'] })\n   */\n  impute(values, options) {\n    return impute(this, values, options);\n  }\n\n  // -- Reshaping Verbs -----------------------------------------------------\n\n  /**\n   * Fold one or more columns into two key-value pair columns.\n   * The fold transform is an inverse of the *pivot* transform.\n   * The resulting table has two new columns, one containing the column\n   * names (named \"key\") and the other the column values (named \"value\").\n   * The number of output rows equals the original row count multiplied\n   * by the number of folded columns.\n   * @param {import('./types.js').ExprList} values The columns to fold.\n   *  The columns may be specified using column name strings, column index\n   *  numbers, value objects with output column names for keys and table\n   *  expressions for values, or selection helper functions.\n   * @param {import('./types.js').FoldOptions} [options] Options for folding.\n   * @return {this} A new folded table.\n   * @example table.fold('colA')\n   * @example table.fold(['colA', 'colB'])\n   * @example table.fold(range(5, 8))\n   */\n  fold(values, options) {\n    return fold(this, values, options);\n  }\n\n  /**\n   * Pivot columns into a cross-tabulation.\n   * The pivot transform is an inverse of the *fold* transform.\n   * The resulting table has new columns for each unique combination\n   * of the provided *keys*, populated with the provided *values*.\n   * The provided *values* must be aggregates, as a single set of keys may\n   * include more than one row. If string-valued, the *any* aggregate is used.\n   * If only one *values* column is defined, the new pivoted columns will\n   * be named using key values directly. Otherwise, input value column names\n   * will be included as a component of the output column names.\n   * @param {import('./types.js').ExprList} keys\n   *  Key values to map to new column names. The keys may be specified using\n   *  column name strings, column index numbers, value objects with output\n   *  column names for keys and table expressions for values, or selection\n   *  helper functions.\n   * @param {import('./types.js').ExprList} values Output values for pivoted\n   *  columns. Column references will be wrapped in an *any* aggregate. If\n   *  object-valued, the input object should have output value names for keys\n   *  and aggregate table expressions for values.\n   * @param {import('./types.js').PivotOptions} [options]\n   *  Options for pivoting.\n   * @return {this} A new pivoted table.\n   * @example table.pivot('key', 'value')\n   * @example table.pivot(['keyA', 'keyB'], ['valueA', 'valueB'])\n   * @example table.pivot({ key: d => d.key }, { value: d => op.sum(d.value) })\n   */\n  pivot(keys, values, options) {\n    return pivot(this, keys, values, options);\n  }\n\n  /**\n   * Spread array elements into a set of new columns.\n   * Output columns are named based on the value key and array index.\n   * @param {import('./types.js').ExprList} values\n   *  The column values to spread. The values may be specified using column\n   *  name strings, column index numbers, value objects with output column\n   *  names for keys and table expressions for values, or selection helper\n   *  functions.\n   * @param {import('./types.js').SpreadOptions } [options]\n   *  Options for spreading.\n   * @return {this} A new table with the spread columns added.\n   * @example table.spread({ a: d => op.split(d.text, '') })\n   * @example table.spread('arrayCol', { limit: 100 })\n   */\n  spread(values, options) {\n    return spread(this, values, options);\n  }\n\n  /**\n   * Unroll one or more array-valued columns into new rows.\n   * If more than one array value is used, the number of new rows\n   * is the smaller of the limit and the largest length.\n   * Values for all other columns are copied over.\n   * @param {import('./types.js').ExprList} values\n   *  The column values to unroll. The values may be specified using column\n   *  name strings, column index numbers, value objects with output column\n   *  names for keys and table expressions for values, or selection helper\n   *  functions.\n   * @param {import('./types.js').UnrollOptions} [options]\n   *  Options for unrolling.\n   * @return {this} A new unrolled table.\n   * @example table.unroll('colA', { limit: 1000 })\n   */\n  unroll(values, options) {\n    return unroll(this, values, options);\n  }\n\n  // -- Joins ---------------------------------------------------------------\n\n  /**\n   * Lookup values from a secondary table and add them as new columns.\n   * A lookup occurs upon matching key values for rows in both tables.\n   * If the secondary table has multiple rows with the same key, only\n   * the last observed instance will be considered in the lookup.\n   * Lookup is similar to *join_left*, but with a simpler\n   * syntax and the added constraint of allowing at most one match only.\n   * @param {import('./types.js').TableRef} other\n   *  The secondary table to look up values from.\n   * @param {import('./types.js').JoinKeys} [on]\n   *  Lookup keys (column name strings or table expressions) for this table\n   *  and the secondary table, respectively. If unspecified, the values of\n   *  all columns with matching names are compared.\n   * @param {...import('./types.js').ExprList} [values]\n   *  The column values to add from the secondary table. Can be column name\n   *  strings or objects with column names as keys and table expressions as\n   *  values. If unspecified, includes all columns from the secondary table\n   *  whose names do no match any column in the primary table.\n   * @return {this} A new table with lookup values added.\n   * @example table.lookup(other, ['key1', 'key2'], 'value1', 'value2')\n   */\n  lookup(other, on, ...values) {\n    return lookup(this, other, on, ...values);\n  }\n\n  /**\n   * Join two tables, extending the columns of one table with\n   * values from the other table. The current table is considered\n   * the \"left\" table in the join, and the new table input is\n   * considered the \"right\" table in the join. By default an inner\n   * join is performed, removing all rows that do not match the\n   * join criteria. To perform left, right, or full outer joins, use\n   * the *join_left*, *join_right*, or *join_full* methods, or provide\n   * an options argument.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinPredicate} [on]\n   *  The join criteria for matching table rows. If unspecified, the values of\n   *  all columns with matching names are compared.\n   *  If array-valued, a two-element array should be provided, containing\n   *  the columns to compare for the left and right tables, respectively.\n   *  If a one-element array or a string value is provided, the same\n   *  column names will be drawn from both tables.\n   *  If function-valued, should be a two-table table expression that\n   *  returns a boolean value. When providing a custom predicate, note that\n   *  join key values can be arrays or objects, and that normal join\n   *  semantics do not consider null or undefined values to be equal (that is,\n   *  null !== null). Use the op.equal function to handle these cases.\n   * @param {import('./types.js').JoinValues} [values]\n   *  The columns to include in the join output.\n   *  If unspecified, all columns from both tables are included; paired\n   *  join keys sharing the same column name are included only once.\n   *  If array-valued, a two element array should be provided, containing\n   *  the columns to include for the left and right tables, respectively.\n   *  Array input may consist of column name strings, objects with output\n   *  names as keys and single-table table expressions as values, or the\n   *  selection helper functions *all*, *not*, or *range*.\n   *  If object-valued, specifies the key-value pairs for each output,\n   *  defined using two-table table expressions.\n   * @param {import('./types.js').JoinOptions} [options]\n   *  Options for the join.\n   * @return {this} A new joined table.\n   * @example table.join(other, ['keyL', 'keyR'])\n   * @example table.join(other, (a, b) => op.equal(a.keyL, b.keyR))\n   */\n  join(other, on, values, options) {\n    return join(this, other, on, values, options);\n  }\n\n  /**\n   * Perform a left outer join on two tables. Rows in the left table\n   * that do not match a row in the right table will be preserved.\n   * This is a convenience method with fixed options for *join*.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinPredicate} [on]\n   *  The join criteria for matching table rows.\n   *  If unspecified, the values of all columns with matching names\n   *  are compared.\n   *  If array-valued, a two-element array should be provided, containing\n   *  the columns to compare for the left and right tables, respectively.\n   *  If a one-element array or a string value is provided, the same\n   *  column names will be drawn from both tables.\n   *  If function-valued, should be a two-table table expression that\n   *  returns a boolean value. When providing a custom predicate, note that\n   *  join key values can be arrays or objects, and that normal join\n   *  semantics do not consider null or undefined values to be equal (that is,\n   *  null !== null). Use the op.equal function to handle these cases.\n   * @param {import('./types.js').JoinValues} [values]\n   *  he columns to include in the join output.\n   *  If unspecified, all columns from both tables are included; paired\n   *  join keys sharing the same column name are included only once.\n   *  If array-valued, a two element array should be provided, containing\n   *  the columns to include for the left and right tables, respectively.\n   *  Array input may consist of column name strings, objects with output\n   *  names as keys and single-table table expressions as values, or the\n   *  selection helper functions *all*, *not*, or *range*.\n   *  If object-valued, specifies the key-value pairs for each output,\n   *  defined using two-table table expressions.\n   * @param {import('./types.js').JoinOptions} [options]\n   *  Options for the join. With this method, any options will be\n   *  overridden with `{left: true, right: false}`.\n   * @return {this} A new joined table.\n   * @example table.join_left(other, ['keyL', 'keyR'])\n   * @example table.join_left(other, (a, b) => op.equal(a.keyL, b.keyR))\n   */\n  join_left(other, on, values, options) {\n    const opt = { ...options, left: true, right: false };\n    return join(this, other, on, values, opt);\n  }\n\n  /**\n   * Perform a right outer join on two tables. Rows in the right table\n   * that do not match a row in the left table will be preserved.\n   * This is a convenience method with fixed options for *join*.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinPredicate} [on]\n   *  The join criteria for matching table rows.\n   *  If unspecified, the values of all columns with matching names\n   *  are compared.\n   *  If array-valued, a two-element array should be provided, containing\n   *  the columns to compare for the left and right tables, respectively.\n   *  If a one-element array or a string value is provided, the same\n   *  column names will be drawn from both tables.\n   *  If function-valued, should be a two-table table expression that\n   *  returns a boolean value. When providing a custom predicate, note that\n   *  join key values can be arrays or objects, and that normal join\n   *  semantics do not consider null or undefined values to be equal (that is,\n   *  null !== null). Use the op.equal function to handle these cases.\n   * @param {import('./types.js').JoinValues} [values]\n   *  The columns to include in the join output.\n   *  If unspecified, all columns from both tables are included; paired\n   *  join keys sharing the same column name are included only once.\n   *  If array-valued, a two element array should be provided, containing\n   *  the columns to include for the left and right tables, respectively.\n   *  Array input may consist of column name strings, objects with output\n   *  names as keys and single-table table expressions as values, or the\n   *  selection helper functions *all*, *not*, or *range*.\n   *  If object-valued, specifies the key-value pairs for each output,\n   *  defined using two-table table expressions.\n   * @param {import('./types.js').JoinOptions} [options]\n   *  Options for the join. With this method, any options will be overridden\n   *  with `{left: false, right: true}`.\n   * @return {this} A new joined table.\n   * @example table.join_right(other, ['keyL', 'keyR'])\n   * @example table.join_right(other, (a, b) => op.equal(a.keyL, b.keyR))\n   */\n  join_right(other, on, values, options) {\n    const opt = { ...options, left: false, right: true };\n    return join(this, other, on, values, opt);\n  }\n\n  /**\n   * Perform a full outer join on two tables. Rows in either the left or\n   * right table that do not match a row in the other will be preserved.\n   * This is a convenience method with fixed options for *join*.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinPredicate} [on]\n   *  The join criteria for matching table rows.\n   *  If unspecified, the values of all columns with matching names\n   *  are compared.\n   *  If array-valued, a two-element array should be provided, containing\n   *  the columns to compare for the left and right tables, respectively.\n   *  If a one-element array or a string value is provided, the same\n   *  column names will be drawn from both tables.\n   *  If function-valued, should be a two-table table expression that\n   *  returns a boolean value. When providing a custom predicate, note that\n   *  join key values can be arrays or objects, and that normal join\n   *  semantics do not consider null or undefined values to be equal (that is,\n   *  null !== null). Use the op.equal function to handle these cases.\n   * @param {import('./types.js').JoinValues} [values]\n   *  The columns to include in the join output.\n   *  If unspecified, all columns from both tables are included; paired\n   *  join keys sharing the same column name are included only once.\n   *  If array-valued, a two element array should be provided, containing\n   *  the columns to include for the left and right tables, respectively.\n   *  Array input may consist of column name strings, objects with output\n   *  names as keys and single-table table expressions as values, or the\n   *  selection helper functions *all*, *not*, or *range*.\n   *  If object-valued, specifies the key-value pairs for each output,\n   *  defined using two-table table expressions.\n   * @param {import('./types.js').JoinOptions} [options]\n   *  Options for the join. With this method, any options will be overridden\n   *  with `{left: true, right: true}`.\n   * @return {this} A new joined table.\n   * @example table.join_full(other, ['keyL', 'keyR'])\n   * @example table.join_full(other, (a, b) => op.equal(a.keyL, b.keyR))\n   */\n  join_full(other, on, values, options) {\n    const opt = { ...options, left: true, right: true };\n    return join(this, other, on, values, opt);\n  }\n\n  /**\n   * Produce the Cartesian cross product of two tables. The output table\n   * has one row for every pair of input table rows. Beware that outputs\n   * may be quite large, as the number of output rows is the product of\n   * the input row counts.\n   * This is a convenience method for *join* in which the\n   * join criteria is always true.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinValues} [values]\n   *  The columns to include in the output.\n   *  If unspecified, all columns from both tables are included.\n   *  If array-valued, a two element array should be provided, containing\n   *  the columns to include for the left and right tables, respectively.\n   *  Array input may consist of column name strings, objects with output\n   *  names as keys and single-table table expressions as values, or the\n   *  selection helper functions *all*, *not*, or *range*.\n   *  If object-valued, specifies the key-value pairs for each output,\n   *  defined using two-table table expressions.\n   * @param {import('./types.js').JoinOptions} [options]\n   *  Options for the join.\n   * @return {this} A new joined table.\n   * @example table.cross(other)\n   * @example table.cross(other, [['leftKey', 'leftVal'], ['rightVal']])\n   */\n  cross(other, values, options) {\n    return cross(this, other, values, options);\n  }\n\n  /**\n   * Perform a semi-join, filtering the left table to only rows that\n   * match a row in the right table.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinPredicate} [on]\n   *  The join criteria for matching table rows.\n   *  If unspecified, the values of all columns with matching names\n   *  are compared.\n   *  If array-valued, a two-element array should be provided, containing\n   *  the columns to compare for the left and right tables, respectively.\n   *  If a one-element array or a string value is provided, the same\n   *  column names will be drawn from both tables.\n   *  If function-valued, should be a two-table table expression that\n   *  returns a boolean value. When providing a custom predicate, note that\n   *  join key values can be arrays or objects, and that normal join\n   *  semantics do not consider null or undefined values to be equal (that is,\n   *  null !== null). Use the op.equal function to handle these cases.\n   * @return {this} A new filtered table.\n   * @example table.semijoin(other)\n   * @example table.semijoin(other, ['keyL', 'keyR'])\n   * @example table.semijoin(other, (a, b) => op.equal(a.keyL, b.keyR))\n   */\n  semijoin(other, on) {\n    return semijoin(this, other, on);\n  }\n\n  /**\n   * Perform an anti-join, filtering the left table to only rows that\n   * do *not* match a row in the right table.\n   * @param {import('./types.js').TableRef} other\n   *  The other (right) table to join with.\n   * @param {import('./types.js').JoinPredicate} [on]\n   *  The join criteria for matching table rows.\n   *  If unspecified, the values of all columns with matching names\n   *  are compared.\n   *  If array-valued, a two-element array should be provided, containing\n   *  the columns to compare for the left and right tables, respectively.\n   *  If a one-element array or a string value is provided, the same\n   *  column names will be drawn from both tables.\n   *  If function-valued, should be a two-table table expression that\n   *  returns a boolean value. When providing a custom predicate, note that\n   *  join key values can be arrays or objects, and that normal join\n   *  semantics do not consider null or undefined values to be equal (that is,\n   *  null !== null). Use the op.equal function to handle these cases.\n   * @return {this} A new filtered table.\n   * @example table.antijoin(other)\n   * @example table.antijoin(other, ['keyL', 'keyR'])\n   * @example table.antijoin(other, (a, b) => op.equal(a.keyL, b.keyR))\n   */\n  antijoin(other, on) {\n    return antijoin(this, other, on);\n  }\n\n  // -- Set Operations ------------------------------------------------------\n\n  /**\n   * Concatenate multiple tables into a single table, preserving all rows.\n   * This transformation mirrors the UNION_ALL operation in SQL.\n   * Only named columns in this table are included in the output.\n   * @param  {...import('./types.js').TableRefList} tables\n   *  A list of tables to concatenate.\n   * @return {this} A new concatenated table.\n   * @example table.concat(other)\n   * @example table.concat(other1, other2)\n   * @example table.concat([other1, other2])\n   */\n  concat(...tables) {\n    return concat(this, ...tables);\n  }\n\n  /**\n   * Union multiple tables into a single table, deduplicating all rows.\n   * This transformation mirrors the UNION operation in SQL. It is\n   * similar to *concat* but suppresses duplicate rows with\n   * values identical to another row.\n   * Only named columns in this table are included in the output.\n   * @param  {...import('./types.js').TableRefList} tables\n   *  A list of tables to union.\n   * @return {this} A new unioned table.\n   * @example table.union(other)\n   * @example table.union(other1, other2)\n   * @example table.union([other1, other2])\n   */\n  union(...tables) {\n    return union(this, ...tables);\n  }\n\n  /**\n   * Intersect multiple tables, keeping only rows whose with identical\n   * values for all columns in all tables, and deduplicates the rows.\n   * This transformation is similar to a series of *semijoin*.\n   * calls, but additionally suppresses duplicate rows.\n   * @param  {...import('./types.js').TableRefList} tables\n   *  A list of tables to intersect.\n   * @return {this} A new filtered table.\n   * @example table.intersect(other)\n   * @example table.intersect(other1, other2)\n   * @example table.intersect([other1, other2])\n   */\n  intersect(...tables) {\n    return intersect(this, ...tables);\n  }\n\n  /**\n   * Compute the set difference with multiple tables, keeping only rows in\n   * this table that whose values do not occur in the other tables.\n   * This transformation is similar to a series of *anitjoin*\n   * calls, but additionally suppresses duplicate rows.\n   * @param  {...import('./types.js').TableRefList} tables\n   *  A list of tables to difference.\n   * @return {this} A new filtered table.\n   * @example table.except(other)\n   * @example table.except(other1, other2)\n   * @example table.except([other1, other2])\n   */\n  except(...tables) {\n    return except(this, ...tables);\n  }\n\n  // -- Table Output Formats ------------------------------------------------\n\n  /**\n   * Format this table as a Flechette Arrow table.\n   * @param {import('../format/types.js').ArrowFormatOptions} [options]\n   *  The Arrow formatting options.\n   * @return {import('@uwdata/flechette').Table} A Flechette Arrow table.\n   */\n  toArrow(options) {\n    return toArrow(this, options);\n  }\n\n  /**\n   * Format this table as binary data in the Apache Arrow IPC format.\n   * @param {import('../format/types.js').ArrowIPCFormatOptions} [options]\n   *  The Arrow IPC formatting options.\n   * @return {Uint8Array} A new Uint8Array of Arrow-encoded binary data.\n   */\n  toArrowIPC(options) {\n    return toArrowIPC(this, options);\n  }\n\n  /**\n   * Format this table as a comma-separated values (CSV) string. Other\n   * delimiters, such as tabs or pipes ('|'), can be specified using\n   * the options argument.\n   * @param {import('../format/to-csv.js').CSVFormatOptions} [options]\n   *   The CSV formatting options.\n   * @return {string} A delimited value string.\n   */\n  toCSV(options) {\n    return toCSV(this, options);\n  }\n\n  /**\n   * Format this table as an HTML table string.\n   * @param {import('../format/to-html.js').HTMLFormatOptions} [options]\n   *  The HTML formatting options.\n   * @return {string} An HTML table string.\n   */\n  toHTML(options) {\n    return toHTML(this, options);\n  }\n\n  /**\n   * Format this table as a JavaScript Object Notation (JSON) string.\n   * @param {import('../format/to-json.js').JSONFormatOptions} [options]\n   *  The JSON formatting options.\n   * @return {string} A JSON string.\n   */\n  toJSON(options) {\n    return toJSON(this, options);\n  }\n\n  /**\n   * Format this table as a GitHub-Flavored Markdown table string.\n   * @param {import('../format/to-markdown.js').MarkdownFormatOptions} [options]\n   *  The Markdown formatting options.\n   * @return {string} A GitHub-Flavored Markdown table string.\n   */\n  toMarkdown(options) {\n    return toMarkdown(this, options);\n  }\n}\n","import { columnSet } from '../table/ColumnSet.js';\nimport { Table } from '../table/Table.js';\nimport { error } from '../util/error.js';\n\nexport function assign(table, ...others) {\n  others = others.flat();\n  const nrows = table.numRows();\n  const base = table.reify();\n  const cols = columnSet(base).groupby(base.groups());\n  others.forEach(input => {\n    input = input instanceof Table ? input : new Table(input);\n    if (input.numRows() !== nrows) error('Assign row counts do not match');\n    input = input.reify();\n    input.columnNames(name => cols.add(name, input.column(name)));\n  });\n  return cols.new(table);\n}\n","import { _select } from './select.js';\nimport { resolve } from '../helpers/selection.js';\n\nexport function rename(table, ...columns) {\n  const map = new Map();\n  table.columnNames(x => (map.set(x, x), 0));\n  return _select(table, resolve(table, columns.flat(), map));\n}\n","import { reduceFlat, reduceGroups } from './reduce/util.js';\nimport { columnSet } from '../table/ColumnSet.js';\n\nexport function reduce(table, reducer) {\n  const cols = columnSet();\n  const groups = table.groups();\n\n  // initialize groups\n  const { get, names = [], rows, size = 1 } = groups || {};\n  const counts = new Uint32Array(size + 1);\n  names.forEach(name => cols.add(name, null));\n\n  // compute reduced values\n  const cells = groups\n    ? reduceGroups(table, reducer, groups)\n    : [ reduceFlat(table, reducer) ];\n\n  // initialize output columns\n  reducer.outputs().map(name => cols.add(name, []));\n\n  // write reduced values to output columns\n  const n = counts.length - 1;\n  let len = 0;\n  for (let i = 0; i < n; ++i) {\n    len += counts[i + 1] = reducer.write(cells[i], cols.data, counts[i]);\n  }\n\n  // write group values to output columns\n  if (groups) {\n    const data = table.data();\n    names.forEach((name, index) => {\n      const column = cols.data[name] = Array(len);\n      const getter = get[index];\n      for (let i = 0, j = 0; i < size; ++i) {\n        column.fill(getter(rows[i], data), j, j += counts[i + 1]);\n      }\n    });\n  }\n\n  return cols.new(table);\n}\n","export function unorder(table) {\n  return table.isOrdered()\n    ? table.create({ order: null })\n    : table;\n}\n","import { concat } from './concat.js';\nimport { dedupe } from './dedupe.js';\n\nexport function union(table, ...others) {\n  return dedupe(concat(table, others.flat()));\n}\n","import { dedupe } from './dedupe.js';\nimport { semijoin } from './join-filter.js';\n\nexport function intersect(table, ...others) {\n  others = others.flat();\n  const names = table.columnNames();\n  return others.length\n    ? dedupe(others.reduce((a, b) => semijoin(a, b.select(names)), table))\n    : table.reify([]);\n}\n","import { dedupe } from './dedupe.js';\nimport { antijoin } from './join-filter.js';\n\nexport function except(table, ...others) {\n  others = others.flat();\n  if (others.length === 0) return table;\n  const names = table.columnNames();\n  return dedupe(others.reduce((a, b) => antijoin(a, b.select(names)), table));\n}\n","/**\n * @param {string} path\n * @returns {'gzip' | 'deflate' | null}\n */\nexport function compressionType(path) {\n  const ext = path.slice(-3).toLowerCase();\n  return ext === '.gz' ? 'gzip'\n    : ext === '.zz' ? 'deflate'\n    : null;\n}\n","import { compressionType } from './compression-type.js';\n\n/**\n * Return a ReadableStream for the given URL path.\n * @param {string} url The URL to load.\n * @param {import('../types.js').LoadOptions} options\n * @returns {Promise<ReadableStream<Uint8Array>>}\n */\nexport async function byteStream(url, {\n  fetch: fopt = undefined,\n  decompress = compressionType(url)\n} = {}) {\n  const s = await fetch(url, fopt).then(r => r.body);\n  return /** @type {ReadableStream<Uint8Array>} */(decompress\n    ? s.pipeThrough(new DecompressionStream(decompress))\n    : s);\n}\n","import { isFunction } from '../../util/is-function.js';\n\n/**\n * Return an async iterator for a stream.\n * This method is needed to deal with Safari.\n * @template T\n * @param {ReadableStream<T>} stream\n * @returns {AsyncIterator<T> & AsyncIterable<T>}\n */\nexport function streamIterator(stream) {\n  if (isFunction(stream[Symbol.asyncIterator])) {\n    return stream[Symbol.asyncIterator]();\n  } else {\n    const reader = stream.getReader();\n    return {\n      next() {\n        return /** @type {Promise<IteratorResult<T>>} */ (reader.read());\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      }\n    };\n  }\n}\n","import { isReadableStream } from '../../util/is-readable-stream.js';\nimport { isString } from '../../util/is-string.js';\nimport { streamIterator } from './stream-iterator.js';\n\n/**\n * @param {ReadableStream<Uint8Array>} input\n * @returns {Promise<Uint8Array>}\n */\nexport async function collectBytes(input) {\n  const bytes = [];\n  let size = 0;\n  for await (const chunk of streamIterator(input)) {\n    size += chunk.length;\n    bytes.push(chunk);\n  }\n  let buffer;\n  if (bytes.length > 1) {\n    buffer = new Uint8Array(size);\n    for (let i = 0, off = 0; i < bytes.length; ++i) {\n      buffer.set(bytes[i], off);\n      off += bytes[i].length;\n    }\n  } else {\n    buffer = bytes[0];\n  }\n  return buffer;\n}\n\n/**\n * @param {any} input\n */\nexport async function collectJSON(input) {\n  return isString(input) ? JSON.parse(input)\n    : isReadableStream(input) ? JSON.parse(await collectText(input))\n    : input;\n}\n\n/**\n * @param {ReadableStream<string> | string} input\n * @returns {Promise<string>}\n */\nexport async function collectText(input) {\n  if (isString(input)) return input;\n  let text = '';\n  for await (const chunk of streamIterator(input)) {\n    text += chunk;\n  }\n  return text;\n}\n","/**\n * @param {*} value\n * @returns {value is ReadableStream}\n */\nexport function isReadableStream(value) {\n  return value instanceof ReadableStream;\n}\n","import { tableFromIPC } from '@uwdata/flechette';\nimport { all, resolve } from '../helpers/selection.js';\nimport { sequence } from '../op/functions/sequence.js';\nimport { columnSet } from '../table/ColumnSet.js';\nimport { ColumnTable } from '../table/ColumnTable.js';\nimport { byteStream } from './stream/byte-stream.js';\nimport { collectBytes } from './stream/collect.js';\n\n/**\n * Create a new table backed by an Apache Arrow table instance.\n * @param {import('./types.js').ArrowInput} input\n *  An Apache Arrow data table or Arrow IPC byte buffer.\n * @param {import('./types.js').ArrowOptions} [options]\n *  Options for Arrow import.\n * @return {ColumnTable} A new table containing the imported values.\n */\nexport function fromArrow(input, options) {\n  const { columns = all(), ...rest } = options || {};\n  const arrow = input instanceof ArrayBuffer || input instanceof Uint8Array\n    ? tableFromIPC(input, { useDate: true, ...rest })\n    : input;\n\n  const { fields } = arrow.schema;\n\n  // resolve column selection\n  const names = fields.map(f => f.name);\n  const sel = resolve({\n    columnNames: test => test ? names.filter(test) : names.slice(),\n    columnIndex: name => names.indexOf(name)\n  }, columns);\n\n  // build Arquero columns for backing Arrow columns\n  const cols = columnSet();\n  sel.forEach((name, key) => {\n    const col = /** @type {import('./types.js').ArrowColumn} */ (arrow.getChild(key));\n    cols.add(name, col.type.typeId === -1 ? dictionary(col) : col);\n  });\n\n  return new ColumnTable(cols.data, cols.names);\n}\n\n/**\n * Parse Arrow data and return a Promise for an Arquero table.\n * @param {ReadableStream<Uint8Array>} stream\n *  An input byte stream, Apache Arrow data table, or Arrow IPC byte buffer.\n * @param {import('./types.js').ArrowOptions} [options]\n *  Options for Arrow import.\n * @return {Promise<ColumnTable>} A Promise to an Arquero table.\n */\nexport async function fromArrowStream(stream, options) {\n  return fromArrow(await collectBytes(stream), options);\n}\n\n/**\n * Load an Arrow file from a URL and return a Promise for an Arquero table.\n * @param {string} path The URL or file path to load.\n * @param {import('./types.js').LoadOptions\n *  & import('./types.js').ArrowOptions} [options] Arrow parse options.\n * @return {Promise<ColumnTable>} A Promise to an Arquero table.\n * @example aq.loadArrow('data/table.arrow')\n */\nexport async function loadArrow(path, options) {\n  return fromArrowStream(await byteStream(path, options), options);\n}\n\nfunction dictionary(column) {\n  const { data, length, nullCount } = column;\n  const batch = data[data.length - 1];\n  // support both flechette and arrow-js\n  const cache = batch.cache ?? batch.dictionary.toArray();\n  const size = cache.length;\n  const keys = dictKeys(data, length, nullCount, size);\n\n  const get = nullCount\n    ? (k => k === size ? null : cache[k])\n    : (k => cache[k]);\n\n  return {\n    length,\n    nullCount,\n    at: row => get(keys[row]),\n    key: row => keys[row],\n    keyFor(value) {\n      if (value === null) return nullCount ? size : -1;\n      for (let i = 0; i < size; ++i) {\n        if (cache[i] === value) return i;\n      }\n      return -1;\n    },\n    groups(names) {\n      const s = size + (nullCount ? 1 : 0);\n      return {\n        keys,\n        get: [get],\n        names,\n        rows: sequence(0, s),\n        size: s\n      };\n    },\n    [Symbol.iterator]: () => column[Symbol.iterator](),\n    toArray: () => column.toArray()\n  };\n}\n\n/**\n * Generate a dictionary key array.\n * @param {readonly any[]} data Arrow column batches\n * @param {number} length The length of the Arrow column\n * @param {number} nulls The count of column null values\n * @param {number} size The backing dictionary size\n */\nfunction dictKeys(data, length, nulls, size) {\n  const v = data.length > 1 || nulls\n    ? flatten(data, length)\n    : data[0].values;\n  return nulls ? nullKeys(data, v, size) : v;\n}\n\n/**\n * Flatten Arrow column chunks into a single array.\n */\nfunction flatten(data, length) {\n  const type = data[0].values.constructor;\n  const array = new type(length);\n  const n = data.length;\n  for (let i = 0, idx = 0, len; i < n; ++i) {\n    len = data[i].length;\n    array.set(data[i].values.subarray(0, len), idx);\n    idx += len;\n  }\n  return array;\n}\n\n/**\n * Encode null values as an additional dictionary key.\n * Returns a new key array with null values added.\n * TODO: safeguard against integer overflow?\n */\nfunction nullKeys(data, keys, key) {\n  // iterate over null bitmaps, encode null values as key\n  const n = data.length;\n  for (let i = 0, idx = 0, byte; i < n; ++i) {\n    const batch = data[i];\n    const { length } = batch;\n    // support both flechette and arrow-js\n    const validity = batch.validity ?? batch.nullBitmap;\n    const m = length >> 3;\n    if (validity && validity.length) {\n      for (let j = 0; j <= m; ++j) {\n        if ((byte = validity[j]) !== 255) {\n          const base = idx + (j << 3);\n          if ((byte & (1 << 0)) === 0) keys[base + 0] = key;\n          if ((byte & (1 << 1)) === 0) keys[base + 1] = key;\n          if ((byte & (1 << 2)) === 0) keys[base + 2] = key;\n          if ((byte & (1 << 3)) === 0) keys[base + 3] = key;\n          if ((byte & (1 << 4)) === 0) keys[base + 4] = key;\n          if ((byte & (1 << 5)) === 0) keys[base + 5] = key;\n          if ((byte & (1 << 6)) === 0) keys[base + 6] = key;\n          if ((byte & (1 << 7)) === 0) keys[base + 7] = key;\n        }\n      }\n    }\n    idx += length;\n  }\n  return keys;\n}\n","import { BREAK, EOL, NEWLINE, QUOTE, RETURN } from './constants.js';\nimport { error } from '../../util/error.js';\n\nfunction unquote(str) {\n  return str.slice(1, -1).replace(/\"\"/g, '\"');\n}\n\n/**\n * Returns a new delimited text stream transformer.\n * @param {string} [delimiter=','] The column delimiter string.\n *  The value should be a single character.\n * @returns {Transformer<string, string[][]>}\n */\nexport function delimitedTextTransformer(delimiter = ',') {\n  if (delimiter.length !== 1) {\n    error(`Text delimiter should be a single character, found \"${delimiter}\"`);\n  }\n  const delimCode = delimiter.charCodeAt(0);\n\n  let I = 0; // current chunk character index\n  let N = 0; // length of current text chunk\n  let qc = 0; // consecutive quote char count\n  let eol = false; // current token followed by EOL?\n  let skipNewline = false; // skip newline after carriage return?\n  let inQuote = false; // chunk boundary within quoted text?\n  let chunk = null; // current text chunk\n  let fragment = null; // text fragment leftover from prior chunk\n  let row = []; // current row of delimited text values\n\n  function addFragment(str) {\n    fragment = fragment ? (fragment + str) : str;\n  }\n\n  function token() {\n    if (eol) return eol = false, EOL;\n    const j = I;\n    const jq = chunk.charCodeAt(j) === QUOTE;\n\n    // handle quotes, unescape nested double quotes\n    if (inQuote || jq) {\n      let q = qc && !jq; // indicate completion of quote\n      if (inQuote && !q) {\n        --I; // back up if cross-chunk quote\n      } else if (jq) {\n        ++qc; // increment consecutive quote chars\n      }\n      inQuote = true;\n\n      // process characters within quote\n      if (!q) {\n        while (++I < N) {\n          if (chunk.charCodeAt(I) === QUOTE) {\n            if (++qc === 3) {\n              // consume escaped quote char (\"\")\n              qc = 1;\n            } else if ((I + 1) < N && chunk.charCodeAt(I + 1) !== QUOTE) {\n              qc = 0; // reset quote char count\n              q = true; // reached end of quote\n              ++I;\n              break;\n            }\n          }\n        }\n        if (!q) {\n          // end of chunk and still in quote\n          // break off intra-quote fragment\n          addFragment(chunk.slice(j, N));\n          return BREAK;\n        }\n      }\n\n      // extract and unescape quoted text\n      const quoted = unquote((fragment ?? '') + chunk.slice(j, I));\n      qc = 0;\n      inQuote = false;\n      fragment = null;\n\n      // if a quote stops at end of chunk, treat as normal fragment\n      if (I >= N) {\n        fragment = quoted;\n        return BREAK;\n      }\n\n      // check for end of line\n      const c = chunk.charCodeAt(I++);\n      if (c === NEWLINE) eol = true;\n      else if (c === RETURN) {\n        eol = true;\n        if (I >= N) skipNewline = true;\n        else if (chunk.charCodeAt(I) === NEWLINE) ++I;\n      }\n      return quoted;\n    }\n\n    // find next delimiter or newline\n    let i;\n    while (I < N) {\n      const c = chunk.charCodeAt(i = I++);\n      if (c === NEWLINE) eol = true;\n      else if (c === RETURN) {\n        eol = true;\n        if (I >= N) skipNewline = true;\n        else if (chunk.charCodeAt(I) === NEWLINE) ++I;\n      }\n      else if (c !== delimCode) continue;\n      return chunk.slice(j, i);\n    }\n\n    // current token straddles chunks, save fragment\n    addFragment(chunk.slice(j, N));\n    return BREAK;\n  }\n\n  return {\n    start() {},\n\n    transform(next, controller) {\n      chunk = next;\n      N = chunk.length;\n      I = 0;\n      const batch = [];\n      let t;\n\n      if (skipNewline) {\n        if (chunk.charCodeAt(I) === NEWLINE) ++I;\n        skipNewline = false;\n      }\n\n      if (fragment != null) {\n        if ((t = token()) === BREAK) {\n          controller.enqueue(batch);\n          return;\n        }\n        else {\n          row.push((fragment ?? '') + t);\n          fragment = null;\n        }\n      }\n\n      while (true) {\n        if ((t = token()) === BREAK) {\n          controller.enqueue(batch);\n          return;\n        }\n        else if (t === EOL) (batch.push(row), row = []);\n        else row.push(t);\n      }\n    },\n\n    flush(controller) {\n      if (row.length || fragment) {\n        if (fragment != null) {\n          row.push(qc === 2 ? unquote(fragment) : fragment);\n        }\n        controller.enqueue([row]);\n      }\n    }\n  };\n}\n","import { BitSet } from '../../table/BitSet.js';\nimport { identity } from '../../util/identity.js';\n\n/**\n * @template T\n * @param {number} [skip]\n * @param {string} [comment]\n * @param {(value: T) => string} [accessor]\n * @returns {TransformStream<T[]> | null}\n */\nexport function lineFilter(skip, comment, accessor) {\n  const transform = lineFilterTransformer(skip, comment, accessor);\n  return transform ? new TransformStream(transform) : null;\n}\n\nfunction shouldDrop(skip, comment, accessor) {\n  return skip > 0\n    ? (comment\n        ? (t, i) => i < skip || accessor(t).startsWith(comment)\n        : (t, i) => i < skip)\n    : comment ? t => accessor(t).startsWith(comment)\n    : null;\n}\n\n/**\n * Returns a new line filter stream transformer.\n * @template T\n * @param {number} [skip]\n * @param {string} [comment]\n * @param {(value: T) => string} [accessor]\n * @returns {Transformer<T[], T[]>}\n */\nexport function lineFilterTransformer(skip, comment, accessor = identity) {\n  const drop = shouldDrop(skip, comment, accessor);\n  if (!drop) return null;\n  let i = 0;\n  return {\n    start() {}, // no-op\n    flush() {}, // no-op\n    transform(chunk, controller) {\n      const n = chunk.length;\n      const bits = new BitSet(n);\n      for (let c = 0; c < chunk.length; ++c, ++i) {\n        if (drop(chunk[c], i)) bits.set(c);\n      }\n      controller.enqueue(\n        bits.count()\n          ? chunk.filter((_, c) => !bits.get(c))\n          : chunk\n      );\n    }\n  };\n}\n","import { identity } from './identity.js';\nimport { isISODateString } from './is-iso-date-string.js';\n\nconst parseBoolean = [ // boolean\n  v => (v === 'true') || (v === 'false'),\n  v => v === 'false' ? false : true\n];\n\nconst parseNumber = [ // number\n  v => v === 'NaN' || (v = +v) === v,\n  v => +v\n];\n\nconst parseDate = [ // iso date\n  isISODateString,\n  v => new Date(Date.parse(v))\n];\n\nfunction numberParser(decimal) {\n  return decimal && decimal !== '.'\n    ? parseNumber.map(f => s => f(s && s.replace(decimal, '.')))\n    : parseNumber;\n}\n\nexport function parseValues(values, options) {\n  const { decimal, limit = values.length } = options;\n  const types = [parseBoolean, numberParser(decimal), parseDate];\n  const n = types.length;\n  for (let i = 0; i < n; ++i) {\n    const [test, parser] = types[i];\n    if (check(values, test, limit)) {\n      return parser;\n    }\n  }\n  return identity;\n}\n\nfunction check(values, test, n) {\n  for (let i = 0; i < n; ++i) {\n    const v = values[i];\n    if (v != null && !test(v)) {\n      return false;\n    }\n  }\n  return true;\n}\n","/**\n * Run a stream data through a pipeline of stream transformers.\n * @template T\n * @param {ReadableStream<T>} source\n * @param {(Transformer|null)[]} transformers\n * @returns {any}\n */\nexport function pipelineStream(source, transformers) {\n  let stream = source;\n  transformers.forEach(t => {\n    if (t) stream = stream.pipeThrough(new TransformStream(t));\n  });\n  return stream;\n}\n\n/**\n * Synchronously run a batch of data through a pipeline of stream transformers.\n * @template T\n * @param {T} source\n * @param {(Transformer|null)[]} transformers\n * @returns {any}\n */\nexport function pipelineSync(source, transformers) {\n  /** @type {any} */\n  let data = source;\n  let chunks;\n\n  /** @type {TransformStreamDefaultController} */\n  const controller = {\n    desiredSize: -1,\n    error(reason) { throw new Error(reason); },\n    terminate() {},\n    enqueue(chunk) { chunks.push(chunk); }\n  };\n\n  transformers.forEach(t => {\n    if (t == null) return;\n    chunks = [];\n    t.start(controller);\n    t.transform(data, controller);\n    t.flush(controller);\n    data = chunks.flat();\n  });\n  return data;\n}\n","import { identity } from '../../util/identity.js';\nimport { isFunction } from '../../util/is-function.js';\nimport { repeat } from '../../util/repeat.js';\nimport { parseValues } from '../../util/parse-values.js';\nimport { pipelineStream, pipelineSync } from './pipeline.js';\nimport { ColumnTable } from '../../table/ColumnTable.js';\nimport { streamIterator } from './stream-iterator.js';\n\n/**\n * Create a table from column names and value arrays.\n * @param {string[]} names Column names\n * @param {any[]} values Column value arrays\n * @returns {ColumnTable}\n */\nfunction toTable(names, values) {\n  /** @type {import('../../table/types.js').ColumnData} */\n  const columns = {};\n  names.forEach((name, i) => columns[name] = values[i]);\n  return new ColumnTable(columns, names);\n}\n\n/**\n * Create a table from delimited text rows.\n * @param {string} input\n * @param {Transformer[]} transformers\n * @param {*} [options]\n * @returns {ColumnTable}\n */\nexport function parseTextRowsSync(input, transformers, options = {}) {\n  /** @type {string[][]} */\n  const rows = pipelineSync(input, transformers);\n  const { names, values } = parseTextRowBatches([rows], options);\n  return toTable(names, values);\n}\n\n/**\n * Create a table from a stream of delimited text rows.\n * @param {ReadableStream<string>} input\n * @param {*} [options]\n * @returns {Promise<ColumnTable>}\n */\nexport async function parseTextRowsStream(input, transformers, options = {}) {\n  const stream = pipelineStream(input, transformers);\n\n  // pull batches from stream to meet type inference needs\n  const automax = +options.autoMax || 1000;\n  const iter = streamIterator(stream);\n  const init = [];\n  let size = 0;\n  while (size < automax) {\n    const next = await iter.next();\n    const batch = next.value;\n    if (batch?.length > 0) {\n      init.push(batch);\n      size += batch.length;\n    }\n    if (next.done) break;\n  }\n\n  // parse initial batches, retrieve type parser functions\n  const { names, values, parsers } = parseTextRowBatches(init, options);\n  const n = names.length;\n\n  // parse remainder of stream\n  for await (const batch of iter) {\n    for (let r = 0; r < batch.length; ++r) {\n      const row = batch[r];\n      for (let i = 0; i < n; ++i) {\n        values[i].push(row[i] ? parsers[i](row[i]) : null);\n      }\n    }\n  }\n\n  return toTable(names, values);\n}\n\n/**\n * Create column value arrays for batches of text rows.\n * @param {string[][][]} batches\n * @param {*} options\n * @returns {{ names: string[], values: any[], parsers: ReturnType<getParsers> }}\n */\nfunction parseTextRowBatches(batches, options) {\n  const [batch] = batches;\n  const n = batch[0].length;\n  const automax = +options.autoMax || 1000;\n  const values = repeat(n, () => []);\n  let names = options.header !== false ? batch.shift() : options.names;\n  names = names\n    ? names.length < n ? [...names, defaultNames(n, names.length)] : names\n    : defaultNames(n);\n\n  // transpose text rows into column arrays\n  for (const batch of batches) {\n    for (let r = 0; r < batch.length; ++r) {\n      const row = batch[r];\n      for (let i = 0; i < n; ++i) {\n        values[i].push(row[i] === '' ? null : row[i]);\n      }\n    }\n  }\n\n  // initialize parsers\n  const parsers = getParsers(names, values, { ...options, limit: automax });\n\n  // apply parsers to column arrays\n  parsers.forEach((parse, i) => {\n    if (parse === identity) return;\n    const v = values[i];\n    for (let r = 0; r < v.length; ++r) {\n      if (v[r] != null) v[r] = parse(v[r]);\n    }\n  });\n\n  return { names, values, parsers };\n}\n\nfunction defaultNames(n, off = 0) {\n  return repeat(n - off, i => `col${i + off + 1}`);\n}\n\nfunction getParsers(names, values, options) {\n  const { parse = {} } = options;\n  const noParse = options.autoType === false;\n\n  return names.map(\n    (name, i) => isFunction(parse[name]) ? parse[name]\n      : noParse ? identity\n      : parseValues(values[i], options)\n  );\n}\n","import { byteStream } from './byte-stream.js';\n\n/**\n * Return a Promise to a ReadableStream of text for a given file/url path.\n * @param {string} path The file or URL path\n * @param {import('../types.js').LoadOptions} options\n * @returns {Promise<ReadableStream<string>>}\n */\nexport async function textStream(path, options) {\n  return (await byteStream(path, options))\n    .pipeThrough(new TextDecoderStream());\n}\n","import { ColumnTable } from '../table/ColumnTable.js'; // eslint-disable-line no-unused-vars\nimport { delimitedTextTransformer } from './stream/delimited-text-stream.js';\nimport { lineFilterTransformer } from './stream/line-filter-stream.js';\nimport { parseTextRowsStream, parseTextRowsSync } from './stream/parse-text-rows.js';\nimport { textStream } from './stream/text-stream.js';\n\n/**\n * Options for CSV parsing.\n * @typedef {object} CSVParseOptions\n * @property {string} [delimiter=','] Single-character delimiter between values.\n * @property {string} [decimal='.'] Single-character numeric decimal separator.\n * @property {boolean} [header=true] Flag to specify presence of header row.\n *  If true, assumes the CSV contains a header row with column names. If false,\n *  indicates the CSV does not contain a header row; columns are given the\n *  names 'col1', 'col2', etc unless the *names* option is specified.\n * @property {string[]} [names] An array of column names to use for header-less\n *  CSV files. This option is ignored if the header option is true.\n * @property {number} [skip=0] The number of lines to skip before reading data.\n * @property {string} [comment] A string used to identify comment lines. Any\n *  lines that start with the comment pattern are skipped.\n * @property {boolean} [autoType=true] Flag for automatic type inference.\n * @property {number} [autoMax=1000] Maximum number of initial values to use\n *  for type inference.\n * @property {Record<string, (value: string) => any>} [parse] Object of\n *  column parsing options. The object keys should be column names. The object\n *  values should be parsing functions that transform values upon input.\n */\n\n/**\n * Parse a comma-separated values (CSV) string into a table. Other\n * delimiters, such as tabs or pipes ('|'), can be specified using\n * the options argument. By default, automatic type inference is performed\n * for input values; string values that match the ISO standard\n * date format are parsed into JavaScript Date objects. To disable this\n * behavior, set the autoType option to false. To perform custom parsing\n * of input column values, use the parse option.\n * @param {string} input The input text.\n * @param {CSVParseOptions} [options] The formatting options.\n * @return {ColumnTable} An Arquero table.\n */\nexport function fromCSV(input, options) {\n  return parseTextRowsSync(input, transforms(options), options);\n}\n\n/**\n * Parse a comma-separated values (CSV) string into a table. Other\n * delimiters, such as tabs or pipes ('|'), can be specified using\n * the options argument. By default, automatic type inference is performed\n * for input values; string values that match the ISO standard\n * date format are parsed into JavaScript Date objects. To disable this\n * behavior, set the autoType option to false. To perform custom parsing\n * of input column values, use the parse option.\n * @param {ReadableStream<string>} stream The input stream.\n * @param {CSVParseOptions} [options] The formatting options.\n * @return {Promise<ColumnTable>} A Promise to an Arquero table.\n */\nexport async function fromCSVStream(stream, options) {\n  return parseTextRowsStream(stream, transforms(options), options);\n}\n\n/**\n * Load a CSV file from a URL and return a Promise for an Arquero table.\n * @param {string} path The URL or file path to load.\n * @param {import('./types.js').LoadOptions & CSVParseOptions} [options]\n *  CSV parse options.\n * @return {Promise<ColumnTable>} A Promise to an Arquero table.\n * @example aq.loadCSV('data/table.csv')\n * @example aq.loadTSV('data/table.tsv', { delimiter: '\\t' })\n */\nexport async function loadCSV(path, options) {\n  return fromCSVStream(await textStream(path, options), options);\n}\n\nfunction transforms({\n  delimiter = ',',\n  skip = 0,\n  comment = undefined\n} = {}) {\n  return [\n    delimitedTextTransformer(delimiter),\n    lineFilterTransformer(skip, comment, row => row[0])\n  ];\n}\n","/**\n * Returns a fixed text stream transformer.\n * @param {[number, number][]} positions The fixed positions delimiting records\n * @returns {Transformer<string[], string[][]>}\n */\nexport function fixedTextTransformer(positions) {\n  return {\n    start() {}, // no-op\n    flush() {}, // no-op\n    transform(chunk, controller) {\n      controller.enqueue(\n        chunk.map(\n          line => positions.map(([i, j]) => line.slice(i, j).trim())\n        )\n      );\n    }\n  };\n}\n","import { BREAK, NEWLINE, RETURN } from './constants.js';\n\n/**\n * Returns a new text line stream transformer.\n * @returns {Transformer<string, string[]>}\n */\nexport function textLineTransformer() {\n  let I = 0; // current chunk character index\n  let skipNewline = false; // skip newline after carriage return\n  let fragment = ''; // remaining fragment from previous chunk\n\n  function parseLine(text) {\n    const N = text.length;\n    const j = I;\n\n    // find next newline\n    while (I < N) {\n      const c = text.charCodeAt(I);\n      const i = ++I;\n      if (c === RETURN) {\n        if (I >= N) skipNewline = true;\n        else if (text.charCodeAt(I) === NEWLINE) ++I;\n      } else if (c !== NEWLINE) {\n        continue;\n      }\n      return text.slice(j, i);\n    }\n\n    // current line straddles chunks\n    fragment += text.slice(j, N);\n    return BREAK;\n  }\n\n  return {\n    start() {},\n    transform(chunk, controller) {\n      I = 0;\n      let line;\n      const lines = [];\n      if (skipNewline) {\n        if (chunk.charCodeAt(I) === NEWLINE) ++I;\n        skipNewline = false;\n      }\n      if (fragment) {\n        line = parseLine(chunk);\n        if (line === BREAK) {\n          controller.enqueue(lines);\n          return;\n        }\n        else (lines.push(fragment + line), fragment = '');\n      }\n      while ((line = parseLine(chunk)) !== BREAK) {\n        lines.push(line);\n      }\n      controller.enqueue(lines);\n    },\n    flush(controller) {\n      if (fragment) controller.enqueue([fragment]);\n    }\n  };\n}\n","import { ColumnTable } from '../table/ColumnTable.js'; // eslint-disable-line no-unused-vars\nimport { error } from '../util/error.js';\nimport { fixedTextTransformer } from './stream/fixed-text-stream.js';\nimport { lineFilterTransformer } from './stream/line-filter-stream.js';\nimport { textLineTransformer } from './stream/text-line-stream.js';\nimport { parseTextRowsStream, parseTextRowsSync } from './stream/parse-text-rows.js';\nimport { textStream } from './stream/text-stream.js';\n\n/**\n * Options for fixed width file parsing.\n * @typedef {object} FixedParseOptions\n * @property {[number, number][]} [positions] Array of start, end indices for\n *  fixed-width columns. Specifying extact positions supports extraction of\n *  a selected subset of columns.\n * @property {number[]} [widths] Array of fixed column widths. This option is\n *  ignored if the positions property is specified.\n * @property {string[]} [names] An array of column names. The array length\n *  should match the length of the positions array. If not specified or\n *  shorter than the positions array, default column names are generated.\n * @property {string} [decimal='.'] Single-character numeric decimal separator.\n * @property {number} [skip=0] The number of lines to skip before reading data.\n * @property {string} [comment] A string used to identify comment lines. Any\n *  lines that start with the comment pattern are skipped.\n * @property {boolean} [autoType=true] Flag for automatic type inference.\n * @property {number} [autoMax=1000] Maximum number of initial values to use\n *  for type inference.\n * @property {Record<string, (value: string) => any>} [parse] Object of\n *  column parsing options. The object keys should be column names. The object\n *  values should be parsing functions that transform values upon input.\n */\n\n/**\n * Parse a fixed-width file (FWF) string into a table. By default, automatic\n * type inference is performed for input values; string values that match the\n * ISO standard date format are parsed into JavaScript Date objects. To\n * disable this behavior, set the autoType option to false. To perform custom\n * parsing of input column values, use the parse option.\n * @param {string} input The input text.\n * @param {FixedParseOptions} [options] The formatting options.\n * @return {ColumnTable} An Arquero table.\n */\nexport function fromFixed(input, options) {\n  return parseTextRowsSync(\n    input,\n    transforms(options),\n    { ...options, header: false }\n  );\n}\n\n/**\n * Parse a fixed-width file (FWF) stream into a table. By default, automatic\n * type inference is performed for input values; string values that match the\n * ISO standard date format are parsed into JavaScript Date objects. To\n * disable this behavior, set the autoType option to false. To perform custom\n * parsing of input column values, use the parse option.\n * @param {ReadableStream<string>} stream The input stream.\n * @param {FixedParseOptions} [options] The formatting options.\n * @return {Promise<ColumnTable>} A Promise to an Arquero table.\n */\nexport async function fromFixedStream(stream, options) {\n  return parseTextRowsStream(\n    stream,\n    transforms(options),\n    { ...options, header: false }\n  );\n}\n\n/**\n * Load a fixed width file from a URL and return a Promise for an Arquero table.\n * @param {string} path The URL or file path to load.\n * @param {import('./types.js').LoadOptions & FixedParseOptions} [options]\n * Fixed width parse options.\n * @return {Promise<ColumnTable>} A Promise to an Arquero table.\n * @example aq.loadFixedWidth('data/table.txt', { names: ['name', 'city', state'], widths: [10, 20, 2] })\n */\nexport async function loadFixed(path, options) {\n  return fromFixedStream(await textStream(path, options), options);\n}\n\nfunction transforms({\n  skip = 0,\n  comment = undefined,\n  positions = undefined,\n  widths = undefined\n} = {}) {\n  if (!positions && !widths) {\n    error('Fixed width files require a \"positions\" or \"widths\" option.');\n  }\n  let p = 0;\n  const breaks = positions || widths.map(w => [p, p += w]);\n  return [\n    textLineTransformer(),\n    lineFilterTransformer(skip, comment, row => row[0]),\n    fixedTextTransformer(breaks)\n  ];\n}\n","export function isDigitString(value) {\n  const n = value.length;\n  for (let i = 0; i < n; ++i) {\n    const c = value.charCodeAt(i);\n    if (c < 48 || c > 57) return false;\n  }\n  return true;\n}\n","import { pipelineStream, pipelineSync } from './pipeline.js';\nimport { streamIterator } from './stream-iterator.js';\n\nexport function parseJSONSync(input, columns, transformers) {\n  /** @type {string[][]} */\n  const rows = pipelineSync(input, transformers);\n  const { names, values } = parseJSONColumns(rows, columns);\n  parseJSONRowBatch(rows, names, values);\n  return toColumnData(names, values);\n}\n\nexport async function parseJSONStream(input, columns, transformers) {\n  const stream = pipelineStream(input, transformers);\n  const iter = streamIterator(stream);\n  let first;\n  do { first = (await iter.next()).value; } while (first.length === 0);\n  const { names, values } = parseJSONColumns(first, columns);\n  parseJSONRowBatch(first, names, values);\n  for await (const chunk of iter) {\n    parseJSONRowBatch(chunk, names, values);\n  }\n  return toColumnData(names, values);\n}\n\n/**\n * @param {string[]} names\n * @param {any[][]} values\n */\nfunction toColumnData(names, values) {\n  /** @type {import('../../table/types.js').ColumnData} */\n  const columns = {};\n  names.forEach((name, i) => columns[name] = values[i]);\n  return { columns, names };\n}\n\nfunction firstNonNull(lines) {\n  const l = lines.find(l => l.length);\n  return JSON.parse(l);\n}\n\nfunction parseJSONColumns(batch, columns) {\n  const names = columns ?? Object.keys(firstNonNull(batch));\n  return { names, values: names.map(() => []) };\n}\n\nfunction parseJSONRowBatch(batch, names, values) {\n  const n = names.length;\n  for (let r = 0; r < batch.length; ++r) {\n    const row = batch[r];\n    if (row) {\n      const obj = JSON.parse(row);\n      for (let i = 0; i < n; ++i) {\n        values[i].push(obj[names[i]]);\n      }\n    }\n  }\n}\n","import { ColumnTable } from '../table/ColumnTable.js';\nimport { isArray } from '../util/is-array.js';\nimport { isDigitString } from '../util/is-digit-string.js';\nimport { isISODateString } from '../util/is-iso-date-string.js';\nimport { isString } from '../util/is-string.js';\nimport { collectJSON } from './stream/collect.js';\nimport { COLUMNS, NDJSON } from './stream/constants.js';\nimport { lineFilterTransformer } from './stream/line-filter-stream.js';\nimport { parseJSONStream, parseJSONSync } from './stream/parse-json-rows.js';\nimport { textLineTransformer } from './stream/text-line-stream.js';\nimport { textStream } from './stream/text-stream.js';\n\n/**\n * Options for JSON parsing.\n * @typedef {object} JSONParseOptions\n * @property {'columns' | 'rows' | 'ndjson' | null} [type] The format type.\n *  One of `'columns'` (for an object with named column arrays)`, 'rows'` (for\n *  an array for row objects), or `'ndjson'` for [newline-delimited JSON][1]\n *  rows. For `'ndjson'`, each line of text must contain a JSON row object\n *  (with no trailing comma) and string properties must not contain any\n *  newline characters. If no format type is specified, one of `'rows'` or\n *  `'columns'` is inferred from the structure of the parsed JSON.\n *\n *  [1]: https://github.com/ndjson/ndjson-spec\n * @property {boolean} [autoType=true] Flag controlling automatic type\n *  inference for column values. If false, date parsing for input JSON\n *  strings is disabled.\n * @property {Record<string, (value: any) => any>} [parse] Object of column\n *  parsing options. The object keys should be column names. The object values\n *  should be parsing functions that transform values upon input.\n * @property {string[]} [columns] An array of column names to include. JSON\n *  properties missing from this list are not included in the table.\n * @property {number} [skip=0] The number of lines to skip before reading data.\n *  Applicable to newline-delimited (NDJSON) data only.\n * @property {string} [comment] A string used to identify comment lines. Any\n *  lines that start with the comment pattern are skipped. Applicable to\n *   newline-delimited (NDJSON)  data only.\n */\n\n/**\n * Parse JavaScript Object Notation (JSON) data into a table.\n * By default, automatic type inference is performed\n * for input values; string values that match the ISO standard\n * date format are parsed into JavaScript Date objects. To disable this\n * behavior, set the autoType option to false. To perform custom parsing\n * of input column values, use the parse option.\n * @param {string} input The input text or stream.\n * @param {JSONParseOptions} options The JSON parse options.\n * @return {ColumnTable} A new table containing the parsed values.\n */\nexport function fromJSON(input, options = {}) {\n  const { columns = undefined, type = undefined } = options;\n  let data;\n  if (type === NDJSON) {\n    data = parseJSONSync(input, columns, transforms(options));\n  } else {\n    const json = isString(input) ? JSON.parse(input) : input;\n    data = (type === COLUMNS || (!type && !isArray(json)))\n      ? parseJSONColumns(json, columns)\n      : parseJSONRows(json, columns);\n  }\n  return postprocessJSON(data, options);\n}\n\n/**\n * Parse a JavaScript Object Notation (JSON) stream into a table.\n * By default, automatic type inference is performed\n * for input values; string values that match the ISO standard\n * date format are parsed into JavaScript Date objects. To disable this\n * behavior, set the autoType option to false. To perform custom parsing\n * of input column values, use the parse option.\n * @param {ReadableStream<string>} input The input text or stream.\n * @param {JSONParseOptions} options The JSON parse options.\n * @return {Promise<ColumnTable>} A Promise to a new table containing the\n *  parsed values.\n */\nexport async function fromJSONStream(input, options = {}) {\n  return options.type === NDJSON\n    ? postprocessJSON(\n        await parseJSONStream(input, options.columns, transforms(options)),\n        options\n      )\n    : fromJSON(await collectJSON(input), options);\n}\n\n/**\n * Load a JSON file from a URL and return a Promise for an Arquero table.\n * If the loaded JSON is array-valued, an array-of-objects format is assumed\n * and the aq.from method is used to construct the table. Otherwise, a\n * column object format is assumed and aq.fromJSON is applied.\n * @param {string} path The URL or file path to load.\n * @param {import('./types.js').LoadOptions & JSONParseOptions} [options]\n *  JSON parse options.\n * @return {Promise<ColumnTable>} A Promise to an Arquero table.\n * @example aq.loadJSON('data/table.json')\n */\nexport async function loadJSON(path, options) {\n  const input = await textStream(path, options);\n  if (!options?.type &&\n    path.slice(-NDJSON.length-1).toLowerCase() === `.${NDJSON}`) {\n    options = { ...options, type: NDJSON };\n  }\n  return fromJSONStream(input, options);\n}\n\nfunction transforms({\n  comment = undefined,\n  skip = 0\n} = {}) {\n  return [\n    textLineTransformer(),\n    lineFilterTransformer(skip, comment)\n  ];\n}\n\n/**\n * @param {import('../table/types.js').ColumnData} data Initial column data.\n * @param {string[]} [names] The column names to use.\n * @return {{\n *   columns: import('../table/types.js').ColumnData,\n *   names: string[]\n * }}\n */\nfunction parseJSONColumns(data, names) {\n  /** @type {import('../table/types.js').ColumnData} */\n  let columns = data;\n  if (names) {\n    columns = names.reduce((c, name) => (c[name] = data[name], c), {});\n  } else {\n    names = Object.keys(columns);\n  }\n  return { columns, names };\n}\n\n/**\n * @param {object[]} data The input row objects.\n * @param {string[]} [names] The column names to use.\n * @return {{\n *   columns: import('../table/types.js').ColumnData,\n *   names: string[]\n * }}\n */\nfunction parseJSONRows(data, names) {\n  names ??= Object.keys(data[0]);\n  const cols = names.map(() => []);\n\n  const n = data.length;\n  const m = names.length;\n  for (let i = 0; i < n; ++i) {\n    const obj = data[i];\n    for (let j = 0; j < m; ++j) {\n      cols[j].push(obj[names[j]]);\n    }\n  }\n\n  /** @type {import('../table/types.js').ColumnData} */\n  const columns = {};\n  names.forEach((name, i) => columns[name] = cols[i]);\n  return { columns, names };\n}\n\n/**\n * Post-process JavaScript Object Notation (JSON) data, performing type\n * inference as needed and returning a table instance.\n * @param {{\n *  columns: import('../table/types.js').ColumnData,\n *  names: string[]\n * }} data The column data.\n * @param {JSONParseOptions} [options] The JSON parse options.\n * @return {ColumnTable} A new table containing the parsed values.\n */\nfunction postprocessJSON({ columns, names }, {\n  autoType = true,\n  parse = undefined\n} = {}) {\n  // parse values as necessary\n  if (autoType || parse) {\n    const parsers = parse || {};\n    for (const name in columns) {\n      const col = columns[name];\n      const len = col.length;\n      if (parsers[name]) {\n        // apply custom parser\n        for (let i = 0; i < len; ++i) {\n          col[i] = parsers[name](col[i]);\n        }\n      } else if (autoType) {\n        // apply autoType parser\n        for (let i = 0; i < len; ++i) {\n          const val = col[i];\n          if (isString(val) && isISODateString(val) && !isDigitString(val)) {\n            col[i] = new Date(val);\n          }\n        }\n      }\n    }\n  }\n\n  return new ColumnTable(columns, names);\n}\n","import { aggregateFunctions } from './aggregate-functions.js';\nimport { windowFunctions } from './window-functions.js';\nimport { functions } from './functions/index.js';\nimport { op, opApi } from './op-api.js';\nimport { ROW_OBJECT } from '../expression/row-object.js';\nimport { error } from '../util/error.js';\nimport { toString } from '../util/to-string.js';\n\nconst onIllegal = (name, type) =>\n  error(`Illegal ${type} name: ${toString(name)}`);\n\nconst onDefined = (name, type) =>\n  error(`The ${type} ${toString(name)} is already defined. Use override option?`);\n\nconst onReserve = (name, type) =>\n  error(`The ${type} name ${toString(name)} is reserved and can not be overridden.`);\n\nfunction check(name, options, obj = opApi, type = 'function') {\n  if (!name) onIllegal(name, type);\n  if (!options.override && Object.hasOwn(obj, name)) onDefined(name, type);\n}\n\nfunction verifyFunction(name, def, object, options) {\n  return object[name] === def || check(name, options);\n}\n\n/**\n * Register an aggregate or window operation.\n * @param {string} name The name of the operation\n * @param {AggregateDef|WindowDef} def The operation definition.\n * @param {object} object The registry object to add the definition to.\n * @param {RegisterOptions} [options] Registration options.\n */\nfunction addOp(name, def, object, options = {}) {\n  if (verifyFunction(name, def, object, options)) return;\n  const [nf = 0, np = 0] = def.param; // num fields, num params\n  object[name] = def;\n  opApi[name] = (...params) => op(\n    name,\n    params.slice(0, nf),\n    params.slice(nf, nf + np)\n  );\n}\n\n/**\n * Register a custom aggregate function.\n * @param {string} name The name to use for the aggregate function.\n * @param {AggregateDef} def The aggregate operator definition.\n * @param {RegisterOptions} [options] Function registration options.\n * @throws If a function with the same name is already registered and\n *  the override option is not specified.\n */\nexport function addAggregateFunction(name, def, options) {\n  addOp(name, def, aggregateFunctions, options);\n}\n\n/**\n * Register a custom window function.\n * @param {string} name The name to use for the window function.\n * @param {WindowDef} def The window operator definition.\n * @param {RegisterOptions} [options] Function registration options.\n * @throws If a function with the same name is already registered and\n *  the override option is not specified.\n */\nexport function addWindowFunction(name, def, options) {\n  addOp(name, def, windowFunctions, options);\n}\n\n/**\n * Register a function for use within table expressions.\n * If only a single argument is provided, it will be assumed to be a\n * function and the system will try to extract its name.\n * @param {string} name The name to use for the function.\n * @param {Function} fn A standard JavaScript function.\n * @param {RegisterOptions} [options] Function registration options.\n * @throws If a function with the same name is already registered and\n *  the override option is not specified, or if no name is provided\n *  and the input function is anonymous.\n */\nexport function addFunction(name, fn, options = {}) {\n  if (arguments.length === 1) {\n    // @ts-ignore\n    fn = name;\n    name = fn.name;\n    if (name === '' || name === 'anonymous') {\n      error('Anonymous function provided, please include a name argument.');\n    } else if (name === ROW_OBJECT) {\n      onReserve(ROW_OBJECT, 'function');\n    }\n  }\n  if (verifyFunction(name, fn, functions, options)) return;\n  functions[name] = fn;\n  opApi[name] = fn;\n}\n\n/**\n * Aggregate function definition.\n * @typedef {import('./aggregate-functions.js').AggregateDef} AggregateDef\n */\n\n/**\n * Window function definition.\n * @typedef {import('./window-functions.js').WindowDef} WindowDef\n */\n\n/**\n * Options for registering new functions.\n * @typedef {object} RegisterOptions\n * @property {boolean} [override=false] Flag indicating if the added\n *  function can override an existing function with the same name.\n */\n","import { error } from '../util/error.js';\nimport { isArray } from '../util/is-array.js';\nimport { isDate } from '../util/is-date.js';\nimport { isFunction } from '../util/is-function.js';\nimport { isObject } from '../util/is-object.js';\nimport { isRegExp } from '../util/is-regexp.js';\nimport { isString } from '../util/is-string.js';\n\n/**\n * @return {import('./types.js').ColumnData}\n */\nexport function columnsFrom(values, names) {\n  const raise = type => {\n    error(`Illegal argument type: ${type || typeof values}`);\n    return /** @type {import('./types.js').ColumnData} */({});\n  };\n  // @ts-ignore\n  return values instanceof Map ? fromKeyValuePairs(values.entries(), names)\n    : isDate(values) ? raise('Date')\n    : isRegExp(values) ? raise('RegExp')\n    : isString(values) ? raise()\n    : isArray(values) ? fromArray(values, names)\n    : isFunction(values[Symbol.iterator]) ? fromIterable(values, names)\n    : isObject(values) ? fromKeyValuePairs(Object.entries(values), names)\n    : raise();\n}\n\n/**\n * @param {Iterable<[any, any]>} entries\n * @param {string[]} names\n * @return {import('./types.js').ColumnData}\n */\nfunction fromKeyValuePairs(entries, names = ['key', 'value']) {\n  const keys = [];\n  const vals = [];\n\n  for (const [key, val] of entries) {\n    keys.push(key);\n    vals.push(val);\n  }\n\n  /** @type {import('./types.js').ColumnData} */\n  const columns = {};\n  if (names[0]) columns[names[0]] = keys;\n  if (names[1]) columns[names[1]] = vals;\n  return columns;\n}\n\n/**\n * @param {any[]} values\n * @param {string[]} names\n * @return {import('./types.js').ColumnData}\n */\nfunction fromArray(values, names) {\n  const len = values.length;\n  /** @type {import('./types.js').ColumnData} */\n  const columns = {};\n  const add = name => columns[name] = Array(len);\n\n  if (len) {\n    names = names || Object.keys(values[0]);\n    const cols = names.map(add);\n    const n = cols.length;\n    for (let idx = 0; idx < len; ++idx) {\n      const row = values[idx];\n      for (let i = 0; i < n; ++i) {\n        cols[i][idx] = row[names[i]];\n      }\n    }\n  } else if (names) {\n    names.forEach(add);\n  }\n\n  return columns;\n}\n\n/**\n * @param {Iterable<any>} values\n * @param {string[]} names\n * @return {import('./types.js').ColumnData}\n */\nfunction fromIterable(values, names) {\n  /** @type {import('./types.js').ColumnData} */\n  const columns = {};\n  const add = name => columns[name] = [];\n\n  let cols;\n  let n;\n  for (const row of values) {\n    if (!cols) {\n      names = names || Object.keys(row);\n      cols = names.map(add);\n      n = cols.length;\n    }\n    for (let i = 0; i < n; ++i) {\n      cols[i].push(row[names[i]]);\n    }\n  }\n\n  if (!cols && names) {\n    names.forEach(add);\n  }\n\n  return columns;\n}\n","import { rollup } from '../rollup.js';\nimport { ungroup } from '../ungroup.js';\n\n/**\n * Convenience function for computing a single aggregate value for\n * a table. Equivalent to ungrouping a table, applying a rollup verb\n * for a single aggregate, and extracting the resulting value.\n * @param {import('../../table/Table.js').Table} table A table instance.\n * @param {import('../../table/types.js').TableExpr} expr An\n *   aggregate table expression to evaluate.\n * @return {import('../../table/types.js').DataValue} The aggregate value.\n * @example agg(table, op.max('colA'))\n * @example agg(table, d => [op.min('colA'), op.max('colA')])\n */\nexport function agg(table, expr) {\n  return rollup(ungroup(table), { _: expr }).get('_');\n}\n","/**\n * Options for binning number values.\n * @typedef {object} BinOptions\n * @property {number} [maxbins] The maximum number of bins.\n * @property {number} [minstep] The minimum step size between bins.\n * @property {number} [step] The exact step size to use between bins.\n *  If specified, the maxbins and minstep options are ignored.\n * @property {boolean} [nice=true] Flag indicating if bins should\n *  snap to \"nice\" human-friendly values such as multiples of ten.\n * @property {number} [offset=0] Step offset for bin boundaries.\n *  The default floors to the lower bin boundary. A value of 1 snaps\n *  one step higher to the upper bin boundary, and so on.\n */\n\n/**\n * Generate a table expression that performs uniform binning of\n * number values. The resulting string can be used as part of the\n * input to table transformation verbs.\n * @param {string} name The name of the column to bin.\n * @param {BinOptions} [options] Binning scheme options.\n * @return {string} A table expression string for binned values.\n * @example bin('colA', { maxbins: 20 })\n */\nexport function bin(name, options = {}) {\n  const field = `d[${JSON.stringify(name)}]`;\n  const { maxbins, nice, minstep, step, offset } = options;\n  const args = [maxbins, nice, minstep, step];\n\n  let n = args.length;\n  while (n && args[--n] == null) args.pop();\n  const a = args.length ? ', ' + args.map(a => a + '').join(', ') : '';\n\n  return `d => op.bin(${field}, ...op.bins(${field}${a}), ${offset || 0})`;\n}\n","import { isFunction } from '../util/is-function.js';\nimport { wrap } from './wrap.js';\n\n/**\n * Annotate a table expression with collation metadata, indicating how\n * expression values should be compared and sorted. The orderby verb uses\n * collation metadata to determine sort order. The collation information can\n * either take the form a standard two-argument comparator function, or as\n * locale and option arguments compatible with `Intl.Collator`.\n * @param {string|Function|object} expr The table expression to annotate\n *  with collation metadata.\n * @param {Intl.LocalesArgument | ((a: any, b: any) => number)} comparator\n *  A comparator function or the locale(s) to collate by.\n * @param {Intl.CollatorOptions} [options] Collation options, applicable\n *  with locales only.\n * @return {object} A wrapper object representing the collated value.\n * @example orderby(collate('colA', 'de'))\n */\nexport function collate(expr, comparator, options) {\n  return wrap(expr, {\n    collate: isFunction(comparator)\n      ? comparator\n      : new Intl.Collator(comparator, options).compare\n  });\n}\n","import { wrap } from './wrap.js';\n\n/**\n * Annotate a table expression to indicate descending sort order.\n * @param {string|Function|object} expr The table expression to annotate.\n * @return {object} A wrapped expression indicating descending sort.\n * @example desc('colA')\n * @example desc(d => d.colA)\n */\nexport function desc(expr) {\n  return wrap(expr, { desc: true });\n}\n","import { wrap } from './wrap.js';\nimport { error } from '../util/error.js';\n\n/**\n * Escape a function or value to prevent it from being parsed and recompiled.\n * This helper can be used in lieu of single-table table expressions (which\n * are internally parsed and rewritten) to apply a JavaScript function as-is,\n * including support for closures. It can also be used to pass a constant,\n * literal value as a table expression, bypassing the parser.\n * @param {*} value A function or value to escape.\n * @return {object} A wrapper object representing the escaped value.\n * @example escape(d => d.a.toFixed(2))\n * @example escape(d => d.a * -d.b)\n */\nexport function escape(value) {\n  return wrap(value, {\n    escape: true,\n    toString() { error('Escaped values can not be serialized.'); }\n  });\n}\n","/**\n * Generate a table expression that computes the number of rows\n * corresponding to a given fraction for each group. The resulting\n * string can be used as part of the input to the sample verb.\n * @param {number} fraction The fractional value.\n * @return {string} A table expression string for computing row counts.\n * @example frac(0.5)\n */\nexport function frac(fraction) {\n  return `() => op.round(${+fraction} * op.count())`;\n}\n","import { entries } from '../util/entries.js';\nimport { ColumnTable } from './ColumnTable.js';\nimport { columnsFrom } from './columns-from.js';\n\n/**\n * Create a new table for a set of named columns.\n * @param {object|Map} columns\n *  The set of named column arrays. Keys are column names.\n *  The enumeration order of the keys determines the column indices,\n *  unless the names parameter is specified.\n *  Values must be arrays (or array-like values) of identical length.\n * @param {string[]} [names] Ordered list of column names. If specified,\n *  this array determines the column indices. If not specified, the\n *  key enumeration order of the columns object is used.\n * @return {ColumnTable} the instantiated table\n * @example table({ colA: ['a', 'b', 'c'], colB: [3, 4, 5] })\n */\nexport function table(columns, names) {\n  if (columns instanceof ColumnTable) return columns;\n  /** @type {import('./types.js').ColumnData} */\n  const data = {};\n  const keys = [];\n  for (const [key, value] of entries(columns)) {\n    data[key] = value;\n    keys.push(key);\n  }\n  return new ColumnTable(data, names || keys);\n}\n\n/**\n * Create a new table from an existing object, such as an array of\n * objects or a set of key-value pairs.\n * @param {object|Array|Map} values Data values to populate the table.\n *  If array-valued or iterable, imports rows for each non-null value,\n *  using the provided column names as keys for each row object. If no\n *  names are provided, the first non-null object's own keys are used.\n *  If object- or Map-valued, create columns for the keys and values.\n * @param {string[]} [names] Column names to include.\n *  For object or Map values, specifies the key and value column names.\n *  Otherwise, specifies the keys to look up on each row object.\n * @return {ColumnTable} the instantiated table.\n * @example from([ { colA: 1, colB: 2 }, { colA: 3, colB: 4 } ])\n */\nexport function from(values, names) {\n  return new ColumnTable(columnsFrom(values, names), names);\n}\n","/**\n * Select columns by index and rename them to the provided names. Returns a\n * selection helper function that takes a table as input and produces a\n * rename map as output. If the number of provided names is less than the\n * number of table columns, the rename map will only include entries for the\n * provided names. If the number of table columns is less than then number of\n * provided names, only the rename map will only include entries that cover\n * the existing columns.\n * @param {...(string|string[])} names An ordered list of column names.\n * @return {Function} Selection function compatible with {@link Table#select}.\n * @example table.rename(aq.names('a', 'b', 'c'))\n * @example table.select(aq.names(['a', 'b', 'c']))\n */\nexport function names(...names) {\n  names = names.flat();\n  return table => {\n    const m = new Map();\n    const n = Math.min(names.length, table.numCols());\n    for (let i = 0; i < n; ++i) {\n      m.set(table.columnName(i), names[i]);\n    }\n    return m;\n  };\n}\n","import { wrap } from './wrap.js';\n\n/**\n * Annotate a table expression to compute rolling aggregate or window\n * functions within a sliding window frame. For example, to specify a\n * rolling 7-day average centered on the current day, use rolling with\n * a frame value of [-3, 3].\n * @param {string|Function|object} expr The table expression to annotate.\n * @param {[number?, number?]} [frame=[-Infinity, 0]] The sliding window frame\n *  offsets. Each entry indicates an offset from the current value. If an\n *  entry is non-finite, the frame will be unbounded in that direction,\n *  including all preceding or following values. If unspecified, the frame\n *  will include the current values and all preceding values.\n * @param {boolean} [includePeers=false] Indicates if the sliding window frame\n *  should ignore peer (tied) values. If false (the default), the window frame\n *  boundaries are insensitive to peer values. If `true`, the window frame\n *  expands to include all peers. This parameter only affects operations that\n *  depend on the window frame: aggregate functions and the first_value,\n *  last_value, and nth_value window functions.\n * @return A new wrapped expression annotated with rolling window parameters.\n * @example rolling(d => mean(d.colA), [-3, 3])\n * @example rolling(d => last_value(d.colA), null, true)\n */\nexport function rolling(expr, frame, includePeers) {\n  return wrap(expr, {\n    window: {\n      frame: frame || [-Infinity, 0],\n      peers: !!includePeers\n    }\n  });\n}\n"],"names":["ONE","BitSet","constructor","size","this","_size","_bits","Uint32Array","Math","ceil","length","count","n","i","b","get","set","clear","scan","fn","next","bits","index","curr","clz32","nth","not","tail","and","bitset","a","or","isDate","value","Date","isRegExp","RegExp","isObject","Object","equal","getPrototypeOf","arrayEqual","keysA","keys","keysB","sort","k","deepEqual","test","sequence","start","stop","step","arguments","max","seq","Array","NULL","undefined","isArray","TypedArray","Int8Array","isTypedArray","isArrayType","isString","isValid","isSeq","array","filter","v","values","concat","includes","indexOf","delim","join","lastIndexOf","property","map","slice","reverse","split","end","pad","width","char","s","len","pad2","formatYear","year","formatISO","month","date","hours","min","sec","ms","utc","short","suffix","formatDate","d","isNaN","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","formatUTCDate","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","iso_re","isISODateString","match","parse","msDay","msWeek","t0","t1","t","setTime","parseISODate","minutes","seconds","milliseconds","now","getDay","setHours","setMonth","setDate","tz","getTimezoneOffset","floor","shorten","UTC","getUTCDay","setUTCHours","firstday","setUTCDate","setUTCMonth","JSON","stringify","source","random","abs","acos","acosh","asin","asinh","atan","y","x","atan2","atanh","cbrt","cos","cosh","radians","PI","exp","expm1","fround","Number","isFinite","log","log10","log1p","log2","base","exponent","pow","degrees","_random","round","sign","sin","sinh","sqrt","tan","tanh","trunc","isMap","Map","isMapOrSet","Set","isSet","iter","from","object","entries","key","has","hasOwn","fromEntries","search","String","endsWith","toLowerCase","regexp","m","groups","form","normalize","fill","padEnd","padStart","parseFloat","radix","parseInt","number","repeat","pattern","replacement","replace","separator","limit","position","startsWith","substring","trim","toUpperCase","functions","bin","offset","Infinity","recode","fallback","json","math","string","toArray","isBigInt","toString","Op$1","name","fields","params","args","f","toObject","expr","func","op","Op","any","field","array_agg","array_agg_distinct","map_agg","object_agg","entries_agg","opApi","row_object","names","flat","valid","invalid","distinct","mode","sum","product","mean","average","variance","variancep","stdev","stdevp","quantile","p","median","covariance","field1","field2","covariancep","corr","bins","maxbins","nice","minstep","row_number","rank","avg_rank","dense_rank","percent_rank","cume_dist","ntile","num","lag","defaultValue","lead","first_value","last_value","nth_value","fill_down","fill_up","error","message","cause","Error","isFunction","reps","result","type","objectKey","keyFunction","nulls","row","data","noop","initOp","init","add","rem","initProduct","product_v","aggregateFunctions","create","param","list","stream","_","increment","e","decrement","delete","forEach","distinctMap","req","prod","mean_d","dev","NaN","cov","mean_x","mean_y","dev_x","dev_y","dx","dy","dy2","logb","LN10","level","span","div","precision","eps","w","peer","cume","windowFunctions","j","drank","i0","i1","idx","find","hasAggregate","hasWindow","hasFunction","getAggregate","getWindow","unroll","code","lists","push","l","Function","ascending","toNumeric","ValueList","_values","_sorted","_start","copy","v0","Reducer","outputs","_outputs","columns","state","write","update","ops","fieldReducer","oplist","output","def","item","id","expand","FieldReducer","Field1Reducer","Field2Reducer","super","_op","_fields","_stream","_add","_rem","value1","value2","aggregateGet","table","aggregate","aggrs","reducers","aggr","cells","reduceGroups","cell","reduceFlat","reducer","mask","isOrdered","indices","totalRows","isFiltered","groupOutput","cols","rows","col","val","ArrowFunctionExpression","FunctionExpression","Identifier","Literal","MemberExpression","ObjectExpression","ObjectPattern","Property","Column","Constant","Dictionary","Parameter","walk","node","ctx","visitors","parent","visit","walker","walkers","unary","argument","binary","left","right","ternary","consequent","alternate","body","call","callee","nodes","TemplateLiteral","expressions","quasis","CallExpression","NewExpression","ArrayExpression","elements","AssignmentExpression","AwaitExpression","BinaryExpression","LogicalExpression","UnaryExpression","UpdateExpression","ConditionalExpression","properties","FunctionDeclaration","VariableDeclaration","declarations","VariableDeclarator","SpreadElement","BlockStatement","ExpressionStatement","expression","IfStatement","ForStatement","WhileStatement","DoWhileStatement","SwitchStatement","discriminant","cases","SwitchCase","ReturnStatement","Program","strip","optional","stripMember","computed","is","opt","operator","ref","method","raw","o","ArrayPattern","kind","BreakStatement","codegen","_compile","compile","escape","expr2","dictOps","rewrite","keyFor","lit","rewriteDictionary","ROW_OBJECT","rowObjectExpression","props","columnNames","prop","column","rowObjectCode","rowObjectBuilder","ERROR_ESC_AGGRONLY","parseEscape","spec","aggronly","astralIdentifierCodes","astralIdentifierStartCodes","nonASCIIidentifierStartChars","reservedWords","strict","strictBind","ecma5AndLessKeywords","keywords$1","keywordRelationalOperator","nonASCIIidentifierStart","nonASCIIidentifier","isInAstralSet","pos","isIdentifierStart","astral","fromCharCode","isIdentifierChar","TokenType","label","conf","keyword","beforeExpr","startsExpr","isLoop","isAssign","prefix","postfix","binop","updateContext","prec","keywords","kw","options","types$1","privateId","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","questionDot","arrow","template","invalidTemplate","ellipsis","backQuote","dollarBraceL","eq","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","coalesce","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","lineBreakG","isNewLine","nextLineBreak","charCodeAt","nonASCIIwhitespace","skipWhiteSpace","prototype","hasOwnProperty","obj","propName","regexpCache","wordsRegexp","words","codePointToString","loneSurrogate","Position","line","SourceLocation","sourceFile","getLineInfo","input","cur","nextBreak","defaultOptions","ecmaVersion","sourceType","onInsertedSemicolon","onTrailingComma","allowReserved","allowReturnOutsideFunction","allowImportExportEverywhere","allowAwaitOutsideFunction","allowSuperOutsideMethod","allowHashBang","checkPrivateFields","locations","onToken","onComment","ranges","program","directSourceFile","preserveParens","warnedAboutEcmaVersion","getOptions","opts","console","warn","tokens","token","block","text","startLoc","endLoc","comment","loc","range","pushComment","SCOPE_CLASS_STATIC_BLOCK","SCOPE_VAR","SCOPE_TOP","functionFlags","async","generator","Parser","startPos","reserved","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","lineStart","curLine","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","context","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","potentialArrowInForAwait","yieldPos","awaitPos","awaitIdentPos","labels","undefinedExports","skipLineComment","scopeStack","enterScope","regexpState","privateNameStack","prototypeAccessors","inFunction","configurable","inGenerator","inAsync","canAwait","allowSuper","allowDirectSuper","treatFunctionsAsVar","allowNewDotTarget","inClassStaticBlock","startNode","nextToken","parseTopLevel","currentVarScope","flags","currentThisScope","treatFunctionsAsVarInScope","currentScope","extend","plugins","cls","parseExpressionAt","parser","parseExpression","tokenizer","defineProperties","pp$9","literal","lastIndex","exec","spaceAfter","charAt","eat","isContextual","eatContextual","expectContextual","unexpected","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","expect","raise","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","doubleProto","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","pp$8","exports","stmt","parseStatement","adaptDirectivePrologue","finishNode","loopLabel","switchLabel","isLet","skip","nextCh","ident","isAsyncFunction","after","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseExpressionStatement","parseImport","parseExport","maybeName","parseLabeledStatement","isBreak","parseIdent","lab","pop","parseParenExpression","awaitAt","parseFor","init$1","parseVar","await","parseForIn","startsWithLet","isForOf","initPos","parseExprSubscripts","toAssignable","checkLValPattern","isAsync","declarationPosition","parseFunction","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","sawDefault","isCase","exitScope","empty$1","parseCatchClauseParam","parseBindingAtom","simple","handler","clause","finalizer","allowMissingInitializer","i$1","label$1","statementStart","createNewLexicalScope","exitStrict","isForIn","parseMaybeAssign","isFor","decl","parseVarId","isPrivateNameConflicted","privateNameMap","element","static","checkKeyName","statement","allowExpressionBody","forInit","initFunction","checkLValSimple","oldYieldPos","oldAwaitPos","oldAwaitIdentPos","parseFunctionParams","parseFunctionBody","parseBindingList","isStatement","oldStrict","parseClassId","parseClassSuper","enterClassBody","classBody","hadConstructor","parseClassElement","superClass","exitClassBody","constructorAllowsSuper","keyName","isGenerator","isStatic","parseClassStaticBlock","isClassElementNameStart","lastValue","startNodeAt","parseClassElementName","isConstructor","allowsDirectSuper","parseClassMethod","parseClassField","parsePrivateIdent","parsePropertyName","parseMethod","SCOPE_CLASS_FIELD_INIT","oldLabels","declared","used","parseExportAllDeclaration","exported","parseModuleExportName","checkExport","parseExprAtom","attributes","parseWithClause","declaration","parseExportDefaultDeclaration","shouldParseExportStatement","parseExportDeclaration","checkVariableExport","specifiers","parseExportSpecifiers","checkUnreserved","local","checkLocalExport","fNode","cNode","checkPatternExport","pat","list$1","elt","decls","parseExportSpecifier","first","parseImportSpecifiers","parseImportSpecifier","imported","parseImportDefaultSpecifier","parseImportNamespaceSpecifier","attributeKeys","attr","parseImportAttribute","stringLiteral","parseLiteral","statements","isDirectiveCandidate","directive","pp$7","isBinding","toAssignableList","exprList","last","parseSpread","parseRestBinding","parseObj","close","allowEmpty","allowTrailingComma","allowModifiers","elts","rest","parseBindingListItem","parseAssignableListItem","elem","parseMaybeDefault","bindingType","checkClashes","isBind","declareName","checkLValInnerPattern","TokContext","isExpr","preserveSpace","override","types","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","tryReadTemplateToken","f_stat","f_expr","f_expr_gen","f_gen","pp$6","curContext","braceIsBlock","prevType","inGeneratorContext","overrideContext","tokenCtx","out","statementParens","allowed","pp$5","isLocalVariableAccess","isPrivateFieldAccess","checkPropClash","propHash","shorthand","proto","other","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","oldTrailingComma","oldDoubleProto","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","buildBinary","sawUnary","parseAwait","node$1","parseSubscripts","noCalls","maybeAsyncArrow","optionalChained","parseSubscript","chainNode","shouldParseAsyncArrow","parseSubscriptAsyncArrow","parseArrowExpression","optionalSupported","parseExprList","node$2","tag","quasi","parseTemplate","isTagged","forNew","readRegexp","canBeArrow","regex","parseParenAndDistinguishExpression","parseNew","parseExprImport","parseExprAtomDefault","parseDynamicImport","meta","parseImportMeta","errorPos","bigint","shouldParseArrow","spreadStart","innerStartPos","innerStartLoc","lastIsComma","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","finishNodeAt","par","empty","parseTemplateElement","cooked","curElt","isAsyncProp","isPattern","parseProperty","parsePropertyValue","parseGetterSetter","paramCount","copyNode","isArrowFunction","isMethod","isExpression","useStrict","checkParams","nonSimple","isSimpleParamList","allowDuplicates","nameHash","liberal","parseIdentNode","delegate","pp$4","err","SyntaxError","raisedAt","pp$3","Scope","var","lexical","scope","redeclared","scope$2","scope$3","Node","pp$2","newNode","ecma9BinaryProperties","ecma10BinaryProperties","ecma12BinaryProperties","unicodeBinaryProperties","unicodeBinaryPropertiesOfStrings","unicodeGeneralCategoryValues","ecma9ScriptValues","ecma10ScriptValues","ecma11ScriptValues","ecma12ScriptValues","ecma13ScriptValues","unicodeScriptValues","buildUnicodeData","binaryOfStrings","nonBinary","General_Category","Script","Script_Extensions","gc","sc","scx","pp$1","BranchID","separatedFrom","alt","self","sibling","RegExpValidationState","validFlags","unicodeProperties","switchU","switchV","switchN","lastIntValue","lastStringValue","lastAssertionIsQuantifiable","numCapturingParens","maxBackReference","groupNames","backReferenceNames","branchID","isRegularExpressionModifier","ch","isSyntaxCharacter","isControlLetter","reset","unicodeSets","unicode","at","forceU","c","nextIndex","current","lookahead","advance","eatChars","chs","validateRegExpFlags","u","flag","validateRegExpPattern","regexp_pattern","hasProp","regexp_disjunction","trackDisjunction","regexp_alternative","regexp_eatQuantifier","regexp_eatTerm","regexp_eatAssertion","regexp_eatAtom","regexp_eatExtendedAtom","lookbehind","noError","regexp_eatQuantifierPrefix","regexp_eatBracedQuantifier","regexp_eatDecimalDigits","regexp_eatPatternCharacters","regexp_eatReverseSolidusAtomEscape","regexp_eatCharacterClass","regexp_eatUncapturingGroup","regexp_eatCapturingGroup","regexp_eatAtomEscape","addModifiers","regexp_eatModifiers","hasHyphen","modifier","removeModifiers","modifier$1","regexp_groupSpecifier","modifiers","regexp_eatInvalidBracedQuantifier","regexp_eatExtendedPatternCharacter","regexp_eatSyntaxCharacter","regexp_eatGroupName","known","regexp_eatRegExpIdentifierName","regexp_eatRegExpIdentifierStart","regexp_eatRegExpIdentifierPart","regexp_eatRegExpUnicodeEscapeSequence","isRegExpIdentifierStart","isRegExpIdentifierPart","regexp_eatBackReference","regexp_eatCharacterClassEscape","regexp_eatCharacterEscape","regexp_eatKGroupName","regexp_eatDecimalEscape","regexp_eatControlEscape","regexp_eatCControlLetter","regexp_eatZero","regexp_eatHexEscapeSequence","regexp_eatLegacyOctalEscapeSequence","regexp_eatIdentityEscape","regexp_eatControlLetter","isDecimalDigit","regexp_eatFixedHexDigits","leadSurrogateEnd","trail","regexp_eatHexDigits","isUnicodePropertyNameCharacter","isUnicodePropertyValueCharacter","isHexDigit","hexToInt","isOctalDigit","isCharacterClassEscape","negate","regexp_eatUnicodePropertyValueExpression","regexp_eatUnicodePropertyName","regexp_eatUnicodePropertyValue","regexp_validateUnicodePropertyNameAndValue","regexp_eatLoneUnicodePropertyNameOrValue","nameOrValue","regexp_validateUnicodePropertyNameOrValue","regexp_classContents","regexp_classSetExpression","regexp_nonEmptyClassRanges","regexp_eatClassAtom","regexp_eatClassEscape","ch$1","regexp_eatClassControlLetter","subResult","regexp_eatClassSetRange","regexp_eatClassSetOperand","regexp_eatClassSetCharacter","regexp_eatClassStringDisjunction","regexp_eatNestedClass","result$1","regexp_classStringDisjunctionContents","regexp_classString","regexp_eatClassSetReservedPunctuator","isClassSetReservedDoublePunctuatorCharacter","isClassSetSyntaxCharacter","isClassSetReservedPunctuator","regexp_eatOctalDigit","n1","n2","Token","pp","stringToBigInt","str","BigInt","ignoreEscapeSequenceInKeyword","getToken","Symbol","iterator","this$1$1","done","skipSpace","finishToken","readToken","fullCharCodeAtPos","readWord","getTokenFromCode","skipBlockComment","startSkip","loop","readToken_dot","readNumber","next2","readToken_slash","finishOp","readToken_mult_modulo_exp","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readToken_question","readToken_numberSign","readWord1","readRadixNumber","readString","escaped","inClass","flagsStart","readInt","maybeLegacyOctalNumericLiteral","allowSeparators","isLegacyOctalNumericLiteral","total","lastCode","startsWithDot","octal","val$1","readCodePoint","codePos","readHexChar","invalidStringToken","quote","chunkStart","readEscapedChar","INVALID_TEMPLATE_ESCAPE_ERROR","inTemplateElement","readTmplToken","readInvalidTemplateToken","inTemplate","octalStr","substr","word","escStart","esc","acorn","version","tokTypes","keywordTypes","tokContexts","constants","E","LN2","LOG2E","LOG10E","SQRT1_2","SQRT2","isNumber","PARSER_OPT","DEFAULT_PARAM_ID","DEFAULT_TUPLE_ID","DEFAULT_TUPLE_ID1","DEFAULT_TUPLE_ID2","NO","msg","ERROR_AGGREGATE","ERROR_WINDOW","ERROR_ARGUMENT","ERROR_COLUMN","ERROR_AGGRONLY","ERROR_FUNCTION","ERROR_OP_PARAMETER","ERROR_DESTRUCTURE","ERROR_CLOSURE","ERROR_ESCAPE","ERROR_VARIABLE_NOTE","ERROR_FUNCTION_NOTE","ERROR_ROW_OBJECT","ast","fieldRef","parseAST","root","tuple","tuple1","tuple2","$param","$op","paramsRef","columnRef","isFunctionExpression","setc","setp","parseRef","ForOfStatement","ForInStatement","handleDeclaration","handleIdentifier","functionName","window","updateFunctionNode","arg","opVisitors","idxFields","idxParams","parseOperator","isMath","updateConstantNode","spliceMember","checkColumn","checkParam","updateParameterNode","updateColumnNode","check","refName","alias","rewriteMath","columnName","elm","ANNOTATE","Column$1","generate","compiler","getTableParams","getParams","opcall","exprs","fieldId","opId","compileExpr","frame","peers","opKey","Default","note","wrap","Wrapper","pairs","escapeRegExp","resolve","sel","r","decorate","all","selection","drop","matches","parseValue","marshal","preparse","groupby","createGroups","_groupby","getKey","nrows","columnSet","ColumnSet","order","derive","rollup","_rollup","new","select","_select","nest","agg","uname","uniqueName","reify","Table$1","group","freeze","_names","_data","_total","_nrows","_mask","_group","_order","_params","_index","_partitions","reduce","_rows","_keys","regroup","toStringTag","nr","numRows","nc","numCols","plural","isGrouped","comparator","columnIndex","columnAt","getter","objectBuilder","objects","grouped","createRow","print","ordered","partitions","part","compare","ncols","prev","Int32Array","reindex","_builder","others","trows","tables","arr","trow","relocate","before","bef","aft","anchors","anchor","bisector","lo","hi","mid","bisect","frameValue","peersValue","states","aggOps","winOps","windowOp","adjust","isPeer","numOps","numAgg","evaluate","partition","results","f0","f1","p0","p1","windowState","windowStates","nstate","windowPeers","isWindowed","_derive","segmentOps","criteria","predicate","_filter","dedupe","ungroup","rowLookup","hash","lut","parseKey","inferKeys","tableL","tableR","on","isect","intersect","keyPredicate","onL","onR","semijoin","join_filter","anti","antijoin","hashSemiJoin","loopSemiJoin","_join_filter","keyL","keyR","rowL","nL","nR","dataL","dataR","idxL","idxR","_unroll","nset","priors","copies","icol","maxlen","arrays","fold","as","vals","_fold","_impute","keyNames","keyGet","keyTable","old","keyEnum","enumerate","vec","gets","callback","lens","idxs","OPT_R","NONE","optParse","vR","shared","inferValues","hitL","hitR","getters","emit","emitter","hashJoin","loopJoin","_join","vL","vJ","rename","namesL","rekey","parseValues","rowR","dataScan","keyScan","hitScan","idxScan","dataHash","keyHash","hitHash","idxHash","emitScan","indexLookup","rowScan","lookup","lrow","rrow","_lookup","_compare","lt","gt","_collate","orderby","_orderby","opA","opB","desc","collate","pivot","keyColumn","ksep","keySeparator","kcol","uniq","pivotKeys","vsep","valueSeparator","namefn","_pivot","sample","buffer","weight","sampleRW","sampleRU","sampleNW","sampleNU","Float64Array","Float32Array","shuffle","parts","samples","sz","buf","subarray","sampleIndices","shuffleIndices","_sample","parseSize","parseWeight","prep","_slice","spread","spreadCols","_spread","MAGIC","Uint8Array","of","EOS","Version","V1","V4","V5","Endianness","Little","MessageHeader","Schema","DictionaryBatch","RecordBatch","Tensor","SparseTensor","Type","Null","Int","Float","Binary","Utf8","Bool","Decimal","Time","Timestamp","Interval","List","Struct","Union","FixedSizeBinary","FixedSizeList","Duration","LargeBinary","LargeUtf8","LargeList","RunEndEncoded","BinaryView","Utf8View","ListView","LargeListView","Precision","HALF","SINGLE","DOUBLE","DateUnit","DAY","MILLISECOND","TimeUnit","SECOND","MICROSECOND","NANOSECOND","IntervalUnit","YEAR_MONTH","DAY_TIME","MONTH_DAY_NANO","UnionMode","Sparse","Dense","uint8Array","uint16Array","Uint16Array","uint32Array","uint64Array","BigUint64Array","int8Array","int16Array","Int16Array","int32Array","int64Array","BigInt64Array","float32Array","float64Array","intArrayType","bitWidth","signed","isInt64ArrayType","offsets","resize","newLength","newArray","grow","shift","checkOneOf","invalidDataType","typeId","nullable","metadata","isField","isDataType","asField","defaultName","defaultNullable","basicType","dictionary","indexType","int32","nullType","int","int8","int16","int64","uint8","uint16","uint32","uint64","float","float32","float64","utf8","bool","decimal","scale","unit","dateDay","time","timestamp","timezone","interval","child","children","struct","union","typeIds","typeIdForValue","typeMap","fixedSizeBinary","stride","fixedSizeList","mapType","keysSorted","duration","largeBinary","largeUtf8","largeList","runEndEncoded","runsField","valuesField","listView","largeListView","f64","i64","u32","i32","u8","identity","toBigInt","toOffset","toDateDay","toNumber","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","divide","asUint64","asUintN","fromDecimal64","asIntN","fromDecimal128","fromDecimal256","toFloat16","expo","sigf","textDecoder","TextDecoder","textEncoder","TextEncoder","decodeUtf8","decode","encodeUtf8","encode","keyString","SIZEOF_INT","decodeBit","bitmap","readObject","readInt32","vtable","readInt16","read","off","readOffset","readBoolean","readUint8","readInt8","readUint16","readUint32","readInt64","readVector","extract","RowIndex","proxyFactory","batches","RowObject","toJSON","structObject","batch","defineProperty","enumerable","objectFactory","Batch","nullCount","validity","sizes","DirectBatch","NumberBatch","ArrayBatch","NullBatch","Int64Batch","Float16Batch","BoolBatch","Decimal32NumberBatch","DecimalBatch","DecimalNumberBatch","DecimalBigIntBatch","DateBatch","DateDayBatch","DateDayMillisecondBatch","TimestampSecondBatch","TimestampMillisecondBatch","TimestampMicrosecondBatch","TimestampNanosecondBatch","IntervalDayTimeBatch","IntervalMonthDayNanoBatch","offset32","offset64","BinaryBatch","LargeBinaryBatch","Utf8Batch","LargeUtf8Batch","ListBatch","LargeListBatch","ListViewBatch","LargeListViewBatch","FixedBatch","FixedBinaryBatch","FixedListBatch","MapEntryBatch","MapBatch","SparseUnionBatch","DenseUnionBatch","StructBatch","factory","StructProxyBatch","RunEndEncodedBatch","runs","setDictionary","cache","ViewBatch","view","BinaryViewBatch","Utf8ViewBatch","columnBuilder","batchedIterator","ArrayType","copyArray","extractArray","_cache","Table","schema","useProxy","gen","getFactory","getChildAt","getChild","findIndex","selectAt","renameField","toColumns","batchType","useBigInt","useDate","useDecimalInt","useMap","BaseClass","WrapperClass","decodeBlock","metadataLength","bodyLength","decodeBlocks","decodeRecordBatch","regions","variadic","decodeDictionaryBatch","isDelta","decodeDataType","decodeMetadata","decodeSchema","endianness","decodeSchemaFields","fieldsOffset","decodeField","typeOffset","dict","decodeDictionary","fieldOffset","decodeFieldChildren","decodeInt","invalidMessageMetadata","expected","actual","invalidMessageBodyLength","invalidMessageType","decodeMessage","head","byteLength","content","decoder","decodeIPC","ArrayBuffer","isArrowFileFormat","dicts","recs","dictionaries","records","decodeIPCFile","decodeIPCStream","tableFromIPC","dictionaryMap","nodeIndex","bufferIndex","variadicIndex","byteOffset","BYTES_PER_ELEMENT","contextGenerator","dictionaryTypes","visitor","visitField","visitSchemaFields","createTable","BatchType","writeInt32","INIT_SIZE","Builder","sink","minalign","space","vtables","outputBytes","writeInt8","writeInt16","writeInt64","addInt8","addInt16","addInt32","addInt64","addOffset","addObject","numFields","addFields","builder","startOffset","slot","finish","vtableOffset","standardFields","existingTable","vt1","outer_loop","vt2","addVector","items","itemSize","alignment","writeItem","addOffsetVector","addString","rootOffset","flush","bytes","addBuffer","addPadding","byteCount","additionalBytes","bufSize","alignSize","encodeRecordBatch","nodeVector","regionVector","region","variadicVector","encodeDictionaryBatch","dictionaryBatch","dataOffset","encodeMetadata","encodeDataType","encodeDictionary","encodeInt","encodeFloat","encodeDecimal","encodeDate","encodeTime","timezoneOffset","encodeTimestamp","encodeInterval","encodeDuration","encodeFixedSize","encodeMap","typeIdsOffset","encodeUnion","isLittleEndian","encodeSchema","fieldOffsets","encodeField","fieldsVectorOffset","metadataOffset","dictionaryOffset","childOffsets","childrenVectorOffset","nameOffset","encodeBlock","writeMessage","headerType","headerOffset","blocks","messageSize","alignedSize","Sink","MemorySink","buffers","bufs","STREAM","FILE","encodeIPC","format","file","dictBlocks","recordBlocks","writeBuffers","recsOffset","dictsOffset","schemaOffset","writeFooter","tableToIPC","some","checkBatchLengths","idMap","dictMap","dictionaryColumn","assembleRecordBatch","visitDictionaries","assembleDictionaryBatches","assembleRecordBatches","visitDictType","visitFields","parentType","assembleSchema","batchIndex","assembleContext","arrayType","Buffer","alignedLength","bpe","align64","align","Bitmap","BatchBuilder","batchClass","ValidityBuilder","dictionaryContext","dictionaryValues","DictionaryBuilder","inferType","profile","profiler","minBigInt","maxBigInt","arrayProfile","boolCount","numberCount","intCount","bigintCount","dateCount","dayCount","stringCount","arrayCount","structCount","minLength","maxLength","structProfiles","isInteger","intType","bigintType","unionType","BinaryBuilder","BoolBuilder","DecimalBuilder","toDecimal","FixedSizeBinaryBuilder","FixedSizeListBuilder","IntervalDayTimeBuilder","IntervalMonthDayNanoBuilder","toMonthDayNanoBytes","AbstractListBuilder","offsetType","ListBuilder","AbstractStructBuilder","StructBuilder","setters","MapBuilder","MapStructBuilder","keyValuePair","NO_VALUE","RunEndEncodedBuilder","AbstractUnionBuilder","SparseUnionBuilder","DenseUnionBuilder","Utf8Builder","DirectBuilder","Int64Builder","TransformBuilder","transform","builderContext","columnFromValues","maxBatchRows","numBatches","nullBatches","columnFromArray","typeForTypedArray","columnFromTypedArray","toArrow","fullScan","tableFromColumns","toArrowIPC","toArrowOptions","toCSV","delimiter","header","reFormat","formatValue","formats","formatOpt","alignOpt","auto","dates","dutcs","nums","digits","maxdigits","inferFormat","toExponential","toFixed","toHTML","style","mapObject","styles","nullish","null","baseFormat","formatter","shouldAlign","alignValue","css","EOL","BREAK","QUOTE","NEWLINE","RETURN","COLUMNS","NDJSON","defaultFormatter","fmt","nd","replaceAll","sep","toRows","toMarkdown","ColumnTable","dt","counts","unorder","impute","join_left","join_right","join_full","cross","except","compressionType","path","ext","byteStream","url","fetch","fopt","decompress","then","pipeThrough","DecompressionStream","streamIterator","asyncIterator","reader","getReader","collectJSON","ReadableStream","chunk","collectText","fromArrow","flatten","byte","nullBitmap","nullKeys","dictKeys","fromArrowStream","collectBytes","unquote","delimitedTextTransformer","delimCode","I","N","qc","eol","skipNewline","inQuote","fragment","addFragment","jq","q","quoted","controller","enqueue","lineFilterTransformer","accessor","shouldDrop","parseBoolean","parseNumber","parseDate","numberParser","pipelineStream","transformers","TransformStream","pipelineSync","chunks","desiredSize","reason","terminate","toTable","parseTextRowsSync","parseTextRowBatches","parseTextRowsStream","automax","autoMax","parsers","defaultNames","noParse","autoType","getParsers","textStream","TextDecoderStream","fromCSVStream","transforms","fixedTextTransformer","positions","textLineTransformer","parseLine","lines","fromFixedStream","widths","breaks","isDigitString","toColumnData","parseJSONColumns","firstNonNull","parseJSONRowBatch","fromJSON","parseJSONSync","parseJSONRows","postprocessJSON","fromJSONStream","parseJSONStream","onIllegal","onDefined","verifyFunction","addOp","nf","np","columnsFrom","fromKeyValuePairs","fromArray","fromIterable","onReserve","Intl","Collator","fraction","includePeers","seed","lcg"],"mappings":"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AG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,KAAM,EAAG,EAAG,GAAI,MAAO,GAAI,KAAM,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,IAAK,EAAG,IAAK,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,MAAO,EAAG,KAAM,EAAG,IAAK,GAAI,EAAG,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,EAAG,KAAM,GAAI,IAAK,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,EAAG,GAAI,EAAG,IAAK,EAAG,GAAI,GAAI,IAAK,GAAI,IAAK,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,KAAM,EAAG,OAAQ,KAGloCC,GAA6B,CAAC,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,IAAK,GAAI,GAAI,IAAK,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,IAAK,EAAG,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,KAAM,GAAI,GAAI,KAAM,GAAI,EAAG,GAAI,KAAM,EAAG,IAAK,KAAM,GAAI,KAAM,IAAK,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,GAAI,IAAK,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,KAAM,EAAG,KAAM,GAAI,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAA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","x_google_ignoreList":[66,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,168]}