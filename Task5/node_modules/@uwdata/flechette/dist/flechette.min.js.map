{"version":3,"file":"flechette.min.js","sources":["../src/constants.js","../src/util/arrays.js","../src/util/objects.js","../src/data-types.js","../src/util/numbers.js","../src/util/strings.js","../src/util/read.js","../src/util/struct.js","../src/batch.js","../src/column.js","../src/table.js","../src/batch-type.js","../src/decode/block.js","../src/decode/record-batch.js","../src/decode/dictionary-batch.js","../src/decode/data-type.js","../src/decode/metadata.js","../src/decode/schema.js","../src/decode/message.js","../src/decode/decode-ipc.js","../src/decode/table-from-ipc.js","../src/encode/builder.js","../src/encode/record-batch.js","../src/encode/dictionary-batch.js","../src/encode/metadata.js","../src/encode/data-type.js","../src/encode/schema.js","../src/encode/footer.js","../src/encode/message.js","../src/encode/sink.js","../src/encode/encode-ipc.js","../src/encode/table-to-ipc.js","../src/build/buffer.js","../src/build/builders/batch.js","../src/build/builders/validity.js","../src/build/builders/dictionary.js","../src/build/infer-type.js","../src/build/builders/binary.js","../src/build/builders/bool.js","../src/build/builders/decimal.js","../src/build/builders/fixed-size-binary.js","../src/build/builders/fixed-size-list.js","../src/build/builders/interval.js","../src/build/builders/list.js","../src/build/builders/struct.js","../src/build/builders/map.js","../src/build/builders/run-end-encoded.js","../src/build/builders/union.js","../src/build/builders/utf8.js","../src/build/builders/values.js","../src/build/builder.js","../src/build/column-from-values.js","../src/build/column-from-array.js","../src/build/table-from-columns.js","../src/build/table-from-arrays.js"],"sourcesContent":["/** Magic bytes 'ARROW1' indicating the Arrow 'file' format. */\nexport const MAGIC = Uint8Array.of(65, 82, 82, 79, 87, 49);\n\n/** Bytes for an 'end of stream' message. */\nexport const EOS = Uint8Array.of(255, 255, 255, 255, 0, 0, 0, 0);\n\n/**\n * Apache Arrow version.\n */\nexport const Version = /** @type {const} */ ({\n  /** 0.1.0 (October 2016). */\n  V1: 0,\n  /** 0.2.0 (February 2017). Non-backwards compatible with V1. */\n  V2: 1,\n  /** 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2. */\n  V3: 2,\n  /** >= 0.8.0 (December 2017). Non-backwards compatible with V3. */\n  V4: 3,\n  /**\n   * >= 1.0.0 (July 2020). Backwards compatible with V4 (V5 readers can read V4\n   * metadata and IPC messages). Implementations are recommended to provide a\n   * V4 compatibility mode with V5 format changes disabled.\n   *\n   * Incompatible changes between V4 and V5:\n   * - Union buffer layout has changed.\n   *   In V5, Unions don't have a validity bitmap buffer.\n   */\n  V5: 4\n});\n\n/**\n * Endianness of Arrow-encoded data.\n */\nexport const Endianness = /** @type {const} */ ({\n  Little: 0,\n  Big: 1\n});\n\n/**\n * Message header type codes.\n */\nexport const MessageHeader = /** @type {const} */ ({\n  NONE: 0,\n  /**\n   * A Schema describes the columns in a record batch.\n   */\n  Schema: 1,\n  /**\n   * For sending dictionary encoding information. Any Field can be\n   * dictionary-encoded, but in this case none of its children may be\n   * dictionary-encoded.\n   * There is one vector / column per dictionary, but that vector / column\n   * may be spread across multiple dictionary batches by using the isDelta\n   * flag.\n   */\n  DictionaryBatch: 2,\n  /**\n   * A data header describing the shared memory layout of a \"record\" or \"row\"\n   * batch. Some systems call this a \"row batch\" internally and others a \"record\n   * batch\".\n   */\n  RecordBatch: 3,\n  /**\n   * EXPERIMENTAL: Metadata for n-dimensional arrays, aka \"tensors\" or\n   * \"ndarrays\". Arrow implementations in general are not required to implement\n   * this type.\n   *\n   * Not currently supported by Flechette.\n   */\n  Tensor: 4,\n  /**\n   * EXPERIMENTAL: Metadata for n-dimensional sparse arrays, aka \"sparse\n   * tensors\". Arrow implementations in general are not required to implement\n   * this type.\n   *\n   * Not currently supported by Flechette.\n   */\n  SparseTensor: 5\n});\n\n/**\n * Field data type ids.\n * Only non-negative values ever occur in IPC flatbuffer binary data.\n */\nexport const Type = /** @type {const} */ ({\n  /**\n   * Dictionary types compress data by using a set of integer indices to\n   * lookup potentially repeated vales in a separate dictionary of values.\n   *\n   * This type entry is provided for API convenience, it does not occur\n   * in actual Arrow IPC binary data.\n   */\n  Dictionary: -1,\n  /** No data type. Included for flatbuffer compatibility. */\n  NONE: 0,\n  /** Null values only. */\n  Null: 1,\n  /** Integers, either signed or unsigned, with 8, 16, 32, or 64 bit widths. */\n  Int: 2,\n  /** Floating point numbers with 16, 32, or 64 bit precision. */\n  Float: 3,\n  /** Opaque binary data. */\n  Binary: 4,\n  /** Unicode with UTF-8 encoding. */\n  Utf8: 5,\n  /** Booleans represented as 8 bit bytes. */\n  Bool: 6,\n  /**\n   * Exact decimal value represented as an integer value in two's complement.\n   * Currently only 128-bit (16-byte) and 256-bit (32-byte) integers are used.\n   * The representation uses the endianness indicated in the schema.\n   */\n  Decimal: 7,\n  /**\n   * Date is either a 32-bit or 64-bit signed integer type representing an\n   * elapsed time since UNIX epoch (1970-01-01), stored in either of two units:\n   * - Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no\n   * leap seconds), where the values are evenly divisible by 86400000\n   * - Days (32 bits) since the UNIX epoch\n   */\n  Date: 8,\n  /**\n   * Time is either a 32-bit or 64-bit signed integer type representing an\n   * elapsed time since midnight, stored in either of four units: seconds,\n   * milliseconds, microseconds or nanoseconds.\n   *\n   * The integer `bitWidth` depends on the `unit` and must be one of the following:\n   * - SECOND and MILLISECOND: 32 bits\n   * - MICROSECOND and NANOSECOND: 64 bits\n   *\n   * The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds\n   * (exclusive), adjusted for the time unit (for example, up to 86400000\n   * exclusive for the MILLISECOND unit).\n   * This definition doesn't allow for leap seconds. Time values from\n   * measurements with leap seconds will need to be corrected when ingesting\n   * into Arrow (for example by replacing the value 86400 with 86399).\n   */\n  Time: 9,\n  /**\n   * Timestamp is a 64-bit signed integer representing an elapsed time since a\n   * fixed epoch, stored in either of four units: seconds, milliseconds,\n   * microseconds or nanoseconds, and is optionally annotated with a timezone.\n   *\n   * Timestamp values do not include any leap seconds (in other words, all\n   * days are considered 86400 seconds long).\n   *\n   * The timezone is an optional string for the name of a timezone, one of:\n   *\n   *  - As used in the Olson timezone database (the \"tz database\" or\n   *    \"tzdata\"), such as \"America/New_York\".\n   *  - An absolute timezone offset of the form \"+XX:XX\" or \"-XX:XX\",\n   *    such as \"+07:30\".\n   *\n   * Whether a timezone string is present indicates different semantics about\n   * the data.\n   */\n  Timestamp: 10,\n  /**\n   * A \"calendar\" interval which models types that don't necessarily\n   * have a precise duration without the context of a base timestamp (e.g.\n   * days can differ in length during day light savings time transitions).\n   * All integers in the units below are stored in the endianness indicated\n   * by the schema.\n   *\n   *  - YEAR_MONTH - Indicates the number of elapsed whole months, stored as\n   *    4-byte signed integers.\n   *  - DAY_TIME - Indicates the number of elapsed days and milliseconds (no\n   *    leap seconds), stored as 2 contiguous 32-bit signed integers (8-bytes\n   *    in total). Support of this IntervalUnit is not required for full arrow\n   *    compatibility.\n   *  - MONTH_DAY_NANO - A triple of the number of elapsed months, days, and\n   *    nanoseconds. The values are stored contiguously in 16-byte blocks.\n   *    Months and days are encoded as 32-bit signed integers and nanoseconds\n   *    is encoded as a 64-bit signed integer. Nanoseconds does not allow for\n   *    leap seconds. Each field is independent (e.g. there is no constraint\n   *    that nanoseconds have the same sign as days or that the quantity of\n   *    nanoseconds represents less than a day's worth of time).\n   */\n  Interval: 11,\n  /**\n   * List (vector) data supporting variably-sized lists.\n   * A list has a single child data type for list entries.\n   */\n  List: 12,\n  /**\n   * A struct consisting of multiple named child data types.\n   */\n  Struct: 13,\n  /**\n   * A union is a complex type with parallel child data types. By default ids\n   * in the type vector refer to the offsets in the children. Optionally\n   * typeIds provides an indirection between the child offset and the type id.\n   * For each child `typeIds[offset]` is the id used in the type vector.\n   */\n  Union: 14,\n  /**\n   * Binary data where each entry has the same fixed size.\n   */\n  FixedSizeBinary: 15,\n  /**\n   * List (vector) data where every list has the same fixed size.\n   * A list has a single child data type for list entries.\n   */\n  FixedSizeList: 16,\n  /**\n   * A Map is a logical nested type that is represented as\n   * List<entries: Struct<key: K, value: V>>\n   *\n   * In this layout, the keys and values are each respectively contiguous. We do\n   * not constrain the key and value types, so the application is responsible\n   * for ensuring that the keys are hashable and unique. Whether the keys are sorted\n   * may be set in the metadata for this field.\n   *\n   * In a field with Map type, the field has a child Struct field, which then\n   * has two children: key type and the second the value type. The names of the\n   * child fields may be respectively \"entries\", \"key\", and \"value\", but this is\n   * not enforced.\n   *\n   * Map\n   * ```text\n   *   - child[0] entries: Struct\n   *   - child[0] key: K\n   *   - child[1] value: V\n   *  ```\n   * Neither the \"entries\" field nor the \"key\" field may be nullable.\n   *\n   * The metadata is structured so that Arrow systems without special handling\n   * for Map can make Map an alias for List. The \"layout\" attribute for the Map\n   * field must have the same contents as a List.\n   */\n  Map: 17,\n  /**\n   * An absolute length of time unrelated to any calendar artifacts. For the\n   * purposes of Arrow implementations, adding this value to a Timestamp\n   * (\"t1\") naively (i.e. simply summing the two numbers) is acceptable even\n   * though in some cases the resulting Timestamp (t2) would not account for\n   * leap-seconds during the elapsed time between \"t1\" and \"t2\". Similarly,\n   * representing the difference between two Unix timestamp is acceptable, but\n   * would yield a value that is possibly a few seconds off from the true\n   * elapsed time.\n   *\n   * The resolution defaults to millisecond, but can be any of the other\n   * supported TimeUnit values as with Timestamp and Time types. This type is\n   * always represented as an 8-byte integer.\n   */\n  Duration: 18,\n  /**\n   * Same as Binary, but with 64-bit offsets, allowing representation of\n   * extremely large data values.\n   */\n  LargeBinary: 19,\n  /**\n   * Same as Utf8, but with 64-bit offsets, allowing representation of\n   * extremely large data values.\n   */\n  LargeUtf8: 20,\n  /**\n   * Same as List, but with 64-bit offsets, allowing representation of\n   * extremely large data values.\n   */\n  LargeList: 21,\n  /**\n   * Contains two child arrays, run_ends and values. The run_ends child array\n   * must be a 16/32/64-bit integer array which encodes the indices at which\n   * the run with the value in each corresponding index in the values child\n   * array ends. Like list/struct types, the value array can be of any type.\n   */\n  RunEndEncoded: 22,\n  /**\n   * Logically the same as Binary, but the internal representation uses a view\n   * struct that contains the string length and either the string's entire data\n   * inline (for small strings) or an inlined prefix, an index of another buffer,\n   * and an offset pointing to a slice in that buffer (for non-small strings).\n   *\n   * Since it uses a variable number of data buffers, each Field with this type\n   * must have a corresponding entry in `variadicBufferCounts`.\n   */\n  BinaryView: 23,\n  /**\n   * Logically the same as Utf8, but the internal representation uses a view\n   * struct that contains the string length and either the string's entire data\n   * inline (for small strings) or an inlined prefix, an index of another buffer,\n   * and an offset pointing to a slice in that buffer (for non-small strings).\n   *\n   * Since it uses a variable number of data buffers, each Field with this type\n   * must have a corresponding entry in `variadicBufferCounts`.\n   */\n  Utf8View: 24,\n  /**\n   * Represents the same logical types that List can, but contains offsets and\n   * sizes allowing for writes in any order and sharing of child values among\n   * list values.\n   */\n  ListView: 25,\n  /**\n   * Same as ListView, but with 64-bit offsets and sizes, allowing to represent\n   * extremely large data values.\n   */\n  LargeListView: 26\n});\n\n/**\n * Floating point number precision.\n */\nexport const Precision = /** @type {const} */ ({\n  /** 16-bit floating point number. */\n  HALF: 0,\n  /** 32-bit floating point number. */\n  SINGLE: 1,\n  /** 64-bit floating point number. */\n  DOUBLE: 2\n});\n\n/**\n * Date units.\n */\nexport const DateUnit = /** @type {const} */ ({\n  /* Days (as 32 bit int) since the UNIX epoch. */\n  DAY: 0,\n  /**\n   * Milliseconds (as 64 bit int) indicating UNIX time elapsed since the epoch\n   * (no leap seconds), with values evenly divisible by 86400000.\n   */\n  MILLISECOND: 1\n});\n\n/**\n * Time units.\n */\nexport const TimeUnit = /** @type {const} */ ({\n  /** Seconds. */\n  SECOND: 0,\n  /** Milliseconds. */\n  MILLISECOND: 1,\n  /** Microseconds. */\n  MICROSECOND: 2,\n  /** Nanoseconds. */\n  NANOSECOND: 3\n});\n\n/**\n * Date/time interval units.\n */\nexport const IntervalUnit = /** @type {const} */ ({\n  /**\n   * Indicates the number of elapsed whole months, stored as 4-byte signed\n   * integers.\n   */\n  YEAR_MONTH: 0,\n  /**\n   * Indicates the number of elapsed days and milliseconds (no leap seconds),\n   * stored as 2 contiguous 32-bit signed integers (8-bytes in total). Support\n   * of this IntervalUnit is not required for full arrow compatibility.\n   */\n  DAY_TIME: 1,\n  /**\n   * A triple of the number of elapsed months, days, and nanoseconds.\n   * The values are stored contiguously in 16-byte blocks. Months and days are\n   * encoded as 32-bit signed integers and nanoseconds is encoded as a 64-bit\n   * signed integer. Nanoseconds does not allow for leap seconds. Each field is\n   * independent (e.g. there is no constraint that nanoseconds have the same\n   * sign as days or that the quantity of nanoseconds represents less than a\n   * day's worth of time).\n   */\n  MONTH_DAY_NANO: 2\n});\n\n/**\n * Union type modes.\n */\nexport const UnionMode = /** @type {const} */ ({\n  /** Sparse union layout with full arrays for each sub-type. */\n  Sparse: 0,\n  /** Dense union layout with offsets into value arrays. */\n  Dense: 1\n});\n","/**\n * @import { Int64ArrayConstructor, IntArrayConstructor, IntegerArray, TypedArray } from '../types.js'\n */\nexport const uint8Array = Uint8Array;\nexport const uint16Array = Uint16Array;\nexport const uint32Array = Uint32Array;\nexport const uint64Array = BigUint64Array;\nexport const int8Array = Int8Array;\nexport const int16Array = Int16Array;\nexport const int32Array = Int32Array;\nexport const int64Array = BigInt64Array;\nexport const float32Array = Float32Array;\nexport const float64Array = Float64Array;\n\n/**\n * Check if an input value is an ArrayBuffer or SharedArrayBuffer.\n * @param {unknown} data\n * @returns {data is ArrayBufferLike}\n */\nexport function isArrayBufferLike(data) {\n  return data instanceof ArrayBuffer || (\n    typeof SharedArrayBuffer !== 'undefined' &&\n    data instanceof SharedArrayBuffer\n  );\n}\n\n/**\n * Return the appropriate typed array constructor for the given\n * integer type metadata.\n * @param {number} bitWidth The integer size in bits.\n * @param {boolean} signed Flag indicating if the integer is signed.\n * @returns {IntArrayConstructor}\n */\nexport function intArrayType(bitWidth, signed) {\n  const i = Math.log2(bitWidth) - 3;\n  return (\n    signed\n      ? [int8Array, int16Array, int32Array, int64Array]\n      : [uint8Array, uint16Array, uint32Array, uint64Array]\n  )[i];\n}\n\n/** Shared prototype for typed arrays. */\nconst TypedArray = Object.getPrototypeOf(Int8Array);\n\n/**\n * Check if a value is a typed array.\n * @param {*} value The value to check.\n * @returns {value is TypedArray}\n *  True if value is a typed array, false otherwise.\n */\nexport function isTypedArray(value) {\n  return value instanceof TypedArray;\n}\n\n/**\n * Check if a value is either a standard array or typed array.\n * @param {*} value The value to check.\n * @returns {value is (Array | TypedArray)}\n *  True if value is an array, false otherwise.\n */\nexport function isArray(value) {\n  return Array.isArray(value) || isTypedArray(value);\n}\n\n/**\n * Check if a value is an array type (constructor) for 64-bit integers,\n * one of BigInt64Array or BigUint64Array.\n * @param {*} value The value to check.\n * @returns {value is Int64ArrayConstructor}\n *  True if value is a 64-bit array type, false otherwise.\n */\nexport function isInt64ArrayType(value) {\n  return value === int64Array || value === uint64Array;\n}\n\n/**\n * Determine the correct index into an offset array for a given\n * full column row index. Assumes offset indices can be manipulated\n * as 32-bit signed integers.\n * @param {IntegerArray} offsets The offsets array.\n * @param {number} index The full column row index.\n */\nexport function bisect(offsets, index) {\n  let a = 0;\n  let b = offsets.length;\n  if (b <= 2147483648) { // 2 ** 31\n    // fast version, use unsigned bit shift\n    // array length fits within 32-bit signed integer\n    do {\n      const mid = (a + b) >>> 1;\n      if (offsets[mid] <= index) a = mid + 1;\n      else b = mid;\n    } while (a < b);\n  } else {\n    // slow version, use division and truncate\n    // array length exceeds 32-bit signed integer\n    do {\n      const mid = Math.trunc((a + b) / 2);\n      if (offsets[mid] <= index) a = mid + 1;\n      else b = mid;\n    } while (a < b);\n  }\n  return a;\n}\n\n/**\n * Compute a 64-bit aligned buffer size.\n * @param {number} length The starting size.\n * @param {number} bpe Bytes per element.\n * @returns {number} The aligned size.\n */\nfunction align64(length, bpe = 1) {\n  return (((length * bpe) + 7) & ~7) / bpe;\n}\n\n/**\n * Return a 64-bit aligned version of the array.\n * @template {TypedArray} T\n * @param {T} array The array.\n * @param {number} length The current array length.\n * @returns {T} The aligned array.\n */\nexport function align(array, length = array.length) {\n  const alignedLength = align64(length, array.BYTES_PER_ELEMENT);\n  return array.length > alignedLength ? /** @type {T} */ (array.subarray(0, alignedLength))\n    : array.length < alignedLength ? resize(array, alignedLength)\n    : array;\n}\n\n/**\n * Resize a typed array to exactly the specified length.\n * @template {TypedArray} T\n * @param {T} array The array.\n * @param {number} newLength The new length.\n * @param {number} [offset] The offset at which to copy the old array.\n * @returns {T} The resized array.\n */\nexport function resize(array, newLength, offset = 0) {\n  // @ts-ignore\n  const newArray = new array.constructor(newLength);\n  newArray.set(array, offset);\n  return newArray;\n}\n\n/**\n * Grow a typed array to accommdate a minimum index. The array size is\n * doubled until it exceeds the minimum index.\n * @template {TypedArray} T\n * @param {T} array The array.\n * @param {number} index The minimum index.\n * @param {boolean} [shift] Flag to shift copied bytes to back of array.\n * @returns {T} The resized array.\n */\nexport function grow(array, index, shift) {\n  while (array.length <= index) {\n    array = resize(array, array.length << 1, shift ? array.length : 0);\n  }\n  return array;\n}\n","/**\n * Check if a value is a Date instance\n * @param {*} value The value to check.\n * @returns {value is Date} True if value is a Date, false otherwise.\n */\nexport function isDate(value) {\n  return value instanceof Date;\n}\n\n/**\n * Check if a value is iterable.\n * @param {*} value The value to check.\n * @returns {value is Iterable} True if value is iterable, false otherwise.\n */\nexport function isIterable(value) {\n  return typeof value[Symbol.iterator] === 'function';\n}\n\n/**\n * Return the input value if it passes a test.\n * Otherwise throw an error using the given message generator.\n * @template T\n * @param {T} value The value to check.\n * @param {(value: T) => boolean} test The test function.\n * @param {(value: *) => string} message Message generator.\n * @returns {T} The input value.\n * @throws if the value does not pass the test\n */\nexport function check(value, test, message) {\n  if (test(value)) return value;\n  throw new Error(message(value));\n}\n\n/**\n * Return the input value if it exists in the provided set.\n * Otherwise throw an error using the given message generator.\n * @template T\n * @param {T} value The value to check.\n * @param {T[] | Record<string,T>} set The set of valid values.\n * @param {(value: *) => string} [message] Message generator.\n * @returns {T} The input value.\n * @throws if the value is not included in the set\n */\nexport function checkOneOf(value, set, message) {\n  set = Array.isArray(set) ? set : Object.values(set);\n  return check(\n    value,\n    (value) => set.includes(value),\n    message ?? (() => `${value} must be one of ${set}`)\n  );\n}\n\n/**\n * Return the first object key that pairs with the given value.\n * @param {Record<string,any>} object The object to search.\n * @param {any} value The value to lookup.\n * @returns {string} The first matching key, or '<Unknown>' if not found.\n */\nexport function keyFor(object, value) {\n  for (const [key, val] of Object.entries(object)) {\n    if (val === value) return key;\n  }\n  return '<Unknown>';\n}\n","/**\n * @import { BinaryType, BinaryViewType, BoolType, DataType, DateType, DateUnit_, DecimalType, DictionaryType, DurationType, Field, FixedSizeBinaryType, FixedSizeListType, FloatType, IntBitWidth, IntervalType, IntervalUnit_, IntType, LargeBinaryType, LargeListType, LargeListViewType, LargeUtf8Type, ListType, ListViewType, MapType, NullType, Precision_, RunEndEncodedType, StructType, TimestampType, TimeType, TimeUnit_, UnionMode_, UnionType, Utf8Type, Utf8ViewType } from './types.js'\n */\nimport { DateUnit, IntervalUnit, Precision, TimeUnit, Type, UnionMode } from './constants.js';\nimport { intArrayType, float32Array, float64Array, int32Array, int64Array, uint16Array, uint64Array } from './util/arrays.js';\nimport { check, checkOneOf, keyFor } from './util/objects.js';\n\n/**\n * @typedef {Field | DataType} FieldInput\n */\n\nexport const invalidDataType = (typeId) =>\n  `Unsupported data type: \"${keyFor(Type, typeId)}\" (id ${typeId})`;\n\n/**\n * Return a new field instance for use in a schema or type definition. A field\n * represents a field name, data type, and additional metadata. Fields are used\n * to represent child types within nested types like List, Struct, and Union.\n * @param {string} name The field name.\n * @param {DataType} type The field data type.\n * @param {boolean} [nullable=true] Flag indicating if the field is nullable\n *  (default `true`).\n * @param {Map<string,string>|null} [metadata=null] Custom field metadata\n *  annotations (default `null`).\n * @returns {Field} The field instance.\n */\nexport const field = (name, type, nullable = true, metadata = null) => ({\n  name,\n  type,\n  nullable,\n  metadata\n});\n\n/**\n * Checks if a value is a field instance.\n * @param {any} value\n * @returns {value is Field}\n */\nfunction isField(value) {\n  return Object.hasOwn(value, 'name') && isDataType(value.type)\n}\n\n/**\n * Checks if a value is a data type instance.\n * @param {any} value\n * @returns {value is DataType}\n */\nfunction isDataType(value) {\n  return typeof value?.typeId === 'number';\n}\n\n/**\n * Return a field instance from a field or data type input.\n * @param {FieldInput} value\n *  The value to map to a field.\n * @param {string} [defaultName] The default field name.\n * @param {boolean} [defaultNullable=true] The default nullable value.\n * @returns {Field} The field instance.\n */\nfunction asField(value, defaultName = '', defaultNullable = true) {\n  return isField(value)\n    ? value\n    : field(\n        defaultName,\n        check(value, isDataType, () => `Data type expected.`),\n        defaultNullable\n      );\n}\n\n/////\n\n/**\n * Return a basic type with only a type id.\n * @template {typeof Type[keyof typeof Type]} T\n * @param {T} typeId The type id.\n */\nconst basicType = (typeId) => ({ typeId });\n\n/**\n * Return a Dictionary data type instance.  A dictionary type consists of a\n * dictionary of values (which may be of any type) and corresponding integer\n * indices that reference those values. If values are repeated, a dictionary\n * encoding can provide substantial space savings. In the IPC format,\n * dictionary indices reside alongside other columns in a record batch, while\n * dictionary values are written to special dictionary batches, linked by a\n * unique dictionary *id*.\n * @param {DataType} type The data type of dictionary\n *  values.\n * @param {IntType} [indexType] The data type of\n *  dictionary indices. Must be an integer type (default `int32`).\n * @param {boolean} [ordered=false] Indicates if dictionary values are\n *  ordered (default `false`).\n * @param {number} [id=-1] The dictionary id. The default value (-1) indicates\n *  the dictionary applies to a single column only. Provide an explicit id in\n *  order to reuse a dictionary across columns when building, in which case\n *  different dictionaries *must* have different unique ids. All dictionary\n *  ids are later resolved (possibly to new values) upon IPC encoding.\n * @returns {DictionaryType}\n */\nexport const dictionary = (type, indexType, ordered = false, id = -1) => ({\n  typeId: Type.Dictionary,\n  id,\n  dictionary: type,\n  indices: indexType || int32(),\n  ordered\n});\n\n/**\n * Return a Null data type instance. Null data requires no storage and all\n * extracted values are `null`.\n * @returns {NullType} The null data type.\n */\nexport const nullType = () => basicType(Type.Null);\n\n/**\n * Return an Int data type instance.\n * @param {IntBitWidth} [bitWidth=32] The integer bit width.\n *  One of `8`, `16`, `32` (default), or `64`.\n * @param {boolean} [signed=true] Flag for signed or unsigned integers\n *  (default `true`).\n * @returns {IntType} The integer data type.\n */\nexport const int = (bitWidth = 32, signed = true) => ({\n  typeId: Type.Int,\n  bitWidth: checkOneOf(bitWidth, [8, 16, 32, 64]),\n  signed,\n  values: intArrayType(bitWidth, signed)\n});\n/**\n * Return an Int data type instance for 8 bit signed integers.\n * @returns {IntType} The integer data type.\n */\nexport const int8 = () => int(8);\n/**\n * Return an Int data type instance for 16 bit signed integers.\n * @returns {IntType} The integer data type.\n */\nexport const int16 = () => int(16);\n/**\n * Return an Int data type instance for 32 bit signed integers.\n * @returns {IntType} The integer data type.\n */\nexport const int32 = () => int(32);\n/**\n * Return an Int data type instance for 64 bit signed integers.\n * @returns {IntType} The integer data type.\n */\nexport const int64 = () => int(64);\n/**\n * Return an Int data type instance for 8 bit unsigned integers.\n * @returns {IntType} The integer data type.\n */\nexport const uint8 = () => int(8, false);\n/**\n * Return an Int data type instance for 16 bit unsigned integers.\n * @returns {IntType} The integer data type.\n */\nexport const uint16 = () => int(16, false);\n/**\n * Return an Int data type instance for 32 bit unsigned integers.\n * @returns {IntType} The integer data type.\n */\nexport const uint32 = () => int(32, false);\n/**\n * Return an Int data type instance for 64 bit unsigned integers.\n * @returns {IntType} The integer data type.\n */\nexport const uint64 = () => int(64, false);\n\n/**\n * Return a Float data type instance for floating point numbers.\n * @param {Precision_} [precision=2] The floating point\n *  precision. One of `Precision.HALF` (16-bit), `Precision.SINGLE` (32-bit)\n *  or `Precision.DOUBLE` (64-bit, default).\n * @returns {FloatType} The floating point data type.\n */\nexport const float = (precision = 2) => ({\n  typeId: Type.Float,\n  precision: checkOneOf(precision, Precision),\n  values: [uint16Array, float32Array, float64Array][precision]\n});\n/**\n * Return a Float data type instance for half-precision (16 bit) numbers.\n * @returns {FloatType} The floating point data type.\n */\nexport const float16 = () => float(Precision.HALF);\n/**\n * Return a Float data type instance for single-precision (32 bit) numbers.\n * @returns {FloatType} The floating point data type.\n */\nexport const float32 = () => float(Precision.SINGLE);\n/**\n * Return a Float data type instance for double-precision (64 bit) numbers.\n * @returns {FloatType} The floating point data type.\n */\nexport const float64 = () => float(Precision.DOUBLE);\n\n/**\n * Return a Binary data type instance for variably-sized opaque binary data\n * with 32-bit offsets.\n * @returns {BinaryType} The binary data type.\n */\nexport const binary = () => ({\n  typeId: Type.Binary,\n  offsets: int32Array\n});\n\n/**\n * Return a Utf8 data type instance for Unicode string data.\n * [UTF-8](https://en.wikipedia.org/wiki/UTF-8) code points are stored as\n * binary data.\n * @returns {Utf8Type} The utf8 data type.\n */\nexport const utf8 = () => ({\n  typeId: Type.Utf8,\n  offsets: int32Array\n});\n\n/**\n * Return a Bool data type instance. Bool values are stored compactly in\n * bitmaps with eight values per byte.\n * @returns {BoolType} The bool data type.\n */\nexport const bool = () => basicType(Type.Bool);\n\n/**\n * Return a Decimal data type instance. Decimal values are represented as 32,\n * 64, 128, or 256 bit integers in two's complement. Decimals are fixed point\n * numbers with a set *precision* (total number of decimal digits) and *scale*\n * (number of fractional digits). For example, the number `35.42` can be\n * represented as `3542` with *precision* â‰¥ 4 and *scale* = 2.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @param {32 | 64 | 128 | 256} [bitWidth] The decimal bit width.\n *  One of 32, 64, 128 (default), or 256.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal = (precision, scale, bitWidth = 128) => ({\n  typeId: Type.Decimal,\n  precision,\n  scale,\n  bitWidth: checkOneOf(bitWidth, [32, 64, 128, 256]),\n  values: bitWidth === 32 ? int32Array : uint64Array\n});\n/**\n * Return an Decimal data type instance with a bit width of 32.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal32 = (precision, scale) => decimal(precision, scale, 32);\n/**\n * Return an Decimal data type instance with a bit width of 64.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal64 = (precision, scale) => decimal(precision, scale, 64);\n/**\n * Return an Decimal data type instance with a bit width of 128.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal128 = (precision, scale) => decimal(precision, scale, 128);\n/**\n * Return an Decimal data type instance with a bit width of 256.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal256 = (precision, scale) => decimal(precision, scale, 256);\n\n/**\n * Return a Date data type instance. Date values are 32-bit or 64-bit signed\n * integers representing elapsed time since the UNIX epoch (Jan 1, 1970 UTC),\n * either in units of days (32 bits) or milliseconds (64 bits, with values\n * evenly divisible by 86400000).\n * @param {DateUnit_} unit The date unit.\n *  One of `DateUnit.DAY` or `DateUnit.MILLISECOND`.\n * @returns {DateType} The date data type.\n */\nexport const date = (unit) => ({\n  typeId: Type.Date,\n  unit: checkOneOf(unit, DateUnit),\n  values: unit === DateUnit.DAY ? int32Array : int64Array\n});\n/**\n * Return a Date data type instance with units of days.\n * @returns {DateType} The date data type.\n */\nexport const dateDay = () => date(DateUnit.DAY);\n/**\n * Return a Date data type instance with units of milliseconds.\n * @returns {DateType} The date data type.\n */\nexport const dateMillisecond = () => date(DateUnit.MILLISECOND);\n\n/**\n * Return a Time data type instance, stored in one of four *unit*s: seconds,\n * milliseconds, microseconds or nanoseconds. The integer *bitWidth* is\n * inferred from the *unit* and is 32 bits for seconds and milliseconds or\n * 64 bits for microseconds and nanoseconds. The allowed values are between 0\n * (inclusive) and 86400 (=24*60*60) seconds (exclusive), adjusted for the\n * time unit (for example, up to 86400000 exclusive for the\n * `DateUnit.MILLISECOND` unit.\n *\n * This definition doesn't allow for leap seconds. Time values from\n * measurements with leap seconds will need to be corrected when ingesting\n * into Arrow (for example by replacing the value 86400 with 86399).\n * @param {TimeUnit_} unit The time unit.\n *  One of `TimeUnit.SECOND`, `TimeUnit.MILLISECOND` (default),\n *  `TimeUnit.MICROSECOND`, or `TimeUnit.NANOSECOND`.\n * @returns {TimeType} The time data type.\n */\nexport const time = (unit = TimeUnit.MILLISECOND) => {\n  unit = checkOneOf(unit, TimeUnit);\n  const bitWidth = unit === TimeUnit.SECOND || unit === TimeUnit.MILLISECOND ? 32 : 64;\n  return {\n    typeId: Type.Time,\n    unit,\n    bitWidth,\n    values: bitWidth === 32 ? int32Array : int64Array\n  };\n};\n/**\n * Return a Time data type instance, represented as seconds.\n * @returns {TimeType} The time data type.\n */\nexport const timeSecond = () => time(TimeUnit.SECOND);\n/**\n * Return a Time data type instance, represented as milliseconds.\n * @returns {TimeType} The time data type.\n */\nexport const timeMillisecond = () => time(TimeUnit.MILLISECOND);\n/**\n * Return a Time data type instance, represented as microseconds.\n * @returns {TimeType} The time data type.\n */\nexport const timeMicrosecond = () => time(TimeUnit.MICROSECOND);\n/**\n * Return a Time data type instance, represented as nanoseconds.\n * @returns {TimeType} The time data type.\n */\nexport const timeNanosecond = () => time(TimeUnit.NANOSECOND);\n\n/**\n * Return a Timestamp data type instance. Timestamp values are 64-bit signed\n * integers representing an elapsed time since a fixed epoch, stored in either\n * of four units: seconds, milliseconds, microseconds or nanoseconds, and are\n * optionally annotated with a timezone. Timestamp values do not include any\n * leap seconds (in other words, all days are considered 86400 seconds long).\n * @param {TimeUnit_} [unit] The time unit.\n *  One of `TimeUnit.SECOND`, `TimeUnit.MILLISECOND` (default),\n *  `TimeUnit.MICROSECOND`, or `TimeUnit.NANOSECOND`.\n * @param {string|null} [timezone=null] An optional string for the name of a\n *  timezone. If provided, the value should either be a string as used in the\n *  Olson timezone database (the \"tz database\" or \"tzdata\"), such as\n *  \"America/New_York\", or an absolute timezone offset of the form \"+XX:XX\" or\n *  \"-XX:XX\", such as \"+07:30\".Whether a timezone string is present indicates\n *  different semantics about the data.\n * @returns {TimestampType} The time data type.\n */\nexport const timestamp = (unit = TimeUnit.MILLISECOND, timezone = null) => ({\n  typeId: Type.Timestamp,\n  unit: checkOneOf(unit, TimeUnit),\n  timezone,\n  values: int64Array\n});\n\n/**\n * Return an Interval type instance. Values represent calendar intervals stored\n * as integers for each date part. The supported *unit*s are year/moth,\n * day/time, and month/day/nanosecond intervals.\n *\n * `IntervalUnit.YEAR_MONTH` indicates the number of elapsed whole months,\n * stored as 32-bit signed integers.\n *\n * `IntervalUnit.DAY_TIME` indicates the number of elapsed days and\n * milliseconds (no leap seconds), stored as 2 contiguous 32-bit signed\n * integers (8-bytes in total).\n *\n * `IntervalUnit.MONTH_DAY_NANO` is a triple of the number of elapsed months,\n * days, and nanoseconds. The values are stored contiguously in 16-byte blocks.\n * Months and days are encoded as 32-bit signed integers and nanoseconds is\n * encoded as a 64-bit signed integer. Nanoseconds does not allow for leap\n * seconds. Each field is independent (e.g. there is no constraint that\n * nanoseconds have the same sign as days or that the quantity of nanoseconds\n * represents less than a day's worth of time).\n * @param {IntervalUnit_} unit  The interval unit.\n *  One of `IntervalUnit.YEAR_MONTH`, `IntervalUnit.DAY_TIME`, or\n *  `IntervalUnit.MONTH_DAY_NANO` (default).\n * @returns {IntervalType} The interval data type.\n */\nexport const interval = (unit = IntervalUnit.MONTH_DAY_NANO) => ({\n  typeId: Type.Interval,\n  unit: checkOneOf(unit, IntervalUnit),\n  values: unit === IntervalUnit.MONTH_DAY_NANO ? undefined : int32Array\n});\n\n/**\n * Return a List data type instance, representing variably-sized lists\n * (arrays) with 32-bit offsets. A list has a single child data type for\n * list entries. Lists are represented using integer offsets that indicate\n * list extents within a single child array containing all list values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {ListType} The list data type.\n */\nexport const list = (child) => ({\n  typeId: Type.List,\n  children: [ asField(child) ],\n  offsets: int32Array\n});\n\n/**\n * Return a Struct data type instance. A struct consists of multiple named\n * child data types. Struct values are stored as parallel child batches, one\n * per child type, and extracted to standard JavaScript objects.\n * @param {Field[] | Record<string, DataType>} children\n *  An array of property fields, or an object mapping property names to data\n *  types. If an object, the instantiated fields are assumed to be nullable\n *  and have no metadata.\n * @returns {StructType} The struct data type.\n */\nexport const struct = (children) => ({\n  typeId: Type.Struct,\n  children: Array.isArray(children) && isField(children[0])\n    ? /** @type {Field[]} */ (children)\n    : Object.entries(children).map(([name, type]) => field(name, type))\n});\n\n/**\n * Return a Union type instance. A union is a complex type with parallel\n * *children* data types. Union values are stored in either a sparse\n * (`UnionMode.Sparse`) or dense (`UnionMode.Dense`) layout *mode*. In a\n * sparse layout, child types are stored in parallel arrays with the same\n * lengths, resulting in many unused, empty values. In a dense layout, child\n * types have variable lengths and an offsets array is used to index the\n * appropriate value.\n *\n * By default, ids in the type vector refer to the index in the children\n * array. Optionally, *typeIds* provide an indirection between the child\n * index and the type id. For each child, `typeIds[index]` is the id used\n * in the type vector. The *typeIdForValue* argument provides a lookup\n * function for mapping input data to the proper child type id, and is\n * required if using builder methods.\n * @param {UnionMode_} mode The union mode.\n *  One of `UnionMode.Sparse` or `UnionMode.Dense`.\n * @param {FieldInput[]} children The children fields or data types.\n *  Types are mapped to nullable fields with no metadata.\n * @param {number[]} [typeIds]  Children type ids, in the same order as the\n *  children types. Type ids provide a level of indirection over children\n *  types. If not provided, the children indices are used as the type ids.\n * @param {(value: any, index: number) => number} [typeIdForValue]\n *  A function that takes an arbitrary value and a row index and returns a\n *  correponding union type id. Required by builder methods.\n * @returns {UnionType} The union data type.\n */\nexport const union = (mode, children, typeIds, typeIdForValue) => {\n  typeIds ??= children.map((v, i) => i);\n  return {\n    typeId: Type.Union,\n    mode: checkOneOf(mode, UnionMode),\n    typeIds,\n    typeMap: typeIds.reduce((m, id, i) => ((m[id] = i), m), {}),\n    children: children.map((v, i) => asField(v, `_${i}`)),\n    typeIdForValue,\n    offsets: int32Array,\n  };\n};\n\n/**\n * Create a FixedSizeBinary data type instance for opaque binary data where\n * each entry has the same fixed size.\n * @param {number} stride The fixed size in bytes.\n * @returns {FixedSizeBinaryType} The fixed size binary data type.\n */\nexport const fixedSizeBinary = (stride) => ({\n  typeId: Type.FixedSizeBinary,\n  stride\n});\n\n/**\n * Return a FixedSizeList type instance for list (array) data where every list\n * has the same fixed size. A list has a single child data type for list\n * entries. Fixed size lists are represented as a single child array containing\n * all list values, indexed using the known stride.\n * @param {FieldInput} child The list item data type.\n * @param {number} stride The fixed list size.\n * @returns {FixedSizeListType} The fixed size list data type.\n */\nexport const fixedSizeList = (child, stride) => ({\n  typeId: Type.FixedSizeList,\n  stride,\n  children: [ asField(child) ]\n});\n\n/**\n * Internal method to create a Map type instance.\n * @param {boolean} keysSorted Flag indicating if the map keys are sorted.\n * @param {Field} child The child fields.\n * @returns {MapType} The map data type.\n */\nexport const mapType = (keysSorted, child) => ({\n  typeId: Type.Map,\n  keysSorted,\n  children: [child],\n  offsets: int32Array\n});\n\n/**\n * Return a Map data type instance representing collections of key-value pairs.\n * A Map is a logical nested type that is represented as a list of key-value\n * structs. The key and value types are not constrained, so the application is\n * responsible for ensuring that the keys are hashable and unique, and that\n * keys are properly sorted if *keysSorted* is `true`.\n * @param {FieldInput} keyField The map key field or data type.\n * @param {FieldInput} valueField The map value field or data type.\n * @param {boolean} [keysSorted=false] Flag indicating if the map keys are\n *  sorted (default `false`).\n * @returns {MapType} The map data type.\n */\nexport const map = (keyField, valueField, keysSorted = false) => mapType(\n  keysSorted,\n  field(\n    'entries',\n    struct([ asField(keyField, 'key', false), asField(valueField, 'value') ]),\n    false\n  )\n);\n\n/**\n * Return a Duration data type instance. Durations represent an absolute length\n * of time unrelated to any calendar artifacts. The resolution defaults to\n * millisecond, but can be any of the other `TimeUnit` values. This type is\n * always represented as a 64-bit integer.\n * @param {TimeUnit_} unit\n * @returns {DurationType} The duration data type.\n */\nexport const duration = (unit = TimeUnit.MILLISECOND) => ({\n  typeId: Type.Duration,\n  unit: checkOneOf(unit, TimeUnit),\n  values: int64Array\n});\n\n/**\n * Return a LargeBinary data type instance for variably-sized opaque binary\n * data with 64-bit offsets, allowing representation of extremely large data\n * values.\n * @returns {LargeBinaryType} The large binary data type.\n */\nexport const largeBinary = () => ({\n  typeId: Type.LargeBinary,\n  offsets: int64Array\n});\n\n/**\n * Return a LargeUtf8 data type instance for Unicode string data of variable\n * length with 64-bit offsets, allowing representation of extremely large data\n * values. [UTF-8](https://en.wikipedia.org/wiki/UTF-8) code points are stored\n * as binary data.\n * @returns {LargeUtf8Type} The large utf8 data type.\n */\nexport const largeUtf8 = () => ({\n  typeId: Type.LargeUtf8,\n  offsets: int64Array\n});\n\n/**\n * Return a LargeList data type instance, representing variably-sized lists\n * (arrays) with 64-bit offsets, allowing representation of extremely large\n * data values. A list has a single child data type for list entries. Lists\n * are represented using integer offsets that indicate list extents within a\n * single child array containing all list values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {LargeListType} The large list data type.\n */\nexport const largeList = (child) => ({\n  typeId: Type.LargeList,\n  children: [ asField(child) ],\n  offsets: int64Array\n});\n\n/**\n * Return a RunEndEncoded data type instance, which compresses data by\n * representing consecutive repeated values as a run. This data type uses two\n * child arrays, `run_ends` and `values`. The `run_ends` child array must be\n * a 16, 32, or 64 bit integer array which encodes the indices at which the\n * run with the value in each corresponding index in the values child array\n * ends. Like list and struct types, the `values` array can be of any type.\n * @param {FieldInput} runsField The run-ends field or data type.\n * @param {FieldInput} valuesField The values field or data type.\n * @returns {RunEndEncodedType} The large list data type.\n */\nexport const runEndEncoded = (runsField, valuesField) => ({\n  typeId: Type.RunEndEncoded,\n  children: [\n    check(\n      asField(runsField, 'run_ends'),\n      (field) => field.type.typeId === Type.Int,\n      () => 'Run-ends must have an integer type.'\n    ),\n    asField(valuesField, 'values')\n  ]\n});\n\n/**\n * Return a BinaryView data type instance. BinaryView data is logically the\n * same as the Binary type, but the internal representation uses a view struct\n * that contains the string length and either the string's entire data inline\n * (for small strings) or an inlined prefix, an index of another buffer, and an\n * offset pointing to a slice in that buffer (for non-small strings).\n *\n * Flechette can encode and decode BinaryView data; however, Flechette does\n * not currently support building BinaryView columns from JavaScript values.\n * @returns {BinaryViewType} The binary view data type.\n */\nexport const binaryView = () => /** @type {BinaryViewType} */\n  (basicType(Type.BinaryView));\n\n/**\n * Return a Utf8View data type instance. Utf8View data is logically the same as\n * the Utf8 type, but the internal representation uses a view struct that\n * contains the string length and either the string's entire data inline (for\n * small strings) or an inlined prefix, an index of another buffer, and an\n * offset pointing to a slice in that buffer (for non-small strings).\n *\n * Flechette can encode and decode Utf8View data; however, Flechette does\n * not currently support building Utf8View columns from JavaScript values.\n * @returns {Utf8ViewType} The utf8 view data type.\n */\nexport const utf8View = () => /** @type {Utf8ViewType} */\n  (basicType(Type.Utf8View));\n\n/**\n * Return a ListView data type instance, representing variably-sized lists\n * (arrays) with 32-bit offsets. ListView data represents the same logical\n * types that List can, but contains both offsets and sizes allowing for\n * writes in any order and sharing of child values among list values.\n *\n * Flechette can encode and decode ListView data; however, Flechette does not\n * currently support building ListView columns from JavaScript values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {ListViewType} The list view data type.\n */\nexport const listView = (child) => ({\n  typeId: Type.ListView,\n  children: [ asField(child, 'value') ],\n  offsets: int32Array\n});\n\n/**\n * Return a LargeListView data type instance, representing variably-sized lists\n * (arrays) with 64-bit offsets, allowing representation of extremely large\n * data values. LargeListView data represents the same logical types that\n * LargeList can, but contains both offsets and sizes allowing for writes\n * in any order and sharing of child values among list values.\n *\n * Flechette can encode and decode LargeListView data; however, Flechette does\n * not currently support building LargeListView columns from JavaScript values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {LargeListViewType} The large list view data type.\n */\nexport const largeListView = (child) => ({\n  typeId: Type.LargeListView,\n  children: [ asField(child, 'value') ],\n  offsets: int64Array\n});\n","/**\n * @import { TimeUnit_, TypedArray } from '../types.js';\n */\nimport { float64Array, int32Array, int64Array, isInt64ArrayType, uint32Array, uint8Array } from './arrays.js';\nimport { TimeUnit } from '../constants.js';\n\n// typed arrays over a shared buffer to aid binary conversion\nconst f64 = new float64Array(2);\nconst buf = f64.buffer;\nconst i64 = new int64Array(buf);\nconst u32 = new uint32Array(buf);\nconst i32 = new int32Array(buf);\nconst u8 = new uint8Array(buf);\n\n/**\n * Return a value unchanged.\n * @template T\n * @param {T} value The value.\n * @returns {T} The value.\n */\nexport function identity(value) {\n  return value;\n}\n\n/**\n * Return a value coerced to a BigInt.\n * @param {*} value The value.\n * @returns {bigint} The BigInt value.\n */\nexport function toBigInt(value) {\n  return BigInt(value);\n}\n\n/**\n * Return an offset conversion method for the given data type.\n * @param {{ offsets: TypedArray}} type The array type.\n */\nexport function toOffset(type) {\n  return isInt64ArrayType(type) ? toBigInt : identity;\n}\n\n/**\n * Return the number of days from a millisecond timestamp.\n * @param {number} value The millisecond timestamp.\n * @returns {number} The number of days.\n */\nexport function toDateDay(value) {\n  return (value / 864e5) | 0;\n}\n\n/**\n * Return a timestamp conversion method for the given time unit.\n * @param {TimeUnit_} unit The time unit.\n * @returns {(value: number) => bigint} The conversion method.\n */\nexport function toTimestamp(unit) {\n  return unit === TimeUnit.SECOND ? value => toBigInt(value / 1e3)\n    : unit === TimeUnit.MILLISECOND ? toBigInt\n    : unit === TimeUnit.MICROSECOND ? value => toBigInt(value * 1e3)\n    : value => toBigInt(value * 1e6);\n}\n\n/**\n * Write month/day/nanosecond interval to a byte buffer.\n * @param {Array | Float64Array} interval The interval data.\n * @returns {Uint8Array} A byte buffer with the interval data.\n *  The returned buffer is reused across calls, and so should be\n *  copied to a target buffer immediately.\n */\nexport function toMonthDayNanoBytes([m, d, n]) {\n  i32[0] = m;\n  i32[1] = d;\n  i64[1] = toBigInt(n);\n  return u8;\n}\n\n/**\n * Coerce a bigint value to a number. Throws an error if the bigint value\n * lies outside the range of what a number can precisely represent.\n * @param {bigint} value The value to check and possibly convert.\n * @returns {number} The converted number value.\n */\nexport function toNumber(value) {\n  if (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER) {\n    throw Error(`BigInt exceeds integer number representation: ${value}`);\n  }\n  return Number(value);\n}\n\n/**\n * Divide one BigInt value by another, and return the result as a number.\n * The division may involve unsafe integers and a loss of precision.\n * @param {bigint} num The numerator.\n * @param {bigint} div The divisor.\n * @returns {number} The result of the division as a floating point number.\n */\nexport function divide(num, div) {\n  return Number(num / div) + Number(num % div) / Number(div);\n}\n\n/**\n * Return a 32-bit decimal conversion method for the given decimal scale.\n * @param {number} scale The scale mapping fractional digits to integers.\n * @returns {(value: number|bigint) => number} A conversion method that maps\n *  floating point numbers to 32-bit decimals.\n */\nexport function toDecimal32(scale) {\n  return (value) => typeof value === 'bigint'\n    ? Number(value)\n    : Math.trunc(value * scale);\n}\n\n/**\n * Convert a floating point number or bigint to decimal bytes.\n * @param {number|bigint} value The number to encode. If a bigint, we assume\n *  it already represents the decimal in integer form with the correct scale.\n *  Otherwise, we assume a float that requires scaled integer conversion.\n * @param {BigUint64Array} buf The uint64 array to write to.\n * @param {number} offset The starting index offset into the array.\n * @param {number} stride The stride of an encoded decimal, in 64-bit steps.\n * @param {number} scale The scale mapping fractional digits to integers.\n */\nexport function toDecimal(value, buf, offset, stride, scale) {\n  const v = typeof value === 'bigint'\n    ? value\n    : toBigInt(Math.trunc(value * scale));\n  // assignment into uint64array performs needed truncation for us\n  buf[offset] = v;\n  if (stride > 1) {\n    buf[offset + 1] = (v >> 64n);\n    if (stride > 2) {\n      buf[offset + 2] = (v >> 128n);\n      buf[offset + 3] = (v >> 192n);\n    }\n  }\n}\n\n// helper method to extract uint64 values from bigints\nconst asUint64 = v => BigInt.asUintN(64, v);\n\n/**\n * Convert a 64-bit decimal value to a bigint.\n * @param {BigUint64Array} buf The uint64 array containing the decimal bytes.\n * @param {number} offset The starting index offset into the array.\n * @returns {bigint} The converted decimal as a bigint, such that all\n *  fractional digits are scaled up to integers (for example, 1.12 -> 112).\n */\nexport function fromDecimal64(buf, offset) {\n  return BigInt.asIntN(64, buf[offset]);\n}\n\n/**\n * Convert a 128-bit decimal value to a bigint.\n * @param {BigUint64Array} buf The uint64 array containing the decimal bytes.\n * @param {number} offset The starting index offset into the array.\n * @returns {bigint} The converted decimal as a bigint, such that all\n *  fractional digits are scaled up to integers (for example, 1.12 -> 112).\n */\nexport function fromDecimal128(buf, offset) {\n  const i = offset << 1;\n  let x;\n  if (BigInt.asIntN(64, buf[i + 1]) < 0) {\n    x = asUint64(~buf[i]) | (asUint64(~buf[i + 1]) << 64n);\n    x = -(x + 1n);\n  } else {\n    x = buf[i] | (buf[i + 1] << 64n);\n  }\n  return x;\n}\n\n/**\n * Convert a 256-bit decimal value to a bigint.\n * @param {BigUint64Array} buf The uint64 array containing the decimal bytes.\n * @param {number} offset The starting index offset into the array.\n * @returns {bigint} The converted decimal as a bigint, such that all\n *  fractional digits are scaled up to integers (for example, 1.12 -> 112).\n */\nexport function fromDecimal256(buf, offset) {\n  const i = offset << 2;\n  let x;\n  if (BigInt.asIntN(64, buf[i + 3]) < 0) {\n    x = asUint64(~buf[i])\n      | (asUint64(~buf[i + 1]) << 64n)\n      | (asUint64(~buf[i + 2]) << 128n)\n      | (asUint64(~buf[i + 3]) << 192n);\n    x = -(x + 1n);\n  } else {\n    x = buf[i]\n      | (buf[i + 1] << 64n)\n      | (buf[i + 2] << 128n)\n      | (buf[i + 3] << 192n);\n  }\n  return x;\n}\n\n/**\n * Convert a 16-bit float from integer bytes to a number.\n * Adapted from https://github.com/apache/arrow/blob/main/js/src/util/math.ts\n * @param {number} value The float as a 16-bit integer.\n * @returns {number} The converted 64-bit floating point number.\n */\nexport function fromFloat16(value) {\n  const expo = (value & 0x7C00) >> 10;\n  const sigf = (value & 0x03FF) / 1024;\n  const sign = (-1) ** ((value & 0x8000) >> 15);\n  switch (expo) {\n    case 0x1F: return sign * (sigf ? Number.NaN : 1 / 0);\n    case 0x00: return sign * (sigf ? 6.103515625e-5 * sigf : 0);\n  }\n  return sign * (2 ** (expo - 15)) * (1 + sigf);\n}\n\n/**\n * Convert a number to a 16-bit float as integer bytes..\n * Inspired by numpy's `npy_double_to_half`:\n * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L43\n * Adapted from https://github.com/apache/arrow/blob/main/js/src/util/math.ts\n * @param {number} value The 64-bit floating point number to convert.\n * @returns {number} The converted 16-bit integer.\n */\nexport function toFloat16(value) {\n  if (value !== value) return 0x7E00; // NaN\n  f64[0] = value;\n\n  // Magic numbers:\n  // 0x80000000 = 10000000 00000000 00000000 00000000 -- masks the 32nd bit\n  // 0x7ff00000 = 01111111 11110000 00000000 00000000 -- masks the 21st-31st bits\n  // 0x000fffff = 00000000 00001111 11111111 11111111 -- masks the 1st-20th bit\n  const sign = (u32[1] & 0x80000000) >> 16 & 0xFFFF;\n  let expo = (u32[1] & 0x7FF00000), sigf = 0x0000;\n\n  if (expo >= 0x40F00000) {\n    //\n    // If exponent overflowed, the float16 is either NaN or Infinity.\n    // Rules to propagate the sign bit: mantissa > 0 ? NaN : +/-Infinity\n    //\n    // Magic numbers:\n    // 0x40F00000 = 01000000 11110000 00000000 00000000 -- 6-bit exponent overflow\n    // 0x7C000000 = 01111100 00000000 00000000 00000000 -- masks the 27th-31st bits\n    //\n    // returns:\n    // qNaN, aka 32256 decimal, 0x7E00 hex, or 01111110 00000000 binary\n    // sNaN, aka 32000 decimal, 0x7D00 hex, or 01111101 00000000 binary\n    // +inf, aka 31744 decimal, 0x7C00 hex, or 01111100 00000000 binary\n    // -inf, aka 64512 decimal, 0xFC00 hex, or 11111100 00000000 binary\n    //\n    // If mantissa is greater than 23 bits, set to +Infinity like numpy\n    if (u32[0] > 0) {\n      expo = 0x7C00;\n    } else {\n      expo = (expo & 0x7C000000) >> 16;\n      sigf = (u32[1] & 0x000FFFFF) >> 10;\n    }\n  } else if (expo <= 0x3F000000) {\n    //\n    // If exponent underflowed, the float is either signed zero or subnormal.\n    //\n    // Magic numbers:\n    // 0x3F000000 = 00111111 00000000 00000000 00000000 -- 6-bit exponent underflow\n    //\n    sigf = 0x100000 + (u32[1] & 0x000FFFFF);\n    sigf = 0x100000 + (sigf << ((expo >> 20) - 998)) >> 21;\n    expo = 0;\n  } else {\n    //\n    // No overflow or underflow, rebase the exponent and round the mantissa\n    // Magic numbers:\n    // 0x200 = 00000010 00000000 -- masks off the 10th bit\n    //\n    // Ensure the first mantissa bit (the 10th one) is 1 and round\n    expo = (expo - 0x3F000000) >> 10;\n    sigf = ((u32[1] & 0x000FFFFF) + 0x200) >> 10;\n  }\n  return sign | expo | sigf & 0xFFFF;\n}\n","import { isArray } from './arrays.js';\nimport { isDate } from './objects.js';\n\nconst textDecoder = new TextDecoder('utf-8');\nconst textEncoder = new TextEncoder();\n\n/**\n * Return a UTF-8 string decoded from a byte buffer.\n * @param {Uint8Array} buf The byte buffer.\n * @returns {string} The decoded string.\n */\nexport function decodeUtf8(buf) {\n  return textDecoder.decode(buf);\n}\n\n/**\n * Return a byte buffer encoded from a UTF-8 string.\n * @param {string } str The string to encode.\n * @returns {Uint8Array} The encoded byte buffer.\n */\nexport function encodeUtf8(str) {\n  return textEncoder.encode(str);\n}\n\n/**\n * Return a string-coercible key value that uniquely identifies a value.\n * @param {*} value The input value.\n * @returns {string} The key string.\n */\nexport function keyString(value) {\n  const val = typeof value !== 'object' || !value ? (value ?? null)\n    : isDate(value) ? +value\n    // @ts-ignore\n    : isArray(value) ? `[${value.map(keyString)}]`\n    : objectKey(value);\n  return `${val}`;\n}\n\nfunction objectKey(value) {\n  let s = '';\n  let i = -1;\n  for (const k in value) {\n    if (++i > 0) s += ',';\n    s += `\"${k}\":${keyString(value[k])}`;\n  }\n  return `{${s}}`;\n}\n","import { toNumber } from './numbers.js';\nimport { decodeUtf8 } from './strings.js';\n\n/** The size in bytes of a 32-bit integer. */\nexport const SIZEOF_INT = 4;\n\n/** The size in bytes of a 16-bit integer. */\nexport const SIZEOF_SHORT = 2;\n\n/**\n * Return a boolean for a single bit in a bitmap.\n * @param {Uint8Array} bitmap The bitmap.\n * @param {number} index The bit index to read.\n * @returns {boolean} The boolean bitmap value.\n */\nexport function decodeBit(bitmap, index) {\n  return (bitmap[index >> 3] & 1 << (index % 8)) !== 0;\n}\n\n/**\n * Lookup helper for flatbuffer object (table) entries.\n * @param {Uint8Array} buf The byte buffer.\n * @param {number} index The base index of the object.\n */\nexport function readObject(buf, index) {\n  const pos = index + readInt32(buf, index);\n  const vtable = pos - readInt32(buf, pos);\n  const size = readInt16(buf, vtable);\n  /**\n   * Retrieve a value from a flatbuffer table layout.\n   * @template T\n   * @param {number} index The table entry index.\n   * @param {(buf: Uint8Array, offset: number) => T} read Read function to invoke.\n   * @param {T} [fallback=null] The default fallback value.\n   * @returns {T}\n   */\n  return (index, read, fallback = null) => {\n    if (index < size) {\n      const off = readInt16(buf, vtable + index);\n      if (off) return read(buf, pos + off);\n    }\n    return fallback;\n  };\n}\n\n/**\n * Return a buffer offset value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readOffset(buf, offset) {\n  return offset;\n}\n\n/**\n * Return a boolean value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {boolean}\n */\nexport function readBoolean(buf, offset) {\n  return !!readInt8(buf, offset);\n}\n\n/**\n * Return a signed 8-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt8(buf, offset) {\n  return readUint8(buf, offset) << 24 >> 24;\n}\n\n/**\n * Return an unsigned 8-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readUint8(buf, offset) {\n  return buf[offset];\n}\n\n/**\n * Return a signed 16-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt16(buf, offset) {\n  return readUint16(buf, offset) << 16 >> 16;\n}\n\n/**\n * Return an unsigned 16-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readUint16(buf, offset) {\n  return buf[offset] | buf[offset + 1] << 8;\n}\n\n/**\n * Return a signed 32-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt32(buf, offset) {\n  return buf[offset]\n    | buf[offset + 1] << 8\n    | buf[offset + 2] << 16\n    | buf[offset + 3] << 24;\n}\n\n/**\n * Return an unsigned 32-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readUint32(buf, offset) {\n  return readInt32(buf, offset) >>> 0;\n}\n\n/**\n * Return a signed 64-bit integer value coerced to a JS number.\n * Throws an error if the value exceeds what a JS number can represent.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt64(buf, offset) {\n  return toNumber(BigInt.asIntN(\n    64,\n    BigInt(readUint32(buf, offset)) +\n      (BigInt(readUint32(buf, offset + SIZEOF_INT)) << 32n)\n  ));\n}\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n * @param {Uint8Array} buf The byte buffer.\n * @param {number} index The index of the string entry.\n * @returns {string} The decoded string.\n */\nexport function readString(buf, index) {\n  let offset = index + readInt32(buf, index); // get the string offset\n  const length = readInt32(buf, offset);  // get the string length\n  offset += SIZEOF_INT; // skip length value\n  return decodeUtf8(buf.subarray(offset, offset + length));\n}\n\n/**\n * Extract a flatbuffer vector to an array.\n * @template T\n * @param {Uint8Array} buf The byte buffer.\n * @param {number} offset The offset location of the vector.\n * @param {number} stride The stride between vector entries.\n * @param {(buf: Uint8Array, pos: number) => T} extract Vector entry extraction function.\n * @returns {T[]} The extracted vector entries.\n */\nexport function readVector(buf, offset, stride, extract) {\n  if (!offset) return [];\n\n  // get base position by adding offset delta\n  const base = offset + readInt32(buf, offset);\n\n  // read vector size, extract entries\n  return Array.from(\n    { length: readInt32(buf, base) },\n    (_, i) => extract(buf, base + SIZEOF_INT + i * stride)\n  );\n}\n","/**\n * @import { Batch } from '../batch.js';\n */\n\n/**\n * Symbol for the row index value of a struct object proxy.\n */\nexport const RowIndex = Symbol('rowIndex');\n\n/**\n * Returns a row proxy object factory. The resulting method takes a\n * batch-level row index as input and returns an object that proxies\n * access to underlying batches.\n * @param {string[]} names The column (property) names\n * @param {Batch[]} batches The value batches.\n * @returns {(index: number) => Record<string, any>}\n */\nexport function proxyFactory(names, batches) {\n  class RowObject {\n    /**\n     * Create a new proxy row object representing a struct or table row.\n     * @param {number} index The record batch row index.\n     */\n    constructor(index) {\n      this[RowIndex] = index;\n    }\n\n    /**\n     * Return a JSON-compatible object representation.\n     */\n    toJSON() {\n      return structObject(names, batches, this[RowIndex]);\n    }\n  };\n\n  // prototype for row proxy objects\n  const proto = RowObject.prototype;\n\n  for (let i = 0; i < names.length; ++i) {\n    // skip duplicated column names\n    if (Object.hasOwn(proto, names[i])) continue;\n\n    // add a getter method for the current batch\n    const batch = batches[i];\n    Object.defineProperty(proto, names[i], {\n      get() { return batch.at(this[RowIndex]); },\n      enumerable: true\n    });\n  }\n\n  return index => new RowObject(index);\n}\n\n/**\n * Returns a row object factory. The resulting method takes a\n * batch-level row index as input and returns an object whose property\n * values have been extracted from the batches.\n * @param {string[]} names The column (property) names\n * @param {Batch[]} batches The value batches.\n * @returns {(index: number) => Record<string, any>}\n */\nexport function objectFactory(names, batches) {\n  return index => structObject(names, batches, index);\n}\n\n/**\n * Return a vanilla object representing a struct (row object) type.\n * @param {string[]} names The column (property) names\n * @param {Batch[]} batches The value batches.\n * @param {number} index The record batch row index.\n * @returns {Record<string, any>}\n */\nexport function structObject(names, batches, index) {\n  const obj = {};\n  for (let i = 0; i < names.length; ++i) {\n    obj[names[i]] = batches[i].at(index);\n  }\n  return obj;\n}\n","/**\n * @import { Column } from './column.js'\n * @import { DataType, DecimalType, IntegerArray, OffsetArray, TypedArray, TypedArrayConstructor, ValueArray } from './types.js'\n */\nimport { bisect, float64Array } from './util/arrays.js';\nimport { divide, fromDecimal128, fromDecimal256, fromDecimal64, toNumber } from './util/numbers.js';\nimport { decodeBit, readInt32, readInt64 } from './util/read.js';\nimport { decodeUtf8 } from './util/strings.js';\nimport { objectFactory, proxyFactory } from './util/struct.js';\n\n/**\n * Check if the input is a batch that supports direct access to\n * binary data in the form of typed arrays.\n * @param {Batch<any>?} batch The data batch to check.\n * @returns {boolean} True if a direct batch, false otherwise.\n */\nexport function isDirectBatch(batch) {\n  return batch instanceof DirectBatch;\n}\n\n/**\n * Column values from a single record batch.\n * A column may contain multiple batches.\n * @template T\n */\nexport class Batch {\n  /**\n   * The array type to use when extracting data from the batch.\n   * A null value indicates that the array type should match\n   * the type of the batch's values array.\n   * @type {ArrayConstructor | TypedArrayConstructor | null}\n   */\n  static ArrayType = null;\n\n  /**\n   * Create a new column batch.\n   * @param {object} options\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {TypedArray} [options.values] Values buffer\n   * @param {OffsetArray} [options.offsets] Offsets buffer\n   * @param {OffsetArray} [options.sizes] Sizes buffer\n   * @param {Batch[]} [options.children] Children batches\n   */\n  constructor({\n    length,\n    nullCount,\n    type,\n    validity,\n    values,\n    offsets,\n    sizes,\n    children\n  }) {\n    this.length = length;\n    this.nullCount = nullCount;\n    this.type = type;\n    this.validity = validity;\n    this.values = values;\n    this.offsets = offsets;\n    this.sizes = sizes;\n    this.children = children;\n\n    // optimize access if this batch has no null values\n    // some types (like union) may have null values in\n    // child batches, but no top-level validity buffer\n    if (!nullCount || !this.validity) {\n      /** @type {(index: number) => T | null} */\n      this.at = index => this.value(index);\n    }\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    return 'Batch';\n  }\n\n  /**\n   * Return the value at the given index.\n   * @param {number} index The value index.\n   * @returns {T | null} The value.\n   */\n  at(index) {\n    return this.isValid(index) ? this.value(index) : null;\n  }\n\n  /**\n   * Check if a value at the given index is valid (non-null).\n   * @param {number} index The value index.\n   * @returns {boolean} True if valid, false otherwise.\n   */\n  isValid(index) {\n    return decodeBit(this.validity, index);\n  }\n\n  /**\n   * Return the value at the given index. This method does not check the\n   * validity bitmap and is intended primarily for internal use. In most\n   * cases, callers should use the `at()` method instead.\n   * @param {number} index The value index\n   * @returns {T} The value, ignoring the validity bitmap.\n   */\n  value(index) {\n    return /** @type {T} */ (this.values[index]);\n  }\n\n  /**\n   * Extract an array of values within the given index range. Unlike\n   * Array.slice, all arguments are required and may not be negative indices.\n   * @param {number} start The starting index, inclusive\n   * @param {number} end The ending index, exclusive\n   * @returns {ValueArray<T?>} The slice of values\n   */\n  slice(start, end) {\n    const n = end - start;\n    const values = Array(n);\n    for (let i = 0; i < n; ++i) {\n      values[i] = this.at(start + i);\n    }\n    return values;\n  }\n\n  /**\n   * Return an iterator over the values in this batch.\n   * @returns {Iterator<T?>}\n   */\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.length; ++i) {\n      yield this.at(i);\n    }\n  }\n}\n\n/**\n * A batch whose value buffer can be used directly, without transformation.\n * @template T\n * @extends {Batch<T>}\n */\nexport class DirectBatch extends Batch {\n  /**\n   * Create a new column batch with direct value array access.\n   * @param {object} options\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {TypedArray} options.values Values buffer\n   */\n  constructor(options) {\n    super(options);\n    // underlying buffers may be padded, exceeding the logical batch length\n    // we trim the values array so we can safely access it directly\n    const { length, values } = this;\n    this.values = values.subarray(0, length);\n  }\n\n  /**\n   * Extract an array of values within the given index range. Unlike\n   * Array.slice, all arguments are required and may not be negative indices.\n   * When feasible, a zero-copy subarray of a typed array is returned.\n   * @param {number} start The starting index, inclusive\n   * @param {number} end The ending index, exclusive\n   * @returns {ValueArray<T?>} The slice of values\n   */\n  slice(start, end) {\n    // @ts-ignore\n    return this.nullCount\n      ? super.slice(start, end)\n      : this.values.subarray(start, end);\n  }\n\n  /**\n   * Return an iterator over the values in this batch.\n   * @returns {Iterator<T?>}\n   */\n  [Symbol.iterator]() {\n    return this.nullCount\n      ? super[Symbol.iterator]()\n      : /** @type {Iterator<T?>} */ (this.values[Symbol.iterator]());\n  }\n}\n\n/**\n * A batch whose values are transformed to 64-bit numbers.\n * @extends {Batch<number>}\n */\nexport class NumberBatch extends Batch {\n  static ArrayType = float64Array;\n}\n\n/**\n * A batch whose values should be returned in a standard array.\n * @template T\n * @extends {Batch<T>}\n */\nexport class ArrayBatch extends Batch {\n  static ArrayType = Array;\n}\n\n/**\n * A batch of null values only.\n * @extends {ArrayBatch<null>}\n */\nexport class NullBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   * @returns {null}\n   */\n  value(index) { // eslint-disable-line no-unused-vars\n    return null;\n  }\n}\n\n/**\n * A batch that coerces BigInt values to 64-bit numbers.\n * @extends {NumberBatch}\n */\nexport class Int64Batch extends NumberBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return toNumber(/** @type {bigint} */ (this.values[index]));\n  }\n}\n\n/**\n * A batch of 16-bit floating point numbers, accessed as unsigned\n * 16-bit ints and transformed to 64-bit numbers.\n */\nexport class Float16Batch extends NumberBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    const v = /** @type {number} */ (this.values[index]);\n    const expo = (v & 0x7C00) >> 10;\n    const sigf = (v & 0x03FF) / 1024;\n    const sign = (-1) ** ((v & 0x8000) >> 15);\n    switch (expo) {\n      case 0x1F: return sign * (sigf ? Number.NaN : 1 / 0);\n      case 0x00: return sign * (sigf ? 6.103515625e-5 * sigf : 0);\n    }\n    return sign * (2 ** (expo - 15)) * (1 + sigf);\n  }\n}\n\n/**\n * A batch of boolean values stored as a bitmap.\n * @extends {ArrayBatch<boolean>}\n */\nexport class BoolBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return decodeBit(/** @type {Uint8Array} */ (this.values), index);\n  }\n}\n\n/**\n * A batch of 32-bit decimal numbers, returned as converted 64-bit floating\n * point numbers. Number coercion may be lossy if the decimal precision can\n * not be represented in a 64-bit floating point format.\n * @extends {NumberBatch}\n */\nexport class Decimal32NumberBatch extends NumberBatch {\n  constructor(options) {\n    super(options);\n    const { scale } = /** @type {DecimalType} */ (this.type);\n    this.scale = 10 ** scale;\n  }\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return /** @type {number} */(this.values[index]) / this.scale;\n  }\n}\n\n/**\n * An abstract class for a batch of 64-, 128- or 256-bit decimal numbers,\n * accessed in strided BigUint64Arrays.\n * @template T\n * @extends {Batch<T>}\n */\nexport class DecimalBatch extends Batch {\n  constructor(options) {\n    super(options);\n    const { bitWidth, scale } = /** @type {DecimalType} */ (this.type);\n    this.decimal = bitWidth === 64 ? fromDecimal64\n      : bitWidth === 128 ? fromDecimal128\n      : fromDecimal256;\n    this.scale = 10n ** BigInt(scale);\n  }\n}\n\n/**\n * A batch of 64-, 128- or 256-bit decimal numbers, returned as converted\n * 64-bit floating point numbers. Number coercion may be lossy if the decimal\n * precision can not be represented in a 64-bit floating point format.\n * @extends {DecimalBatch<number>}\n */\nexport class DecimalNumberBatch extends DecimalBatch {\n  static ArrayType = float64Array;\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return divide(\n      this.decimal(/** @type {BigUint64Array} */ (this.values), index),\n      this.scale\n    );\n  }\n}\n\n/**\n * A batch of 64-, 128- or 256-bit decimal numbers, returned as scaled\n * bigint values, such that all fractional digits have been shifted\n * to integer places by the decimal type scale factor.\n * @extends {DecimalBatch<bigint>}\n */\nexport class DecimalBigIntBatch extends DecimalBatch {\n  static ArrayType = Array;\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return this.decimal(/** @type {BigUint64Array} */ (this.values), index);\n  }\n}\n\n/**\n * A batch of date or timestamp values that are coerced to UNIX epoch timestamps\n * and returned as JS Date objects. This batch wraps a source batch that provides\n * timestamp values.\n * @extends {ArrayBatch<Date>}\n */\nexport class DateBatch extends ArrayBatch {\n  /**\n   * Create a new date batch.\n   * @param {Batch<number>} batch A batch of timestamp values.\n   */\n  constructor(batch) {\n    super(batch);\n    this.source = batch;\n  }\n\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return new Date(this.source.value(index));\n  }\n}\n\n/**\n * A batch of dates as day counts, coerced to timestamp numbers.\n */\nexport class DateDayBatch extends NumberBatch {\n  /**\n   * @param {number} index The value index\n   * @returns {number}\n   */\n  value(index) {\n    // epoch days to milliseconds\n    return 86400000 * /** @type {number} */ (this.values[index]);\n  }\n}\n\n/**\n * A batch of dates as millisecond timestamps, coerced to numbers.\n */\nexport const DateDayMillisecondBatch = Int64Batch;\n\n/**\n * A batch of timestaps in seconds, coerced to millisecond numbers.\n */\nexport class TimestampSecondBatch extends Int64Batch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return super.value(index) * 1e3; // seconds to milliseconds\n  }\n}\n\n/**\n * A batch of timestaps in milliseconds, coerced to numbers.\n */\nexport const TimestampMillisecondBatch = Int64Batch;\n\n/**\n * A batch of timestaps in microseconds, coerced to millisecond numbers.\n */\nexport class TimestampMicrosecondBatch extends Int64Batch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    // microseconds to milliseconds\n    return divide(/** @type {bigint} */ (this.values[index]), 1000n);\n  }\n}\n\n/**\n * A batch of timestaps in nanoseconds, coerced to millisecond numbers.\n */\nexport class TimestampNanosecondBatch extends Int64Batch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    // nanoseconds to milliseconds\n    return divide(/** @type {bigint} */ (this.values[index]), 1000000n);\n  }\n}\n\n/**\n * A batch of day/time intervals, returned as two-element 32-bit int arrays.\n * @extends {ArrayBatch<Int32Array>}\n */\nexport class IntervalDayTimeBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   * @returns {Int32Array}\n   */\n  value(index) {\n    const values = /** @type {Int32Array} */ (this.values);\n    return values.subarray(index << 1, (index + 1) << 1);\n  }\n}\n\n/**\n * A batch of month/day/nanosecond intervals, returned as three-element arrays.\n * @extends {ArrayBatch<Float64Array>}\n */\nexport class IntervalMonthDayNanoBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    const values = /** @type {Uint8Array} */ (this.values);\n    const base = index << 4;\n    return Float64Array.of(\n      readInt32(values, base),\n      readInt32(values, base + 4),\n      readInt64(values, base + 8)\n    );\n  }\n}\n\nconst offset32 = ({values, offsets}, index) => values.subarray(offsets[index], offsets[index + 1]);\nconst offset64 = ({values, offsets}, index) => values.subarray(toNumber(offsets[index]), toNumber(offsets[index + 1]));\n\n/**\n * A batch of binary blobs with variable offsets, returned as byte buffers of\n * unsigned 8-bit integers. The offsets are 32-bit ints.\n * @extends {ArrayBatch<Uint8Array>}\n */\nexport class BinaryBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {Uint8Array}\n   */\n  value(index) {\n    return offset32(this, index);\n  }\n}\n\n/**\n * A batch of binary blobs with variable offsets, returned as byte buffers of\n * unsigned 8-bit integers. The offsets are 64-bit ints. Value extraction will\n * fail if an offset exceeds `Number.MAX_SAFE_INTEGER`.\n * @extends {ArrayBatch<Uint8Array>}\n */\nexport class LargeBinaryBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {Uint8Array}\n   */\n  value(index) {\n    return offset64(this, index);\n  }\n}\n\n/**\n * A batch of UTF-8 strings with variable offsets. The offsets are 32-bit ints.\n * @extends {ArrayBatch<string>}\n */\nexport class Utf8Batch extends ArrayBatch {\n  /**\n   * @param {number} index\n   */\n  value(index) {\n    return decodeUtf8(offset32(this, index));\n  }\n}\n\n/**\n * A batch of UTF-8 strings with variable offsets. The offsets are 64-bit ints.\n * Value extraction will fail if an offset exceeds `Number.MAX_SAFE_INTEGER`.\n * @extends {ArrayBatch<string>}\n */\nexport class LargeUtf8Batch extends ArrayBatch {\n  /**\n   * @param {number} index\n   */\n  value(index) {\n    return decodeUtf8(offset64(this, index));\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets are\n * 32-bit ints.\n * @template V\n * @extends {ArrayBatch<ValueArray<V>>}\n */\nexport class ListBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const offsets = /** @type {Int32Array} */ (this.offsets);\n    return this.children[0].slice(offsets[index], offsets[index + 1]);\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets are\n * 64-bit ints. Value extraction will fail if an offset exceeds\n * `Number.MAX_SAFE_INTEGER`.\n * @template V\n * @extends {ArrayBatch<ValueArray<V>>}\n */\nexport class LargeListBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const offsets = /** @type {BigInt64Array} */ (this.offsets);\n    return this.children[0].slice(toNumber(offsets[index]), toNumber(offsets[index + 1]));\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets and\n * sizes are 32-bit ints.\n * @template V\n * @extends {ArrayBatch<ValueArray<V>>}\n */\nexport class ListViewBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const a = /** @type {number} */ (this.offsets[index]);\n    const b = a + /** @type {number} */ (this.sizes[index]);\n    return this.children[0].slice(a, b);\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets and\n * sizes are 64-bit ints. Value extraction will fail if an offset or size\n * exceeds `Number.MAX_SAFE_INTEGER`.\n * @template V\n * @extends {ArrayBatch<ValueArray<V>>}\n */\nexport class LargeListViewBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const a = /** @type {bigint} */ (this.offsets[index]);\n    const b = a + /** @type {bigint} */ (this.sizes[index]);\n    return this.children[0].slice(toNumber(a), toNumber(b));\n  }\n}\n\n/**\n * A batch with a fixed stride.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nclass FixedBatch extends ArrayBatch {\n  constructor(options) {\n    super(options);\n    /** @type {number} */\n    // @ts-ignore\n    this.stride = this.type.stride;\n  }\n}\n\n/**\n * A batch of binary blobs of fixed size, returned as byte buffers of unsigned\n * 8-bit integers.\n * @extends {FixedBatch<Uint8Array>}\n */\nexport class FixedBinaryBatch extends FixedBatch {\n  /**\n   * @param {number} index\n   * @returns {Uint8Array}\n   */\n  value(index) {\n    const { stride, values } = this;\n    return /** @type {Uint8Array} */ (values)\n      .subarray(index * stride, (index + 1) * stride);\n  }\n}\n\n/**\n * A batch of list (array) values of fixed length.\n * @template V\n * @extends {FixedBatch<ValueArray<V>>}\n */\nexport class FixedListBatch extends FixedBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const { children, stride } = this;\n    return children[0].slice(index * stride, (index + 1) * stride);\n  }\n}\n\n/**\n * Extract Map key-value pairs from parallel child batches.\n */\nfunction pairs({ children, offsets }, index) {\n  const [ keys, vals ] = children[0].children;\n  const start = offsets[index];\n  const end = offsets[index + 1];\n  const entries = [];\n  for (let i = start; i < end; ++i) {\n    entries.push([keys.at(i), vals.at(i)]);\n  }\n  return entries;\n}\n\n/**\n * A batch of map (key, value) values. The map is represented as a list of\n * key-value structs.\n * @template K, V\n * @extends {ArrayBatch<[K, V][]>}\n */\nexport class MapEntryBatch extends ArrayBatch {\n  /**\n   * Return the value at the given index.\n   * @param {number} index The value index.\n   * @returns {[K, V][]} The map entries as an array of [key, value] arrays.\n   */\n  value(index) {\n    return /** @type {[K, V][]} */ (pairs(this, index));\n  }\n}\n\n/**\n * A batch of map (key, value) values. The map is represented as a list of\n * key-value structs.\n * @template K, V\n * @extends {ArrayBatch<Map<K, V>>}\n */\nexport class MapBatch extends ArrayBatch {\n  /**\n   * Return the value at the given index.\n   * @param {number} index The value index.\n   * @returns {Map<K, V>} The map value.\n   */\n  value(index) {\n    return new Map(/** @type {[K, V][]} */ (pairs(this, index)));\n  }\n}\n\n/**\n * A batch of union-type values with a sparse layout, enabling direct\n * lookup from the child value batches.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nexport class SparseUnionBatch extends ArrayBatch {\n  /**\n   * Create a new column batch.\n   * @param {object} options\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {Int32Array} [options.offsets] Offsets buffer\n   * @param {Batch[]} options.children Children batches\n   * @param {Int8Array} options.typeIds Union type ids buffer\n   * @param {Record<string, number>} options.map A typeId to children index map\n   */\n  constructor({ typeIds, ...options }) {\n    super(options);\n    /** @type {Int8Array} */\n    this.typeIds = typeIds;\n    /** @type {Record<string, number>} */\n    // @ts-ignore\n    this.typeMap = this.type.typeMap;\n  }\n\n  /**\n   * @param {number} index The value index.\n   */\n  value(index, offset = index) {\n    const { typeIds, children, typeMap } = this;\n    return children[typeMap[typeIds[index]]].at(offset);\n  }\n}\n\n/**\n * A batch of union-type values with a dense layout, reqiring offset\n * lookups from the child value batches.\n * @template T\n * @extends {SparseUnionBatch<T>}\n */\nexport class DenseUnionBatch extends SparseUnionBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return super.value(index, /** @type {number} */ (this.offsets[index]));\n  }\n}\n\n/**\n * A batch of struct values, containing a set of named properties.\n * Struct property values are extracted and returned as JS objects.\n * @extends {ArrayBatch<Record<string, any>>}\n */\nexport class StructBatch extends ArrayBatch {\n  constructor(options, factory = objectFactory) {\n    super(options);\n    /** @type {string[]} */\n    // @ts-ignore\n    this.names = this.type.children.map(child => child.name);\n    this.factory = factory(this.names, this.children);\n  }\n\n  /**\n   * @param {number} index The value index.\n   * @returns {Record<string, any>}\n   */\n  value(index) {\n    return this.factory(index);\n  }\n}\n\n/**\n * A batch of struct values, containing a set of named properties.\n * Structs are returned as proxy objects that extract data directly\n * from underlying Arrow batches.\n * @extends {StructBatch}\n */\nexport class StructProxyBatch extends StructBatch {\n  constructor(options) {\n    super(options, proxyFactory);\n  }\n}\n\n/**\n * A batch of run-end-encoded values.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nexport class RunEndEncodedBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    const [ { values: runs }, vals ] = this.children;\n    return vals.at(\n      bisect(/** @type {IntegerArray} */(runs), index)\n    );\n  }\n}\n\n/**\n * A batch of dictionary-encoded values.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nexport class DictionaryBatch extends ArrayBatch {\n  /**\n   * Register the backing dictionary. Dictionaries are added\n   * after batch creation as the complete dictionary may not\n   * be finished across multiple record batches.\n   * @param {Column<T>} dictionary\n   * The dictionary of column values.\n   */\n  setDictionary(dictionary) {\n    this.dictionary = dictionary;\n    this.cache = dictionary.cache();\n    return this;\n  }\n\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return this.cache[this.key(index)];\n  }\n\n  /**\n   * @param {number} index The value index.\n   * @returns {number} The dictionary key\n   */\n  key(index) {\n    return /** @type {number} */ (this.values[index]);\n  }\n}\n\n/**\n * @template T\n * @extends {ArrayBatch<T>}\n */\nclass ViewBatch extends ArrayBatch {\n  /**\n   * Create a new view batch.\n   * @param {object} options Batch options.\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {Uint8Array} options.values Values buffer\n   * @param {Uint8Array[]} options.data View data buffers\n   */\n  constructor({ data, ...options }) {\n    super(options);\n    this.data = data;\n  }\n\n  /**\n   * Get the binary data at the provided index.\n   * @param {number} index The value index.\n   * @returns {Uint8Array}\n   */\n  view(index) {\n    const { values, data } = this;\n    const offset = index << 4; // each entry is 16 bytes\n    let start = offset + 4;\n    let buf = /** @type {Uint8Array} */ (values);\n    const length = readInt32(buf, offset);\n    if (length > 12) {\n      // longer strings are in a data buffer\n      start = readInt32(buf, offset + 12);\n      buf = data[readInt32(buf, offset + 8)];\n    }\n    return buf.subarray(start, start + length);\n  }\n}\n\n/**\n * A batch of binary blobs from variable data buffers, returned as byte\n * buffers of unsigned 8-bit integers.\n * @extends {ViewBatch<Uint8Array>}\n */\nexport class BinaryViewBatch extends ViewBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return this.view(index);\n  }\n}\n\n/**\n * A batch of UTF-8 strings from variable data buffers.\n * @extends {ViewBatch<string>}\n */\nexport class Utf8ViewBatch extends ViewBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return decodeUtf8(this.view(index));\n  }\n}\n","/**\n * @import { Batch } from './batch.js'\n * @import { DataType, ValueArray } from './types.js'\n */\nimport { bisect } from './util/arrays.js';\nimport { isDirectBatch } from './batch.js';\n\n/**\n * Build up a column from batches.\n */\nexport function columnBuilder(type) {\n  let data = [];\n  return {\n    add(batch) { data.push(batch); return this; },\n    clear: () => data = [],\n    done: () => new Column(data, type)\n  };\n}\n\n/**\n * A data column. A column provides a view over one or more value batches,\n * each drawn from an Arrow record batch. This class supports random access\n * to column values by integer index; however, extracting arrays using\n * `toArray()` or iterating over values (`for (const value of column) {...}`)\n * provide more efficient ways for bulk access or scanning.\n * @template T\n */\nexport class Column {\n  /**\n   * Create a new column instance.\n   * @param {Batch<T>[]} data The value batches.\n   * @param {DataType} [type] The column data type.\n   *  If not specified, the type is extracted from the batches.\n   */\n  constructor(data, type = data[0]?.type) {\n    /**\n     * The column data type.\n     * @type {DataType}\n     * @readonly\n     */\n    this.type = type;\n    /**\n     * The column length.\n     * @type {number}\n     * @readonly\n     */\n    this.length = data.reduce((m, c) => m + c.length, 0);\n    /**\n     * The count of null values in the column.\n     * @type {number}\n     * @readonly\n     */\n    this.nullCount = data.reduce((m, c) => m + c.nullCount, 0);\n    /**\n     * An array of column data batches.\n     * @type {readonly Batch<T>[]}\n     * @readonly\n     */\n    this.data = data;\n\n    const n = data.length;\n    const offsets = new Int32Array(n + 1);\n    if (n === 1) {\n      const [ batch ] = data;\n      offsets[1] = batch.length;\n      // optimize access to single batch\n      this.at = index => batch.at(index);\n    } else {\n      for (let i = 0, s = 0; i < n; ++i) {\n        offsets[i + 1] = (s += data[i].length);\n      }\n    }\n\n    /**\n     * Index offsets for data batches.\n     * Used to map a column row index to a batch-specific index.\n     * @type {Int32Array}\n     * @readonly\n     */\n    this.offsets = offsets;\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    return 'Column';\n  }\n\n  /**\n   * Return an iterator over the values in this column.\n   * @returns {Iterator<T?>}\n   */\n  [Symbol.iterator]() {\n    const data = this.data;\n    return data.length === 1\n      ? data[0][Symbol.iterator]()\n      : batchedIterator(data);\n  }\n\n  /**\n   * Return the column value at the given index. If a column has multiple\n   * batches, this method performs binary search over the batch lengths to\n   * determine the batch from which to retrieve the value. The search makes\n   * lookup less efficient than a standard array access. If making a full\n   * scan of a column, consider extracting arrays via `toArray()` or using an\n   * iterator (`for (const value of column) {...}`).\n   * @param {number} index The row index.\n   * @returns {T | null} The value.\n   */\n  at(index) {\n    // NOTE: if there is only one batch, this method is replaced with an\n    // optimized version in the Column constructor.\n    const { data, offsets } = this;\n    const i = bisect(offsets, index) - 1;\n    return data[i]?.at(index - offsets[i]); // undefined if out of range\n  }\n\n  /**\n   * Return the column value at the given index. This method is the same as\n   * `at()` and is provided for better compatibility with Apache Arrow JS.\n   * @param {number} index The row index.\n   * @returns {T | null} The value.\n   */\n  get(index) {\n    return this.at(index);\n  }\n\n  /**\n   * Extract column values into a single array instance. When possible,\n   * a zero-copy subarray of the input Arrow data is returned.\n   * @returns {ValueArray<T?>}\n   */\n  toArray() {\n    const { length, nullCount, data } = this;\n    const copy = !nullCount && isDirectBatch(data[0]);\n    const n = data.length;\n\n    if (copy && n === 1) {\n      // use batch array directly\n      // @ts-ignore\n      return data[0].values;\n    }\n\n    // determine output array type\n    const ArrayType = !n || nullCount > 0 ? Array\n      // @ts-ignore\n      : (data[0].constructor.ArrayType ?? data[0].values.constructor);\n\n    const array = new ArrayType(length);\n    return copy ? copyArray(array, data) : extractArray(array, data);\n  }\n\n  /**\n   * Return an array of cached column values.\n   * Used internally to accelerate dictionary types.\n   */\n  cache() {\n    return this._cache ?? (this._cache = this.toArray());\n  }\n}\n\nfunction *batchedIterator(data) {\n  for (let i = 0; i < data.length; ++i) {\n    const iter = data[i][Symbol.iterator]();\n    for (let next = iter.next(); !next.done; next = iter.next()) {\n      yield next.value;\n    }\n  }\n}\n\nfunction copyArray(array, data) {\n  for (let i = 0, offset = 0; i < data.length; ++i) {\n    const { values } = data[i];\n    array.set(values, offset);\n    offset += values.length;\n  }\n  return array;\n}\n\nfunction extractArray(array, data) {\n  let index = -1;\n  for (let i = 0; i < data.length; ++i) {\n    const batch = data[i];\n    for (let j = 0; j < batch.length; ++j) {\n      array[++index] = batch.at(j);\n    }\n  }\n  return array;\n}\n","/**\n * @import { Column } from './column.js'\n * @import { Schema, StructFactory, TypeMap, ValueArray } from './types.js'\n */\nimport { bisect } from './util/arrays.js';\nimport { objectFactory, proxyFactory } from './util/struct.js';\n\n/**\n * A table consists of a collection of named columns (or 'children').\n * To work with table data directly in JavaScript, use `toColumns()`\n * to extract an object that maps column names to extracted value arrays,\n * or `toArray()` to extract an array of row objects. For random access\n * by row index, use `getChild()` to access data for a specific column.\n * @template {TypeMap} [T=TypeMap]\n */\nexport class Table {\n  /**\n   * Create a new table with the given schema and columns (children).\n   * @param {Schema} schema The table schema.\n   * @param {Column[]} children The table columns.\n   * @param {boolean} [useProxy=false] Flag indicating if row proxy\n   *  objects should be used to represent table rows (default `false`).\n   */\n  constructor(schema, children, useProxy = false) {\n    const names = schema.fields.map(f => f.name);\n\n    /**\n     * @type {Schema}\n     * @readonly\n     */\n    this.schema = schema;\n    /**\n     * @type {(keyof T)[]}\n     * @readonly\n     */\n    this.names = names;\n    /**\n     * @type {Column[]}\n     * @readonly\n     */\n    this.children = children;\n    /**\n     * @type {StructFactory}\n     * @readonly\n     */\n    this.factory = useProxy ? proxyFactory : objectFactory;\n\n    // lazily created row object generators\n    const gen = [];\n\n    /**\n     * Returns a row object generator for the given batch index.\n     * @private\n     * @readonly\n     * @param {number} b The batch index.\n     * @returns {(index: number) => { [P in keyof T]: T[P] }}\n     */\n    this.getFactory = b => gen[b]\n      ?? (gen[b] = this.factory(names, children.map(c => c.data[b])));\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    return 'Table';\n  }\n\n  /**\n   * The number of columns in this table.\n   * @return {number} The number of columns.\n   */\n  get numCols() {\n    return this.names.length;\n  }\n\n  /**\n   * The number of rows in this table.\n   * @return {number} The number of rows.\n   */\n  get numRows() {\n    return this.children[0]?.length ?? 0;\n  }\n\n  /**\n   * Return the child column at the given index position.\n   * @template {T[keyof T]} R\n   * @param {number} index The column index.\n   * @returns {Column<R>}\n   */\n  getChildAt(index) {\n    return this.children[index];\n  }\n\n  /**\n   * Return the first child column with the given name.\n   * @template {keyof T} P\n   * @param {P} name The column name.\n   * @returns {Column<T[P]>}\n   */\n  getChild(name) {\n    const i = this.names.findIndex(x => x === name);\n    return i > -1 ? this.children[i] : undefined;\n  }\n\n  /**\n   * Construct a new table containing only columns at the specified indices.\n   * The order of columns in the new table matches the order of input indices.\n   * @template {T[keyof T]} V\n   * @param {number[]} indices The indices of columns to keep.\n   * @param {string[]} [as] Optional new names for selected columns.\n   * @returns {Table<{ [key: string]: V }>} A new table with selected columns.\n   */\n  selectAt(indices, as = []) {\n    const { children, factory, schema } = this;\n    const { fields } = schema;\n    return new Table(\n      {\n        ...schema,\n        fields: indices.map((i, j) => renameField(fields[i], as[j]))\n      },\n      indices.map(i => children[i]),\n      factory === proxyFactory\n    );\n  }\n\n  /**\n   * Construct a new table containing only columns with the specified names.\n   * If columns have duplicate names, the first (with lowest index) is used.\n   * The order of columns in the new table matches the order of input names.\n   * @template {keyof T} K\n   * @param {K[]} names Names of columns to keep.\n   * @param {string[]} [as] Optional new names for selected columns.\n   * @returns A new table with columns matching the specified names.\n   */\n  select(names, as) {\n    const all = /** @type {K[]} */(this.names);\n    const indices = names.map(name => all.indexOf(name));\n    return this.selectAt(indices, as);\n  }\n\n  /**\n   * Return an object mapping column names to extracted value arrays.\n   * @returns {{ [P in keyof T]: ValueArray<T[P]> }}\n   */\n  toColumns() {\n    const { children, names } = this;\n    /** @type {{ [P in keyof T]: ValueArray<T[P]> }} */\n    // @ts-expect-error assign to empty object\n    const cols = {};\n    names.forEach((name, i) => cols[name] = children[i]?.toArray() ?? [] );\n    return cols;\n  }\n\n  /**\n   * Return an array of objects representing the rows of this table.\n   * @returns {{ [P in keyof T]: T[P] }[]}\n   */\n  toArray() {\n    const { children, getFactory, numRows } = this;\n    const data = children[0]?.data ?? [];\n    const output = Array(numRows);\n    for (let b = 0, row = -1; b < data.length; ++b) {\n      const f = getFactory(b);\n      for (let i = 0; i < data[b].length; ++i) {\n        output[++row] = f(i);\n      }\n    }\n    return output;\n  }\n\n  /**\n   * Return an iterator over objects representing the rows of this table.\n   * @returns {Generator<{ [P in keyof T]: T[P] }, any, any>}\n   */\n  *[Symbol.iterator]() {\n    const { children, getFactory } = this;\n    const data = children[0]?.data ?? [];\n    for (let b = 0; b < data.length; ++b) {\n      const f = getFactory(b);\n      for (let i = 0; i < data[b].length; ++i) {\n        yield f(i);\n      }\n    }\n  }\n\n  /**\n   * Return a row object for the given index.\n   * @param {number} index The row index.\n   * @returns {{ [P in keyof T]: T[P] }} The row object.\n   */\n  at(index) {\n    const { children, getFactory, numRows } = this;\n    if (index < 0 || index >= numRows) return null;\n    const [{ offsets }] = children;\n    const b = bisect(offsets, index) - 1;\n    return getFactory(b)(index - offsets[b]);\n  }\n\n  /**\n   * Return a row object for the given index. This method is the same as\n   * `at()` and is provided for better compatibility with Apache Arrow JS.\n   * @param {number} index The row index.\n   * @returns {{ [P in keyof T]: T[P] }} The row object.\n   */\n  get(index) {\n    return this.at(index);\n  }\n}\n\nfunction renameField(field, name) {\n  return (name != null && name !== field.name)\n    ? { ...field, name }\n    : field;\n}\n","/**\n * @import { DataType, ExtractionOptions } from './types.js';\n */\nimport { BinaryBatch, BinaryViewBatch, BoolBatch, DateBatch, DateDayBatch, DateDayMillisecondBatch, Decimal32NumberBatch, DecimalBigIntBatch, DecimalNumberBatch, DenseUnionBatch, DictionaryBatch, DirectBatch, FixedBinaryBatch, FixedListBatch, Float16Batch, Int64Batch, IntervalDayTimeBatch, IntervalMonthDayNanoBatch, LargeBinaryBatch, LargeListBatch, LargeListViewBatch, LargeUtf8Batch, ListBatch, ListViewBatch, MapBatch, MapEntryBatch, NullBatch, RunEndEncodedBatch, SparseUnionBatch, StructBatch, StructProxyBatch, TimestampMicrosecondBatch, TimestampMillisecondBatch, TimestampNanosecondBatch, TimestampSecondBatch, Utf8Batch, Utf8ViewBatch } from './batch.js';\nimport { DateUnit, IntervalUnit, TimeUnit, Type } from './constants.js';\nimport { invalidDataType } from './data-types.js';\n\n/**\n * Return a batch constructor for the given data type and extraction options.\n * @param {DataType} type The data type.\n * @param {ExtractionOptions} options The extraction options.\n */\nexport function batchType(type, options = {}) {\n  const { typeId, bitWidth, mode, precision, unit } = /** @type {any} */(type);\n  const { useBigInt, useDate, useDecimalInt, useMap, useProxy } = options;\n\n  switch (typeId) {\n    case Type.Null: return NullBatch;\n    case Type.Bool: return BoolBatch;\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n      return useBigInt || bitWidth < 64 ? DirectBatch : Int64Batch;\n    case Type.Float:\n      return precision ? DirectBatch : Float16Batch;\n    case Type.Date:\n      return wrap(\n        unit === DateUnit.DAY ? DateDayBatch : DateDayMillisecondBatch,\n        useDate && DateBatch\n      );\n    case Type.Timestamp:\n      return wrap(\n        unit === TimeUnit.SECOND ? TimestampSecondBatch\n          : unit === TimeUnit.MILLISECOND ? TimestampMillisecondBatch\n          : unit === TimeUnit.MICROSECOND ? TimestampMicrosecondBatch\n          : TimestampNanosecondBatch,\n        useDate && DateBatch\n      );\n    case Type.Decimal:\n      return bitWidth === 32\n        ? (useDecimalInt ? DirectBatch : Decimal32NumberBatch)\n        : (useDecimalInt ? DecimalBigIntBatch : DecimalNumberBatch);\n    case Type.Interval:\n      return unit === IntervalUnit.DAY_TIME ? IntervalDayTimeBatch\n        : unit === IntervalUnit.YEAR_MONTH ? DirectBatch\n        : IntervalMonthDayNanoBatch;\n    case Type.FixedSizeBinary: return FixedBinaryBatch;\n    case Type.Utf8: return Utf8Batch;\n    case Type.LargeUtf8: return LargeUtf8Batch;\n    case Type.Binary: return BinaryBatch;\n    case Type.LargeBinary: return LargeBinaryBatch;\n    case Type.BinaryView: return BinaryViewBatch;\n    case Type.Utf8View: return Utf8ViewBatch;\n    case Type.List: return ListBatch;\n    case Type.LargeList: return LargeListBatch;\n    case Type.Map: return useMap ? MapBatch : MapEntryBatch;\n    case Type.ListView: return ListViewBatch;\n    case Type.LargeListView: return LargeListViewBatch;\n    case Type.FixedSizeList: return FixedListBatch;\n    case Type.Struct: return useProxy ? StructProxyBatch : StructBatch;\n    case Type.RunEndEncoded: return RunEndEncodedBatch;\n    case Type.Dictionary: return DictionaryBatch;\n    case Type.Union: return mode ? DenseUnionBatch : SparseUnionBatch;\n  }\n  throw new Error(invalidDataType(typeId));\n}\n\nfunction wrap(BaseClass, WrapperClass) {\n  return WrapperClass\n    ? class WrapBatch extends WrapperClass {\n        constructor(options) {\n          super(new BaseClass(options));\n        }\n      }\n    : BaseClass;\n}\n","import { readInt32, readInt64, readVector } from '../util/read.js';\n\n/**\n * Decode a block that points to messages within an Arrow 'file' format.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns The file block.\n */\nexport function decodeBlock(buf, index) {\n  //  0: offset\n  //  8: metadataLength\n  // 16: bodyLength\n  return {\n    offset: readInt64(buf, index),\n    metadataLength: readInt32(buf, index + 8),\n    bodyLength: readInt64(buf, index + 16)\n  }\n}\n\n/**\n * Decode a vector of blocks.\n * @param {Uint8Array} buf\n * @param {number} index\n * @returns An array of file blocks.\n */\nexport function decodeBlocks(buf, index) {\n  return readVector(buf, index, 24, decodeBlock);\n}\n","/**\n * @import { RecordBatch, Version_ } from '../types.js'\n */\nimport { Version } from '../constants.js';\nimport { readInt64, readObject, readOffset, readVector } from '../util/read.js';\n\n/**\n * Decode a record batch.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @param {Version_} version Arrow version value\n * @returns {RecordBatch} The record batch\n */\nexport function decodeRecordBatch(buf, index, version) {\n  //  4: length\n  //  6: nodes\n  //  8: buffers\n  // 10: compression (not supported)\n  // 12: variadicBuffers (buffer counts for view-typed fields)\n  const get = readObject(buf, index);\n  if (get(10, readOffset, 0)) {\n    throw new Error('Record batch compression not implemented');\n  }\n\n  // If an Arrow buffer was written before version 4,\n  // advance 8 bytes to skip the now-removed page_id field\n  const offset = version < Version.V4 ? 8 : 0;\n\n  return {\n    length: get(4, readInt64, 0),\n    nodes: readVector(buf, get(6, readOffset), 16, (buf, pos) => ({\n      length: readInt64(buf, pos),\n      nullCount: readInt64(buf, pos + 8)\n    })),\n    regions: readVector(buf, get(8, readOffset), 16 + offset, (buf, pos) => ({\n      offset: readInt64(buf, pos + offset),\n      length: readInt64(buf, pos + offset + 8)\n    })),\n    variadic: readVector(buf, get(12, readOffset), 8, readInt64)\n  };\n}\n","/**\n * @import { DictionaryBatch, Version_ } from '../types.js'\n */\nimport { readBoolean, readInt64, readObject } from '../util/read.js';\nimport { decodeRecordBatch } from './record-batch.js';\n\n/**\n * Decode a dictionary batch.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @param {Version_} version Arrow version value\n * @returns {DictionaryBatch} The dictionary batch\n */\nexport function decodeDictionaryBatch(buf, index, version) {\n  //  4: id\n  //  6: data\n  //  8: isDelta\n  const get = readObject(buf, index);\n  return {\n    id: get(4, readInt64, 0),\n    data: get(6, (buf, off) => decodeRecordBatch(buf, off, version)),\n    /**\n     * If isDelta is true the values in the dictionary are to be appended to a\n     * dictionary with the indicated id. If isDelta is false this dictionary\n     * should replace the existing dictionary.\n     */\n    isDelta: get(8, readBoolean, false)\n  };\n}\n","/**\n * @import { DataType, Field } from '../types.js'\n */\nimport { DateUnit, IntervalUnit, Precision, TimeUnit, Type, UnionMode } from '../constants.js';\nimport { binary, date, decimal, duration, fixedSizeBinary, fixedSizeList, float, int, interval, invalidDataType, largeBinary, largeList, largeListView, largeUtf8, list, listView, mapType, runEndEncoded, struct, time, timestamp, union, utf8 } from '../data-types.js';\nimport { checkOneOf } from '../util/objects.js';\nimport { readBoolean, readInt16, readInt32, readObject, readOffset, readString, readVector } from '../util/read.js';\n\n/**\n * Decode a data type definition for a field.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data.\n * @param {number} index The starting index in the byte buffer.\n * @param {number} typeId The data type id.\n * @param {Field[]} [children] A list of parsed child fields.\n * @returns {DataType} The data type.\n */\nexport function decodeDataType(buf, index, typeId, children) {\n  checkOneOf(typeId, Type, invalidDataType);\n  const get = readObject(buf, index);\n\n  switch (typeId) {\n    // types without flatbuffer objects\n    case Type.Binary: return binary();\n    case Type.Utf8: return utf8();\n    case Type.LargeBinary: return largeBinary();\n    case Type.LargeUtf8: return largeUtf8();\n    case Type.List: return list(children[0]);\n    case Type.ListView: return listView(children[0]);\n    case Type.LargeList: return largeList(children[0]);\n    case Type.LargeListView: return largeListView(children[0]);\n    case Type.Struct: return struct(children);\n    case Type.RunEndEncoded: return runEndEncoded(children[0], children[1]);\n\n    // types with flatbuffer objects\n    case Type.Int: return int(\n      // @ts-ignore\n      get(4, readInt32, 0), // bitwidth\n      get(6, readBoolean, false) // signed\n    );\n    case Type.Float: return float(\n      // @ts-ignore\n      get(4, readInt16, Precision.HALF) // precision\n    );\n    case Type.Decimal: return decimal(\n      get(4, readInt32, 0), // precision\n      get(6, readInt32, 0), // scale\n      // @ts-ignore\n      get(8, readInt32, 128) // bitwidth\n    );\n    case Type.Date: return date(\n      // @ts-ignore\n      get(4, readInt16, DateUnit.MILLISECOND) // unit\n    );\n    case Type.Time: return time(\n      // @ts-ignore\n      get(4, readInt16, TimeUnit.MILLISECOND) // unit\n    );\n    case Type.Timestamp: return timestamp(\n      // @ts-ignore\n      get(4, readInt16, TimeUnit.SECOND), // unit\n      get(6, readString) // timezone\n    );\n    case Type.Interval: return interval(\n      // @ts-ignore\n      get(4, readInt16, IntervalUnit.YEAR_MONTH) // unit\n    );\n    case Type.Duration: return duration(\n      // @ts-ignore\n      get(4, readInt16, TimeUnit.MILLISECOND) // unit\n    );\n\n    case Type.FixedSizeBinary: return fixedSizeBinary(\n      get(4, readInt32, 0) // stride\n    );\n    case Type.FixedSizeList: return fixedSizeList(\n      children[0],\n      get(4, readInt32, 0), // stride\n    );\n    case Type.Map: return mapType(\n      get(4, readBoolean, false), // keysSorted\n      children[0]\n    );\n\n    case Type.Union: return union(\n      // @ts-ignore\n      get(4, readInt16, UnionMode.Sparse), // mode\n      children,\n      readVector(buf, get(6, readOffset), 4, readInt32) // type ids\n    );\n  }\n  // case Type.NONE:\n  // case Type.Null:\n  // case Type.Bool:\n  // case Type.BinaryView:\n  // case Type.Utf8View:\n  // @ts-ignore\n  return { typeId };\n}\n","/**\n * @import { Metadata } from '../types.js'\n */\nimport { readObject, readString, readVector } from '../util/read.js';\n\n/**\n * Decode custom metadata consisting of key-value string pairs.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns {Metadata | null} The custom metadata map\n */\nexport function decodeMetadata(buf, index) {\n  const entries = readVector(buf, index, 4, (buf, pos) => {\n    const get = readObject(buf, pos);\n    return /** @type {[string, string]} */ ([\n      get(4, readString), // 4: key (string)\n      get(6, readString)  // 6: key (string)\n    ]);\n  });\n  return entries.length ? new Map(entries) : null;\n}\n","/**\n * @import { DictionaryType, Endianness_, Field, IntType, Schema, Version_ } from '../types.js'\n */\nimport { Type } from '../constants.js';\nimport { dictionary, int32 } from '../data-types.js';\nimport { readBoolean, readInt16, readInt64, readObject, readOffset, readString, readUint8, readVector } from '../util/read.js';\nimport { decodeDataType } from './data-type.js';\nimport { decodeMetadata } from './metadata.js';\n\n/**\n * Decode a table schema describing the fields and their data types.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @param {Version_} version Arrow version value\n * @returns {Schema} The schema\n */\nexport function decodeSchema(buf, index, version) {\n  //  4: endianness (int16)\n  //  6: fields (vector)\n  //  8: metadata (vector)\n  // 10: features (int64[])\n  const get = readObject(buf, index);\n  return {\n    version,\n    endianness: /** @type {Endianness_} */ (get(4, readInt16, 0)),\n    fields: get(6, decodeSchemaFields, []),\n    metadata: get(8, decodeMetadata)\n  };\n}\n\n/**\n * @returns {Field[] | null}\n */\nfunction decodeSchemaFields(buf, fieldsOffset) {\n  return readVector(buf, fieldsOffset, 4, decodeField);\n}\n\n/**\n * @returns {Field}\n */\nfunction decodeField(buf, index) {\n  //  4: name (string)\n  //  6: nullable (bool)\n  //  8: type id (uint8)\n  // 10: type (union)\n  // 12: dictionary (table)\n  // 14: children (vector)\n  // 16: metadata (vector)\n  const get = readObject(buf, index);\n  const typeId = get(8, readUint8, Type.NONE);\n  const typeOffset = get(10, readOffset, 0);\n  const dict = get(12, decodeDictionary);\n  const children = get(14, (buf, off) => decodeFieldChildren(buf, off));\n\n  let type = decodeDataType(buf, typeOffset, typeId, children);\n  if (dict) {\n    dict.dictionary = type;\n    type = dict;\n  }\n\n  return {\n    name: get(4, readString),\n    type,\n    nullable: get(6, readBoolean, false),\n    metadata: get(16, decodeMetadata)\n  };\n}\n\n/**\n * @returns {Field[] | null}\n */\nfunction decodeFieldChildren(buf, fieldOffset) {\n  const children = readVector(buf, fieldOffset, 4, decodeField);\n  return children.length ? children : null;\n}\n\n/**\n * @param {Uint8Array} buf\n * @param {number} index\n * @returns {DictionaryType}\n */\nfunction decodeDictionary(buf, index) {\n  if (!index) return null;\n  //  4: id (int64)\n  //  6: indexType (Int type)\n  //  8: isOrdered (boolean)\n  // 10: kind (int16) currently only dense array is supported\n  const get = readObject(buf, index);\n  return dictionary(\n    null, // data type will be populated by caller\n    get(6, decodeInt, int32()), // index type\n    get(8, readBoolean, false), // ordered\n    get(4, readInt64, 0), // id\n  );\n}\n\n/**\n * Decode an integer data type.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data.\n * @param {number} index The starting index in the byte buffer.\n * @returns {IntType}\n */\nfunction decodeInt(buf, index) {\n  return /** @type {IntType} */ (\n    decodeDataType(buf, index, Type.Int)\n  );\n}\n","/**\n * @import { Message, MessageHeader_, Version_ } from '../types.js'\n */\nimport { MessageHeader, Version } from '../constants.js';\nimport { keyFor } from '../util/objects.js';\nimport { SIZEOF_INT, readInt16, readInt32, readInt64, readObject, readOffset, readUint8 } from '../util/read.js';\nimport { decodeDictionaryBatch } from './dictionary-batch.js';\nimport { decodeRecordBatch } from './record-batch.js';\nimport { decodeSchema } from './schema.js';\n\nconst invalidMessageMetadata = (expected, actual) =>\n  `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\n\nconst invalidMessageBodyLength = (expected, actual) =>\n  `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\n\nconst invalidMessageType = (type) =>\n  `Unsupported message type: ${type} (${keyFor(MessageHeader, type)})`;\n\n/**\n * A \"message\" contains a block of Apache Arrow data, such as a schema,\n * record batch, or dictionary batch. This message decodes a single\n * message, returning its associated metadata and content.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns {Message} The decoded message.\n */\nexport function decodeMessage(buf, index) {\n  // get message start\n  let metadataLength = readInt32(buf, index) || 0;\n  index += SIZEOF_INT;\n\n  // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n  // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n  // pre-v0.15 message, where the first 4 bytes are the metadata length.\n  if (metadataLength === -1) {\n    metadataLength = readInt32(buf, index) || 0;\n    index += SIZEOF_INT;\n  }\n  if (metadataLength === 0) return null;\n\n  const head = buf.subarray(index, index += metadataLength);\n  if (head.byteLength < metadataLength) {\n    throw new Error(invalidMessageMetadata(metadataLength, head.byteLength));\n  }\n\n  // decode message metadata\n  //  4: version\n  //  6: headerType\n  //  8: headerIndex\n  // 10: bodyLength\n  const get = readObject(head, 0);\n  const version = /** @type {Version_} */\n    (get(4, readInt16, Version.V1));\n  const type = /** @type {MessageHeader_} */\n    (get(6, readUint8, MessageHeader.NONE));\n  const offset = get(8, readOffset, 0);\n  const bodyLength = get(10, readInt64, 0);\n  let content;\n\n  if (offset) {\n    // decode message header\n    const decoder = type === MessageHeader.Schema ? decodeSchema\n      : type === MessageHeader.DictionaryBatch ? decodeDictionaryBatch\n      : type === MessageHeader.RecordBatch ? decodeRecordBatch\n      : null;\n    if (!decoder) throw new Error(invalidMessageType(type));\n    content = decoder(head, offset, version);\n\n    // extract message body\n    if (bodyLength > 0) {\n      const body = buf.subarray(index, index += bodyLength);\n      if (body.byteLength < bodyLength) {\n        throw new Error(invalidMessageBodyLength(bodyLength, body.byteLength));\n      }\n      // @ts-ignore\n      content.body = body;\n    } else if (type !== MessageHeader.Schema) {\n      // table-from-ipc.js buffer accessor requires body to exist, even for empty batches\n      // @ts-ignore\n      content.body = new Uint8Array(0);\n    }\n  }\n\n  return { version, type, index, content };\n}\n","/**\n * @import { ArrowData, Version_ } from '../types.js'\n */\nimport { MAGIC, MessageHeader, Version } from '../constants.js';\nimport { isArrayBufferLike } from '../util/arrays.js';\nimport { readInt16, readInt32, readObject } from '../util/read.js';\nimport { decodeBlocks } from './block.js';\nimport { decodeMessage } from './message.js';\nimport { decodeMetadata } from './metadata.js';\nimport { decodeSchema } from './schema.js';\n\n/**\n * Decode [Apache Arrow IPC data][1] and return parsed schema, record batch,\n * and dictionary batch definitions. The input binary data may be either\n * an `ArrayBuffer` or `Uint8Array`. For Arrow data in the IPC 'stream' format,\n * an array of `Uint8Array` instances is also supported.\n *\n * This method stops short of generating views over field buffers. Use the\n * `createData()` method on the result to enable column data access.\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#serialization-and-interprocess-communication-ipc\n * @param {ArrayBufferLike | Uint8Array | Uint8Array[]} data\n *  The source byte buffer, or an array of buffers. If an array, each byte\n *  array may contain one or more self-contained messages. Messages may NOT\n *  span multiple byte arrays.\n * @returns {import('../types.js').ArrowData}\n */\nexport function decodeIPC(data) {\n  const source = isArrayBufferLike(data) ? new Uint8Array(data) : data;\n  return source instanceof Uint8Array && isArrowFileFormat(source)\n    ? decodeIPCFile(source)\n    : decodeIPCStream(source);\n}\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isArrowFileFormat(buf) {\n  if (!buf || buf.length < 4) return false;\n  for (let i = 0; i < 6; ++i) {\n    if (MAGIC[i] !== buf[i]) return false;\n  }\n  return true;\n}\n\n/**\n * Decode data in the [Arrow IPC 'stream' format][1].\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format\n * @param {Uint8Array | Uint8Array[]} data The source byte buffer, or an\n *  array of buffers. If an array, each byte array may contain one or more\n *  self-contained messages. Messages may NOT span multiple byte arrays.\n * @returns {ArrowData}\n */\nexport function decodeIPCStream(data) {\n  const stream = [data].flat();\n\n  let schema;\n  const records = [];\n  const dictionaries = [];\n\n  // consume each message in the stream\n  for (const buf of stream) {\n    if (!(buf instanceof Uint8Array)) {\n      throw new Error(`IPC data batch was not a Uint8Array.`);\n    }\n    let offset = 0;\n\n    // decode all messages in current buffer\n    while (true) {\n      const m = decodeMessage(buf, offset);\n      if (m === null) break; // end of messages\n      offset = m.index;\n      if (!m.content) continue;\n      switch (m.type) {\n        case MessageHeader.Schema:\n          // ignore repeated schema messages\n          if (!schema) schema = m.content;\n          break;\n        case MessageHeader.RecordBatch:\n          records.push(m.content);\n          break;\n        case MessageHeader.DictionaryBatch:\n          dictionaries.push(m.content);\n          break;\n      }\n    }\n  }\n\n  return /** @type {ArrowData} */ (\n    { schema, dictionaries, records, metadata: null }\n  );\n}\n\n/**\n * Decode data in the [Arrow IPC 'file' format][1].\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#ipc-file-format\n * @param {Uint8Array} data The source byte buffer.\n * @returns {ArrowData}\n */\nexport function decodeIPCFile(data) {\n  // find footer location\n  const offset = data.byteLength - (MAGIC.length + 4);\n  const length = readInt32(data, offset);\n\n  // decode file footer\n  //  4: version\n  //  6: schema\n  //  8: dictionaries (vector)\n  // 10: batches (vector)\n  // 12: metadata\n  const get = readObject(data, offset - length);\n  const version = /** @type {Version_} */\n    (get(4, readInt16, Version.V1));\n  const dicts = get(8, decodeBlocks, []);\n  const recs = get(10, decodeBlocks, []);\n\n  return /** @type {ArrowData} */ ({\n    schema: get(6, (buf, index) => decodeSchema(buf, index, version)),\n    dictionaries: dicts.map(({ offset }) => decodeMessage(data, offset).content),\n    records: recs.map(({ offset }) => decodeMessage(data, offset).content),\n    metadata: get(12, decodeMetadata)\n  });\n}\n","/**\n * @import { ArrowData, ExtractionOptions, Field, RecordBatch, Schema } from '../types.js'\n */\nimport { batchType } from '../batch-type.js';\nimport { columnBuilder } from '../column.js';\nimport { Type, UnionMode, Version } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { Table } from '../table.js';\nimport { int8Array } from '../util/arrays.js';\nimport { decodeIPC } from './decode-ipc.js';\n\n/**\n * Decode [Apache Arrow IPC data][1] and return a new Table. The input binary\n * data may be either an `ArrayBuffer` or `Uint8Array`. For Arrow data in the\n * [IPC 'stream' format][2], an array of `Uint8Array` values is also supported.\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#serialization-and-interprocess-communication-ipc\n * [2]: https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format\n * @param {ArrayBufferLike | Uint8Array | Uint8Array[]} data\n *  The source byte buffer, or an array of buffers. If an array, each byte\n *  array may contain one or more self-contained messages. Messages may NOT\n *  span multiple byte arrays.\n * @param {ExtractionOptions} [options]\n *  Options for controlling how values are transformed when extracted\n *  from an Arrow binary representation.\n * @returns {Table} A Table instance.\n */\nexport function tableFromIPC(data, options) {\n  return createTable(decodeIPC(data), options);\n}\n\n/**\n * Create a table from parsed IPC data.\n * @param {ArrowData} data\n *  The IPC data, as returned by parseIPC.\n * @param {ExtractionOptions} [options]\n *  Options for controlling how values are transformed when extracted\n *  from am Arrow binary representation.\n * @returns {Table} A Table instance.\n */\nexport function createTable(data, options = {}) {\n  const { schema = { fields: [] }, dictionaries, records } = data;\n  const { version, fields } = schema;\n  const dictionaryMap = new Map;\n  const context = contextGenerator(options, version, dictionaryMap);\n\n  // build dictionary type map\n  const dictionaryTypes = new Map;\n  visitSchemaFields(schema, field => {\n    const type = field.type;\n    if (type.typeId === Type.Dictionary) {\n      dictionaryTypes.set(type.id, type.dictionary);\n    }\n  });\n\n  // decode dictionaries, build dictionary column map\n  const dicts = new Map;\n  for (const dict of dictionaries) {\n    const { id, data, isDelta, body } = dict;\n    const type = dictionaryTypes.get(id);\n    const batch = visit(type, context({ ...data, body }));\n    if (!dicts.has(id)) {\n      if (isDelta) {\n        throw new Error('Delta update can not be first dictionary batch.');\n      }\n      dicts.set(id, columnBuilder(type).add(batch));\n    } else {\n      const dict = dicts.get(id);\n      if (!isDelta) dict.clear();\n      dict.add(batch);\n    }\n  }\n  dicts.forEach((value, key) => dictionaryMap.set(key, value.done()));\n\n  // decode column fields\n  const cols = fields.map(f => columnBuilder(f.type));\n  for (const batch of records) {\n    const ctx = context(batch);\n    fields.forEach((f, i) => cols[i].add(visit(f.type, ctx)));\n  }\n\n  return new Table(schema, cols.map(c => c.done()), options.useProxy);\n}\n\n/**\n * Visit all fields within a schema.\n * @param {Schema} schema\n * @param {(field: Field) => void} visitor\n */\nfunction visitSchemaFields(schema, visitor) {\n  schema.fields.forEach(function visitField(field) {\n    visitor(field);\n    // @ts-ignore\n    field.type.dictionary?.children?.forEach(visitField);\n    // @ts-ignore\n    field.type.children?.forEach(visitField);\n  });\n}\n\n/**\n * Context object generator for field visitation and buffer definition.\n */\nfunction contextGenerator(options, version, dictionaryMap) {\n  const base = {\n    version,\n    options,\n    dictionary: id => dictionaryMap.get(id),\n  };\n\n  /**\n   * Return a context generator.\n   * @param {RecordBatch} batch\n   */\n  return batch => {\n    const { length, nodes, regions, variadic, body } = batch;\n    let nodeIndex = -1;\n    let bufferIndex = -1;\n    let variadicIndex = -1;\n    return {\n      ...base,\n      length,\n      node: () => nodes[++nodeIndex],\n      buffer: (ArrayType) => {\n        const { length, offset } = regions[++bufferIndex];\n        return ArrayType\n          ? new ArrayType(body.buffer, body.byteOffset + offset, length / ArrayType.BYTES_PER_ELEMENT)\n          : body.subarray(offset, offset + length)\n      },\n      variadic: () => variadic[++variadicIndex],\n      visit(children) { return children.map(f => visit(f.type, this)); }\n    };\n  };\n}\n\n/**\n * Visit a field, instantiating views of buffer regions.\n */\nfunction visit(type, ctx) {\n  const { typeId } = type;\n  const { options, node, buffer, variadic, version } = ctx;\n  const BatchType = batchType(type, options);\n\n  // extract the next { length, nullCount } field node - ALL fields have field nodes\n  const base = { ...node(), type };\n\n  if (typeId === Type.Null) {\n    // null fields have field nodes but no data buffers\n    return new BatchType({ ...base, nullCount: base.length });\n  }\n\n  switch (typeId) {\n    // validity and data value buffers\n    case Type.Bool:\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n    case Type.Float:\n    case Type.Decimal:\n    case Type.Date:\n    case Type.Timestamp:\n    case Type.Interval:\n    case Type.FixedSizeBinary:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        values: buffer(type.values)\n      });\n\n    // validity, offset, and value buffers\n    case Type.Utf8:\n    case Type.LargeUtf8:\n    case Type.Binary:\n    case Type.LargeBinary:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        offsets: buffer(type.offsets),\n        values: buffer()\n      });\n\n    // views with variadic buffers\n    case Type.BinaryView:\n    case Type.Utf8View:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        values: buffer(), // views buffer\n        data: Array.from({ length: variadic() }, () => buffer()) // data buffers\n      });\n\n    // validity, offset, and list child\n    case Type.List:\n    case Type.LargeList:\n    case Type.Map:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        offsets: buffer(type.offsets),\n        children: ctx.visit(type.children)\n      });\n\n    // validity, offset, size, and list child\n    case Type.ListView:\n    case Type.LargeListView:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        offsets: buffer(type.offsets),\n        sizes: buffer(type.offsets),\n        children: ctx.visit(type.children)\n      });\n\n    // validity and children\n    case Type.FixedSizeList:\n    case Type.Struct:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        children: ctx.visit(type.children)\n      });\n\n    // children only\n    case Type.RunEndEncoded:\n      return new BatchType({\n        ...base,\n        children: ctx.visit(type.children)\n      });\n\n    // dictionary\n    case Type.Dictionary: {\n      const { id, indices } = type;\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        values: buffer(indices.values),\n      }).setDictionary(ctx.dictionary(id));\n    }\n\n    // union\n    case Type.Union: {\n      if (version < Version.V5) {\n        buffer(); // skip unused null bitmap\n      }\n      return new BatchType({\n        ...base,\n        typeIds: buffer(int8Array),\n        offsets: type.mode === UnionMode.Sparse ? null : buffer(type.offsets),\n        children: ctx.visit(type.children)\n      });\n    }\n\n    // unsupported type\n    default:\n      throw new Error(invalidDataType(typeId));\n  }\n}\n","/**\n * @import { Sink } from './sink.js';\n */\nimport { grow } from '../util/arrays.js';\nimport { SIZEOF_INT, SIZEOF_SHORT, readInt16 } from '../util/read.js';\nimport { encodeUtf8 } from '../util/strings.js';\n\nexport function writeInt32(buf, index, value) {\n  buf[index] = value;\n  buf[index + 1] = value >> 8;\n  buf[index + 2] = value >> 16;\n  buf[index + 3] = value >> 24;\n}\n\nconst INIT_SIZE = 1024;\n\n/** Flatbuffer binary builder. */\nexport class Builder {\n  /**\n   * Create a new builder instance.\n   * @param {Sink} sink The byte consumer.\n   */\n  constructor(sink) {\n    /**\n     * Sink that consumes built byte buffers;\n     * @type {Sink}\n     */\n    this.sink = sink;\n    /**\n     * Minimum alignment encountered so far.\n     * @type {number}\n     */\n    this.minalign = 1;\n    /**\n     * Current byte buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = new Uint8Array(INIT_SIZE);\n    /**\n     * Remaining space in the current buffer.\n     * @type {number}\n     */\n    this.space = INIT_SIZE;\n    /**\n     * List of offsets of all vtables. Used to find and\n     * reuse tables upon duplicated table field schemas.\n     * @type {number[]}\n     */\n    this.vtables = [];\n    /**\n     * Total bytes written to sink thus far.\n     */\n    this.outputBytes = 0;\n  }\n\n  /**\n   * Returns the flatbuffer offset, relative to the end of the current buffer.\n   * @returns {number} Offset relative to the end of the buffer.\n   */\n  offset() {\n    return this.buf.length - this.space;\n  }\n\n  /**\n   * Write a flatbuffer int8 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt8(value) {\n    this.buf[this.space -= 1] = value;\n  }\n\n  /**\n   * Write a flatbuffer int16 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt16(value) {\n    this.buf[this.space -= 2] = value;\n    this.buf[this.space + 1] = value >> 8;\n  }\n\n  /**\n   * Write a flatbuffer int32 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt32(value) {\n    writeInt32(this.buf, this.space -= 4, value);\n  }\n\n  /**\n   * Write a flatbuffer int64 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt64(value) {\n    const v = BigInt(value);\n    this.writeInt32(Number(BigInt.asIntN(32, v >> BigInt(32))));\n    this.writeInt32(Number(BigInt.asIntN(32, v)));\n  }\n\n  /**\n   * Add a flatbuffer int8 value, properly aligned,\n   * @param value The int8 value to add the buffer.\n   */\n  addInt8(value) {\n    prep(this, 1, 0);\n    this.writeInt8(value);\n  }\n\n  /**\n   * Add a flatbuffer int16 value, properly aligned,\n   * @param value The int16 value to add the buffer.\n   */\n  addInt16(value) {\n    prep(this, 2, 0);\n    this.writeInt16(value);\n  }\n\n  /**\n   * Add a flatbuffer int32 value, properly aligned,\n   * @param value The int32 value to add the buffer.\n   */\n  addInt32(value) {\n    prep(this, 4, 0);\n    this.writeInt32(value);\n  }\n\n  /**\n   * Add a flatbuffer int64 values, properly aligned.\n   * @param value The int64 value to add the buffer.\n   */\n  addInt64(value) {\n    prep(this, 8, 0);\n    this.writeInt64(value);\n  }\n\n  /**\n   * Add a flatbuffer offset, relative to where it will be written.\n   * @param {number} offset The offset to add.\n   */\n  addOffset(offset) {\n    prep(this, SIZEOF_INT, 0); // Ensure alignment is already done.\n    this.writeInt32(this.offset() - offset + SIZEOF_INT);\n  }\n\n  /**\n   * Add a flatbuffer object (vtable).\n   * @param {number} numFields The maximum number of fields\n   *  this object may include.\n   * @param {(tableBuilder: ReturnType<objectBuilder>) => void} [addFields]\n   *  A callback function that writes all fields using an object builder.\n   * @returns {number} The object offset.\n   */\n  addObject(numFields, addFields) {\n    const b = objectBuilder(this, numFields);\n    addFields?.(b);\n    return b.finish();\n  }\n\n  /**\n   * Add a flatbuffer vector (list).\n   * @template T\n   * @param {T[]} items An array of items to write.\n   * @param {number} itemSize The size in bytes of a serialized item.\n   * @param {number} alignment The desired byte alignment value.\n   * @param {(builder: this, item: T) => void} writeItem A callback\n   *  function that writes a vector item to this builder.\n   * @returns {number} The vector offset.\n   */\n  addVector(items, itemSize, alignment, writeItem) {\n    const n = items?.length;\n    if (!n) return 0;\n    prep(this, SIZEOF_INT, itemSize * n);\n    prep(this, alignment, itemSize * n); // Just in case alignment > int.\n    for (let i = n; --i >= 0;) {\n      writeItem(this, items[i]);\n    }\n    this.writeInt32(n);\n    return this.offset();\n  }\n\n  /**\n   * Convenience method for writing a vector of byte buffer offsets.\n   * @param {number[]} offsets\n   * @returns {number} The vector offset.\n   */\n  addOffsetVector(offsets) {\n    return this.addVector(offsets, 4, 4, (b, off) => b.addOffset(off));\n  }\n\n  /**\n   * Add a flatbuffer UTF-8 string.\n   * @param {string} s The string to encode.\n   * @return {number} The string offset.\n   */\n  addString(s) {\n    if (s == null) return 0;\n    const utf8 = encodeUtf8(s);\n    const n = utf8.length;\n    this.addInt8(0); // string null terminator\n    prep(this, SIZEOF_INT, n);\n    this.buf.set(utf8, this.space -= n);\n    this.writeInt32(n);\n    return this.offset();\n  }\n\n  /**\n   * Finish the current flatbuffer by adding a root offset.\n   * @param {number} rootOffset The root offset.\n   */\n  finish(rootOffset) {\n    prep(this, this.minalign, SIZEOF_INT);\n    this.addOffset(rootOffset);\n  }\n\n  /**\n   * Flush the current flatbuffer byte buffer content to the sink,\n   * and reset the flatbuffer builder state.\n   */\n  flush() {\n    const { buf, sink } = this;\n    const bytes = buf.subarray(this.space, buf.length);\n    sink.write(bytes);\n    this.outputBytes += bytes.byteLength;\n    this.minalign = 1;\n    this.vtables = [];\n    this.buf = new Uint8Array(INIT_SIZE);\n    this.space = INIT_SIZE;\n  }\n\n  /**\n   * Add a byte buffer directly to the builder sink. This method bypasses\n   * any unflushed flatbuffer state and leaves it unchanged, writing the\n   * buffer to the sink *before* the flatbuffer.\n   * The buffer will be padded for 64-bit (8-byte) alignment as needed.\n   * @param {Uint8Array} buffer The buffer to add.\n   * @returns {number} The total byte count of the buffer and padding.\n   */\n  addBuffer(buffer) {\n    const size = buffer.byteLength;\n    if (!size) return 0;\n    this.sink.write(buffer);\n    this.outputBytes += size;\n    const pad = ((size + 7) & ~7) - size;\n    this.addPadding(pad);\n    return size + pad;\n  }\n\n  /**\n   * Write padding bytes directly to the builder sink. This method bypasses\n   * any unflushed flatbuffer state and leaves it unchanged, writing the\n   * padding bytes to the sink *before* the flatbuffer.\n   * @param {number} byteCount The number of padding bytes.\n   */\n  addPadding(byteCount) {\n    if (byteCount > 0) {\n      this.sink.write(new Uint8Array(byteCount));\n      this.outputBytes += byteCount;\n    }\n  }\n}\n\n/**\n * Prepare to write an element of `size` after `additionalBytes` have been\n * written, e.g. if we write a string, we need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * we need to do is alignment, `additionalBytes` will be 0.\n * @param {Builder} builder The builder to prep.\n * @param {number} size The size of the new element to write.\n * @param {number} additionalBytes Additional padding size.\n */\nexport function prep(builder, size, additionalBytes) {\n  let { buf, space, minalign } = builder;\n\n  // track the biggest thing we've ever aligned to\n  if (size > minalign) {\n    builder.minalign = size;\n  }\n\n  // find alignment needed so that `size` aligns after `additionalBytes`\n  const bufSize = buf.length;\n  const used = bufSize - space + additionalBytes;\n  const alignSize = (~used + 1) & (size - 1);\n\n  // reallocate the buffer if needed\n  buf = grow(buf, used + alignSize + size - 1, true);\n  space += buf.length - bufSize;\n\n  // add padding\n  for (let i = 0; i < alignSize; ++i) {\n    buf[--space] = 0;\n  }\n\n  // update builder state\n  builder.buf = buf;\n  builder.space = space;\n}\n\n/**\n * Returns a builder object for flatbuffer objects (vtables).\n * @param {Builder} builder The underlying flatbuffer builder.\n * @param {number} numFields The expected number of fields, not\n *  including the standard size fields.\n */\nfunction objectBuilder(builder, numFields) {\n  /** @type {number[]} */\n  const vtable = Array(numFields).fill(0);\n  const startOffset = builder.offset();\n\n  function slot(index) {\n    vtable[index] = builder.offset();\n  }\n\n  return {\n    /**\n     * Add an int8-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt8(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt8(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add an int16-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt16(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt16(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add an int32-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt32(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt32(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add an int64-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt64(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt64(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add a buffer offset-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addOffset(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addOffset(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Write the vtable to the buffer and return the table offset.\n     * @returns {number} The buffer offset to the vtable.\n     */\n    finish() {\n      // add offset entry, will overwrite later with actual offset\n      builder.addInt32(0);\n      const vtableOffset = builder.offset();\n\n      // trim zero-valued fields (indicating default value)\n      let i = numFields;\n      while (--i >= 0 && vtable[i] === 0) {} // eslint-disable-line no-empty\n      const size = i + 1;\n\n      // Write out the current vtable.\n      for (; i >= 0; --i) {\n        // Offset relative to the start of the table.\n        builder.addInt16(vtable[i] ? (vtableOffset - vtable[i]) : 0);\n      }\n\n      const standardFields = 2; // size fields\n      builder.addInt16(vtableOffset - startOffset);\n      const len = (size + standardFields) * SIZEOF_SHORT;\n      builder.addInt16(len);\n\n      // Search for an existing vtable that matches the current one.\n      let existingTable = 0;\n      const { buf, vtables, space: vt1 } = builder;\n    outer_loop:\n      for (i = 0; i < vtables.length; ++i) {\n        const vt2 = buf.length - vtables[i];\n        if (len == readInt16(buf, vt2)) {\n          for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n            if (readInt16(buf, vt1 + j) != readInt16(buf, vt2 + j)) {\n              continue outer_loop;\n            }\n          }\n          existingTable = vtables[i];\n          break;\n        }\n      }\n\n      if (existingTable) {\n        // Found a match: remove the current vtable.\n        // Point table to existing vtable.\n        builder.space = buf.length - vtableOffset;\n        writeInt32(buf, builder.space, existingTable - vtableOffset);\n      } else {\n        // No match: add the location of the current vtable to the vtables list.\n        // Point table to current vtable.\n        const off = builder.offset();\n        vtables.push(off);\n        writeInt32(buf, buf.length - vtableOffset, off - vtableOffset);\n      }\n\n      return vtableOffset;\n    }\n  }\n}\n","/**\n * @import { RecordBatch } from '../types.js';\n * @import { Builder } from './builder.js';\n */\n\n/**\n * @param {Builder} builder\n * @param {RecordBatch} batch\n * @returns {number}\n */\nexport function encodeRecordBatch(builder, batch) {\n  const { nodes, regions, variadic } = batch;\n  const nodeVector = builder.addVector(nodes, 16, 8,\n    (builder, node) => {\n      builder.writeInt64(node.nullCount);\n      builder.writeInt64(node.length);\n      return builder.offset();\n    }\n  );\n  const regionVector = builder.addVector(regions, 16, 8,\n    (builder, region) => {\n      builder.writeInt64(region.length);\n      builder.writeInt64(region.offset);\n      return builder.offset();\n    }\n  );\n  const variadicVector = builder.addVector(variadic, 8, 8,\n    (builder, count) => builder.addInt64(count)\n  );\n  return builder.addObject(5, b => {\n    b.addInt64(0, nodes[0].length, 0);\n    b.addOffset(1, nodeVector, 0);\n    b.addOffset(2, regionVector, 0);\n    // NOT SUPPORTED: 3, compression offset\n    b.addOffset(4, variadicVector, 0);\n  });\n}\n","/**\n * @import { DictionaryBatch } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { encodeRecordBatch } from './record-batch.js';\n\n/**\n * @param {Builder} builder\n * @param {DictionaryBatch} dictionaryBatch\n * @returns {number}\n */\nexport function encodeDictionaryBatch(builder, dictionaryBatch) {\n  const dataOffset = encodeRecordBatch(builder, dictionaryBatch.data);\n  return builder.addObject(3, b => {\n    b.addInt64(0, dictionaryBatch.id, 0);\n    b.addOffset(1, dataOffset, 0);\n    b.addInt8(2, +dictionaryBatch.isDelta, 0);\n  });\n}\n","/**\n * @import { Builder } from './builder.js';\n */\n\n/**\n * @param {Builder} builder\n * @param {Map<string, string>} metadata\n * @returns {number}\n */\nexport function encodeMetadata(builder, metadata) {\n  return metadata?.size > 0\n     ? builder.addOffsetVector(Array.from(metadata, ([k, v]) => {\n        const key = builder.addString(`${k}`);\n        const val = builder.addString(`${v}`);\n        return builder.addObject(2, b => {\n          b.addOffset(0, key, 0);\n          b.addOffset(1, val, 0);\n        });\n      }))\n    : 0;\n}\n","/**\n * @import { DataType } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { DateUnit, IntervalUnit, Precision, TimeUnit, Type, UnionMode } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { checkOneOf } from '../util/objects.js';\n\n/**\n * Encode a data type into a flatbuffer.\n * @param {Builder} builder\n * @param {DataType} type\n * @returns {number} The offset at which the data type is written.\n */\nexport function encodeDataType(builder, type) {\n  const typeId = checkOneOf(type.typeId, Type, invalidDataType);\n\n  switch (typeId) {\n    case Type.Dictionary:\n      return encodeDictionary(builder, type);\n    case Type.Int:\n      return encodeInt(builder, type);\n    case Type.Float:\n      return encodeFloat(builder, type);\n    case Type.Decimal:\n      return encodeDecimal(builder, type);\n    case Type.Date:\n      return encodeDate(builder, type);\n    case Type.Time:\n      return encodeTime(builder, type);\n    case Type.Timestamp:\n      return encodeTimestamp(builder, type);\n    case Type.Interval:\n      return encodeInterval(builder, type);\n    case Type.Duration:\n      return encodeDuration(builder, type);\n    case Type.FixedSizeBinary:\n    case Type.FixedSizeList:\n      return encodeFixedSize(builder, type);\n    case Type.Map:\n      return encodeMap(builder, type);\n    case Type.Union:\n      return encodeUnion(builder, type);\n  }\n  // case Type.Null:\n  // case Type.Binary:\n  // case Type.LargeBinary:\n  // case Type.BinaryView:\n  // case Type.Bool:\n  // case Type.Utf8:\n  // case Type.Utf8View:\n  // case Type.LargeUtf8:\n  // case Type.List:\n  // case Type.ListView:\n  // case Type.LargeList:\n  // case Type.LargeListView:\n  // case Type.RunEndEncoded:\n  // case Type.Struct:\n  return builder.addObject(0);\n}\n\nfunction encodeDate(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.unit, DateUnit.MILLISECOND);\n  });\n}\n\nfunction encodeDecimal(builder, type) {\n  return builder.addObject(3, b => {\n    b.addInt32(0, type.precision, 0);\n    b.addInt32(1, type.scale, 0);\n    b.addInt32(2, type.bitWidth, 128);\n  });\n}\n\nfunction encodeDuration(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.unit, TimeUnit.MILLISECOND);\n  });\n}\n\nfunction encodeFixedSize(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt32(0, type.stride, 0);\n  });\n}\n\nfunction encodeFloat(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.precision, Precision.HALF);\n  });\n}\n\nfunction encodeInt(builder, type) {\n  return builder.addObject(2, b => {\n    b.addInt32(0, type.bitWidth, 0);\n    b.addInt8(1, +type.signed, 0);\n  });\n}\n\nfunction encodeInterval(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.unit, IntervalUnit.YEAR_MONTH);\n  });\n}\n\nfunction encodeMap(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt8(0, +type.keysSorted, 0);\n  });\n}\n\nfunction encodeTime(builder, type) {\n  return builder.addObject(2, b => {\n    b.addInt16(0, type.unit, TimeUnit.MILLISECOND);\n    b.addInt32(1, type.bitWidth, 32);\n  });\n}\n\nfunction encodeTimestamp(builder, type) {\n  const timezoneOffset = builder.addString(type.timezone);\n  return builder.addObject(2, b => {\n    b.addInt16(0, type.unit, TimeUnit.SECOND);\n    b.addOffset(1, timezoneOffset, 0);\n  });\n}\n\nfunction encodeUnion(builder, type) {\n  const typeIdsOffset = builder.addVector(\n    type.typeIds, 4, 4,\n    (builder, value) => builder.addInt32(value)\n  );\n  return builder.addObject(2, b => {\n    b.addInt16(0, type.mode, UnionMode.Sparse);\n    b.addOffset(1, typeIdsOffset, 0);\n  });\n}\n\nfunction encodeDictionary(builder, type) {\n  // The Arrow spec uses signed 32-bit integers as the default index type.\n  // However, multiple 3rd party tools fail on a null (default) index type,\n  // so we always encode the index data type explicitly here.\n  return builder.addObject(4, b => {\n    b.addInt64(0, type.id, 0);\n    b.addOffset(1, encodeDataType(builder, type.indices), 0);\n    b.addInt8(2, +type.ordered, 0);\n    // NOT SUPPORTED: 3, dictionaryKind (defaults to dense array)\n  });\n}\n","/**\n * @import { DictionaryType, Field, Schema } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { Type } from '../constants.js';\nimport { encodeDataType } from './data-type.js';\nimport { encodeMetadata } from './metadata.js';\n\nconst isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n/**\n * @param {Builder} builder\n * @param {Schema} schema\n * @returns {number}\n */\nexport function encodeSchema(builder, schema) {\n  const { fields, metadata } = schema;\n  const fieldOffsets = fields.map(f => encodeField(builder, f));\n  const fieldsVectorOffset = builder.addOffsetVector(fieldOffsets);\n  const metadataOffset = encodeMetadata(builder, metadata);\n  return builder.addObject(4, b => {\n    b.addInt16(0, +(!isLittleEndian), 0);\n    b.addOffset(1, fieldsVectorOffset, 0);\n    b.addOffset(2, metadataOffset, 0);\n    // NOT SUPPORTED: 3, features\n  });\n}\n\n/**\n * @param {Builder} builder\n * @param {Field} field\n * @returns {number}\n */\nfunction encodeField(builder, field) {\n  const { name, nullable, type, metadata } = field;\n  let { typeId } = type;\n\n  // encode field data type\n  let typeOffset = 0;\n  let dictionaryOffset = 0;\n  if (typeId !== Type.Dictionary) {\n    typeOffset = encodeDataType(builder, type);\n  } else {\n    const dict = /** @type {DictionaryType} */ (type).dictionary;\n    typeId = dict.typeId;\n    dictionaryOffset = encodeDataType(builder, type);\n    typeOffset = encodeDataType(builder, dict);\n  }\n\n  // encode children, metadata, name, and field object\n  // @ts-ignore\n  const childOffsets = (type.children || []).map(f => encodeField(builder, f));\n  const childrenVectorOffset = builder.addOffsetVector(childOffsets);\n  const metadataOffset = encodeMetadata(builder, metadata);\n  const nameOffset = builder.addString(name);\n  return builder.addObject(7, b => {\n    b.addOffset(0, nameOffset, 0);\n    b.addInt8(1, +nullable, +false);\n    b.addInt8(2, typeId, Type.NONE);\n    b.addOffset(3, typeOffset, 0);\n    b.addOffset(4, dictionaryOffset, 0);\n    b.addOffset(5, childrenVectorOffset, 0);\n    b.addOffset(6, metadataOffset, 0);\n  });\n}\n","/**\n * @import { Block, Schema } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { MAGIC, Version } from '../constants.js';\nimport { encodeMetadata } from './metadata.js';\nimport { encodeSchema } from './schema.js';\n\n/**\n * Write a file footer.\n * @param {Builder} builder The binary builder.\n * @param {Schema} schema The table schema.\n * @param {Block[]} dictBlocks Dictionary batch file blocks.\n * @param {Block[]} recordBlocks Record batch file blocks.\n * @param {Map<string,string> | null} metadata File-level metadata.\n */\nexport function writeFooter(builder, schema, dictBlocks, recordBlocks, metadata) {\n  // encode footer flatbuffer\n  const metadataOffset = encodeMetadata(builder, metadata);\n  const recsOffset = builder.addVector(recordBlocks, 24, 8, encodeBlock);\n  const dictsOffset = builder.addVector(dictBlocks, 24, 8, encodeBlock);\n  const schemaOffset = encodeSchema(builder, schema);\n  builder.finish(\n    builder.addObject(5, b => {\n      b.addInt16(0, Version.V5, Version.V1);\n      b.addOffset(1, schemaOffset, 0);\n      b.addOffset(2, dictsOffset, 0);\n      b.addOffset(3, recsOffset, 0);\n      b.addOffset(4, metadataOffset, 0);\n    })\n  );\n  const size = builder.offset();\n\n  // add eos with continuation indicator\n  builder.addInt32(0);\n  builder.addInt32(-1);\n\n  // write builder contents\n  builder.flush();\n\n  // write file tail\n  builder.sink.write(new Uint8Array(Int32Array.of(size).buffer));\n  builder.sink.write(MAGIC);\n}\n\n/**\n * Encode a file pointer block.\n * @param {Builder} builder\n * @param {Block} block\n * @returns {number} the current block offset\n */\nfunction encodeBlock(builder, { offset, metadataLength, bodyLength }) {\n  builder.writeInt64(bodyLength);\n  builder.writeInt32(0);\n  builder.writeInt32(metadataLength);\n  builder.writeInt64(offset);\n  return builder.offset();\n}\n","/**\n * @import { Block, MessageHeader_ } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { MessageHeader, Version } from '../constants.js';\n\n/**\n * Write an IPC message to the builder sink.\n * @param {Builder} builder\n * @param {MessageHeader_} headerType\n * @param {number} headerOffset\n * @param {number} bodyLength\n * @param {Block[]} [blocks]\n */\nexport function writeMessage(builder, headerType, headerOffset, bodyLength, blocks) {\n  builder.finish(\n    builder.addObject(5, b => {\n      b.addInt16(0, Version.V5, Version.V1);\n      b.addInt8(1, headerType, MessageHeader.NONE);\n      b.addOffset(2, headerOffset, 0);\n      b.addInt64(3, bodyLength, 0);\n      // NOT SUPPORTED: 4, message-level metadata\n    })\n  );\n\n  const prefixSize = 8; // continuation indicator + message size\n  const messageSize = builder.offset();\n  const alignedSize = (messageSize + prefixSize + 7) & ~7;\n\n  // track blocks for file footer\n  blocks?.push({\n    offset: builder.outputBytes,\n    metadataLength: alignedSize,\n    bodyLength\n  });\n\n  // write size prefix (including padding)\n  builder.addInt32(alignedSize - prefixSize);\n\n  // write the stream continuation indicator\n  builder.addInt32(-1);\n\n  // flush the builder content\n  builder.flush();\n\n  // add alignment padding as needed\n  builder.addPadding(alignedSize - messageSize - prefixSize);\n}\n","export class Sink {\n  /**\n   * Write bytes to this sink.\n   * @param {Uint8Array} bytes The byte buffer to write.\n   */\n  write(bytes) { // eslint-disable-line no-unused-vars\n  }\n\n  /**\n   * Write padding bytes (zeroes) to this sink.\n   * @param {number} byteCount The number of padding bytes.\n   */\n  pad(byteCount) {\n    this.write(new Uint8Array(byteCount));\n  }\n\n  /**\n   * @returns {Uint8Array | null}\n   */\n  finish() {\n    return null;\n  }\n}\n\nexport class MemorySink extends Sink {\n  /**\n   * A sink that collects bytes in memory.\n   */\n  constructor() {\n    super();\n    this.buffers = [];\n  }\n\n  /**\n   * Write bytes\n   * @param {Uint8Array} bytes\n   */\n  write(bytes) {\n    this.buffers.push(bytes);\n  }\n\n  /**\n   * @returns {Uint8Array}\n   */\n  finish() {\n    const bufs = this.buffers;\n    const size = bufs.reduce((sum, b) => sum + b.byteLength, 0);\n    const buf = new Uint8Array(size);\n    for (let i = 0, off = 0; i < bufs.length; ++i) {\n      buf.set(bufs[i], off);\n      off += bufs[i].byteLength;\n    }\n    return buf;\n  }\n}\n","/**\n * @import { Sink } from './sink.js';\n */\nimport { EOS, MAGIC, MessageHeader } from '../constants.js';\nimport { Builder } from './builder.js';\nimport { encodeDictionaryBatch } from './dictionary-batch.js';\nimport { writeFooter } from './footer.js';\nimport { encodeRecordBatch } from './record-batch.js';\nimport { encodeSchema } from './schema.js';\nimport { writeMessage } from './message.js';\nimport { MemorySink } from './sink.js';\n\nconst STREAM = 'stream';\nconst FILE = 'file';\n\n/**\n * Encode assembled data into Arrow IPC binary format.\n * @param {any} data Assembled table data.\n * @param {object} options Encoding options.\n * @param {Sink} [options.sink] IPC byte consumer.\n * @param {'stream' | 'file'} [options.format] Arrow stream or file format.\n * @returns {Sink} The sink that was passed in.\n */\nexport function encodeIPC(data, { sink, format = STREAM } = {}) {\n  if (format !== STREAM && format !== FILE) {\n    throw new Error(`Unrecognized Arrow IPC format: ${format}`);\n  }\n  const { schema, dictionaries = [], records = [], metadata } = data;\n  const builder = new Builder(sink || new MemorySink());\n  const file = format === FILE;\n  const dictBlocks = [];\n  const recordBlocks = [];\n\n  if (file) {\n    builder.addBuffer(MAGIC);\n  }\n\n  // both stream and file start with the schema\n  if (schema) {\n    writeMessage(\n      builder,\n      MessageHeader.Schema,\n      encodeSchema(builder, schema),\n      0\n    );\n  }\n\n  // write dictionary messages\n  for (const dict of dictionaries) {\n    const { data } = dict;\n    writeMessage(\n      builder,\n      MessageHeader.DictionaryBatch,\n      encodeDictionaryBatch(builder, dict),\n      data.byteLength,\n      dictBlocks\n    );\n    writeBuffers(builder, data.buffers);\n  }\n\n  // write record batch messages\n  for (const batch of records) {\n    writeMessage(\n      builder,\n      MessageHeader.RecordBatch,\n      encodeRecordBatch(builder, batch),\n      batch.byteLength,\n      recordBlocks\n    );\n    writeBuffers(builder, batch.buffers);\n  }\n\n  // both stream and file include end-of-stream message\n  builder.addBuffer(EOS);\n\n  if (file) {\n    writeFooter(builder, schema, dictBlocks, recordBlocks, metadata);\n  }\n\n  return builder.sink;\n}\n\n/**\n * Write byte buffers to the builder sink.\n * Buffers are aligned to 64 bits (8 bytes) as needed.\n * @param {Builder} builder\n * @param {Uint8Array[]} buffers\n */\nfunction writeBuffers(builder, buffers) {\n  for (let i = 0; i < buffers.length; ++i) {\n    builder.addBuffer(buffers[i]); // handles alignment for us\n  }\n}\n","/**\n * @import { Batch, DictionaryBatch } from '../batch.js'\n * @import { Column } from '../column.js'\n * @import { Table } from '../table.js'\n * @import { DataType, RecordBatch, Schema, TypedArray } from '../types.js'\n * @import { Sink } from './sink.js';\n */\nimport { Type, UnionMode } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { encodeIPC } from './encode-ipc.js';\n\n/**\n * Encode an Arrow table into Arrow IPC binary format.\n * @param {Table} table The Arrow table to encode.\n * @param {object} options Encoding options.\n * @param {Sink} [options.sink] IPC byte consumer.\n * @param {'stream' | 'file'} [options.format] Arrow stream or file format.\n * @returns {Uint8Array | null} The generated bytes (for an in-memory sink)\n *  or null (if using a sink that writes bytes elsewhere).\n */\nexport function tableToIPC(table, options) {\n  // accept a format string option for Arrow-JS compatibility\n  if (typeof options === 'string') {\n    options = { format: options };\n  }\n\n  const columns = table.children;\n  checkBatchLengths(columns);\n\n  const { dictionaries, idMap } = assembleDictionaryBatches(columns);\n  const records = assembleRecordBatches(columns);\n  const schema = assembleSchema(table.schema, idMap);\n  const data = { schema, dictionaries, records };\n  return encodeIPC(data, options).finish();\n}\n\nfunction checkBatchLengths(columns) {\n  const n = columns[0]?.data.map(d => d.length);\n  columns.forEach(({ data }) => {\n    if (data.length !== n.length || data.some((b, i) => b.length !== n[i])) {\n      throw new Error('Columns have inconsistent batch sizes.');\n    }\n  });\n}\n\n/**\n * Create a new assembly context.\n */\nfunction assembleContext() {\n  let byteLength = 0;\n  const nodes = [];\n  const regions = [];\n  const buffers = [];\n  const variadic = [];\n  return {\n    /**\n     * @param {number} length\n     * @param {number} nullCount\n     */\n    node(length, nullCount) {\n      nodes.push({ length, nullCount });\n    },\n    /**\n     * @param {TypedArray} b\n     */\n    buffer(b) {\n      const size = b.byteLength;\n      const length = ((size + 7) & ~7);\n      regions.push({ offset: byteLength, length });\n      byteLength += length;\n      buffers.push(new Uint8Array(b.buffer, b.byteOffset, size));\n    },\n    /**\n     * @param {number} length\n     */\n    variadic(length) {\n      variadic.push(length);\n    },\n    /**\n     * @param {DataType} type\n     * @param {Batch} batch\n     */\n    children(type, batch) {\n      // @ts-ignore\n      type.children.forEach((field, index) => {\n        visit(field.type, batch.children[index], this);\n      });\n    },\n    /**\n     * @returns {RecordBatch}\n     */\n    done() {\n      return { byteLength, nodes, regions, variadic, buffers };\n    }\n  };\n}\n\n/**\n * Assemble dictionary batches and their unique ids.\n * @param {Column[]} columns The table columns.\n * @returns {{\n *    dictionaries: DictionaryBatch[],\n *    idMap: Map<DataType, number>\n *  }}\n *  The assembled dictionary batches and a map from dictionary column\n *  instances to dictionary ids.\n */\nfunction assembleDictionaryBatches(columns) {\n  const dictionaries = [];\n  const dictMap = new Map;\n  const idMap = new Map;\n  let id = -1;\n\n  // track dictionaries, key by dictionary column, assign ids\n  const visitor = dictionaryColumn => {\n    if (!dictMap.has(dictionaryColumn)) {\n      dictMap.set(dictionaryColumn, ++id);\n      for (let i = 0; i < dictionaryColumn.data.length; ++i) {\n        dictionaries.push({\n          id,\n          isDelta: i > 0,\n          data: assembleRecordBatch([dictionaryColumn], i)\n        });\n      }\n      idMap.set(dictionaryColumn.type, id);\n    } else {\n      idMap.set(dictionaryColumn.type, dictMap.get(dictionaryColumn));\n    }\n  };\n\n  // recurse through column batches to find dictionaries\n  // it is sufficient to visit the first batch only,\n  // as all batches have the same dictionary column\n  columns.forEach(col => visitDictionaries(col.data[0], visitor));\n\n  return { dictionaries, idMap };\n}\n\n/**\n * Traverse column batches to visit dictionary columns.\n * @param {Batch} batch\n * @param {(column: Column) => void} visitor\n */\nfunction visitDictionaries(batch, visitor) {\n  if (batch?.type.typeId === Type.Dictionary) {\n    // @ts-ignore - batch has type DictionaryBatch\n    const dictionary = batch.dictionary;\n    visitor(dictionary);\n    visitDictionaries(dictionary.data[0], visitor);\n  }\n  batch?.children?.forEach(child => visitDictionaries(child, visitor));\n}\n\n/**\n * Assemble a schema with resolved dictionary ids.\n * @param {Schema} schema The schema.\n * @param {Map<DataType, number>} idMap A map\n *  from dictionary value types to dictionary ids.\n * @returns {Schema} A new schema with resolved\n *  dictionary ids. If there are no dictionaries, the input schema is\n *  returned unchanged.\n */\nfunction assembleSchema(schema, idMap) {\n  // early exit if no dictionaries\n  if (!idMap.size) return schema;\n\n  const visit = type => {\n    if (type.typeId === Type.Dictionary) {\n      type.id = idMap.get(type.dictionary); // lookup and set id\n      visitDictType(type);\n    }\n    if (type.children) {\n      (type.children = type.children.slice()).forEach(visitFields);\n    }\n  };\n\n  // visit a field in a field array\n  const visitFields = (field, index, array) => {\n    const type = { ...field.type };\n    array[index] = { ...field, type };\n    visit(type);\n  };\n\n  // visit a dictionary values type\n  const visitDictType = (parentType) => {\n    const type = { ...parentType.dictionary };\n    parentType.dictionary = type;\n    visit(type);\n  };\n\n  schema = { ...schema, fields: schema.fields.slice() };\n  schema.fields.forEach(visitFields);\n  return schema;\n}\n\n/**\n * Assemble record batches with marshalled buffers.\n * @param {Column[]} columns The table columns.\n * @returns {RecordBatch[]} The assembled record batches.\n */\nfunction assembleRecordBatches(columns) {\n  return (columns[0]?.data || [])\n    .map((_, index) => assembleRecordBatch(columns, index));\n}\n\n/**\n * Assemble a record batch with marshalled buffers.\n * @param {Column[]} columns The table columns.\n * @param {number} batchIndex The batch index.\n * @returns {RecordBatch} The assembled record batch.\n */\nfunction assembleRecordBatch(columns, batchIndex = 0) {\n  const ctx = assembleContext();\n  columns.forEach(column => {\n    visit(column.type, column.data[batchIndex], ctx);\n  });\n  return ctx.done();\n}\n\n/**\n * Visit a column batch, assembling buffer data.\n * @param {DataType} type The data type.\n * @param {Batch} batch The column batch.\n * @param {ReturnType<assembleContext>} ctx The assembly context.\n */\nfunction visit(type, batch, ctx) {\n  const { typeId } = type;\n\n  // record field node info - ALL fields need field nodes, including nulls\n  ctx.node(batch.length, batch.nullCount);\n\n  // null fields have field nodes but no data buffers\n  if (typeId === Type.Null) return;\n\n  switch (typeId) {\n    // validity and value buffers\n    // backing dictionaries handled elsewhere\n    case Type.Bool:\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n    case Type.Float:\n    case Type.Date:\n    case Type.Timestamp:\n    case Type.Decimal:\n    case Type.Interval:\n    case Type.FixedSizeBinary:\n    case Type.Dictionary: // dict key values\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.values);\n      return;\n\n    // validity, offset, and value buffers\n    case Type.Utf8:\n    case Type.LargeUtf8:\n    case Type.Binary:\n    case Type.LargeBinary:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.offsets);\n      ctx.buffer(batch.values);\n      return;\n\n    // views with variadic buffers\n    case Type.BinaryView:\n    case Type.Utf8View:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.values);\n      // @ts-ignore\n      ctx.variadic(batch.data.length);\n      // @ts-ignore\n      batch.data.forEach(b => ctx.buffer(b));\n      return;\n\n    // validity, offset, and list child\n    case Type.List:\n    case Type.LargeList:\n    case Type.Map:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.offsets);\n      ctx.children(type, batch);\n      return;\n\n    // validity, offset, size, and list child\n    case Type.ListView:\n    case Type.LargeListView:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.offsets);\n      ctx.buffer(batch.sizes);\n      ctx.children(type, batch);\n      return;\n\n    // validity and children\n    case Type.FixedSizeList:\n    case Type.Struct:\n      ctx.buffer(batch.validity);\n      ctx.children(type, batch);\n      return;\n\n    // children only\n    case Type.RunEndEncoded:\n      ctx.children(type, batch);\n      return;\n\n    // union\n    case Type.Union: {\n      // @ts-ignore\n      ctx.buffer(batch.typeIds);\n      if (type.mode === UnionMode.Dense) {\n        ctx.buffer(batch.offsets);\n      }\n      ctx.children(type, batch);\n      return;\n    }\n\n    // unsupported type\n    default:\n      throw new Error(invalidDataType(typeId));\n  }\n}\n","/**\n * @import { TypedArray, TypedArrayConstructor } from '../types.js'\n */\nimport { align, grow, uint8Array } from '../util/arrays.js';\n\n/**\n * Create a new resizable buffer instance.\n * @param {TypedArrayConstructor} [arrayType]\n *  The array type.\n * @returns {Buffer} The buffer.\n */\nexport function buffer(arrayType) {\n  return new Buffer(arrayType);\n}\n\n/**\n * Resizable byte buffer.\n */\nexport class Buffer {\n  /**\n   * Create a new resizable buffer instance.\n   * @param {TypedArrayConstructor} arrayType\n   */\n  constructor(arrayType = uint8Array) {\n    this.buf = new arrayType(512);\n  }\n  /**\n   * Return the underlying data as a 64-bit aligned array of minimum size.\n   * @param {number} size The desired minimum array size.\n   * @returns {TypedArray} The 64-bit aligned array.\n   */\n  array(size) {\n    return align(this.buf, size);\n  }\n  /**\n   * Prepare for writes to the given index, resizing as necessary.\n   * @param {number} index The array index to prepare to write to.\n   */\n  prep(index) {\n    if (index >= this.buf.length) {\n      this.buf = grow(this.buf, index);\n    }\n  }\n  /**\n   * Return the value at the given index.\n   * @param {number} index The array index.\n   */\n  get(index) {\n    return this.buf[index];\n  }\n  /**\n   * Set a value at the given index.\n   * @param {number | bigint} value The value to set.\n   * @param {number} index The index to write to.\n   */\n  set(value, index) {\n    this.prep(index);\n    this.buf[index] = value;\n  }\n  /**\n   * Write a byte array at the given index. The method should be called\n   * only when the underlying buffer is of type Uint8Array.\n   * @param {Uint8Array} bytes The byte array.\n   * @param {number} index The starting index to write to.\n   */\n  write(bytes, index) {\n    this.prep(index + bytes.length);\n    /** @type {Uint8Array} */ (this.buf).set(bytes, index);\n  }\n}\n\n/**\n * Create a new resizable bitmap instance.\n * @returns {Bitmap} The bitmap buffer.\n */\nexport function bitmap() {\n  return new Bitmap();\n}\n\n/**\n * Resizable bitmap buffer.\n */\nexport class Bitmap extends Buffer {\n  /**\n   * Set a bit to true at the given bitmap index.\n   * @param {number} index The index to write to.\n   */\n  set(index) {\n    const i = index >> 3;\n    this.prep(i);\n    /** @type {Uint8Array} */ (this.buf)[i] |= (1 << (index % 8));\n  }\n}\n","/**\n * @import { Batch } from '../../batch.js'\n */\n\n/**\n * Abstract class for building a column data batch.\n */\nexport class BatchBuilder {\n  constructor(type, ctx) {\n    this.type = type;\n    this.ctx = ctx;\n    this.batchClass = ctx.batchType(type);\n  }\n\n  /**\n   * Initialize the builder state.\n   * @returns {this} This builder.\n   */\n  init() {\n    this.index = -1;\n    return this;\n  }\n\n  /**\n   * Write a value to the builder.\n   * @param {*} value\n   * @param {number} index\n   * @returns {boolean | void}\n   */\n  set(value, index) {\n    this.index = index;\n    return false;\n  }\n\n  /**\n   * Returns a batch constructor options object.\n   * Used internally to marshal batch data.\n   * @returns {Record<string, any>}\n   */\n  done() {\n    return null;\n  }\n\n  /**\n   * Returns a completed batch and reinitializes the builder state.\n   * @returns {Batch}\n   */\n  batch() {\n    const b = new this.batchClass(this.done());\n    this.init();\n    return b;\n  }\n}\n","import { uint8Array } from '../../util/arrays.js';\nimport { bitmap } from '../buffer.js';\nimport { BatchBuilder } from './batch.js';\n\n/**\n * Builder for validity bitmaps within batches.\n */\nexport class ValidityBuilder extends BatchBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n  }\n\n  init() {\n    this.nullCount = 0;\n    this.validity = bitmap();\n    return super.init();\n  }\n\n  /**\n   * @param {*} value\n   * @param {number} index\n   * @returns {boolean | void}\n   */\n  set(value, index) {\n    this.index = index;\n    const isValid = value != null;\n    if (isValid) {\n      this.validity.set(index);\n    } else {\n      this.nullCount++;\n    }\n    return isValid;\n  }\n\n  done() {\n    const { index, nullCount, type, validity } = this;\n    return {\n      length: index + 1,\n      nullCount,\n      type,\n      validity: nullCount\n        ? validity.array((index >> 3) + 1)\n        : new uint8Array(0)\n    };\n  }\n}\n","/**\n * @import { builderContext } from '../builder.js'\n * @import { DictionaryType, ExtractionOptions } from '../../types.js'\n */\nimport { Column } from '../../column.js';\nimport { keyString } from '../../util/strings.js';\nimport { batchType } from '../../batch-type.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Create a context object for managing dictionary builders.\n */\nexport function dictionaryContext() {\n  const idMap = new Map;\n  const dicts = new Set;\n  return {\n    /**\n     * Get a dictionary values builder for the given dictionary type.\n     * @param {DictionaryType} type\n     *  The dictionary type.\n     * @param {*} ctx The builder context.\n     * @returns {ReturnType<dictionaryValues>}\n     */\n    get(type, ctx) {\n      // if a dictionary has a non-negative id, assume it was set\n      // intentionally and track it for potential reuse across columns\n      // otherwise the dictionary is used for a single column only\n      const id = type.id;\n      if (id >= 0 && idMap.has(id)) {\n        return idMap.get(id);\n      } else {\n        const dict = dictionaryValues(type, ctx);\n        if (id >= 0) idMap.set(id, dict);\n        dicts.add(dict);\n        return dict;\n      }\n    },\n    /**\n     * Finish building dictionary values columns and assign them to\n     * their corresponding dictionary batches.\n     * @param {ExtractionOptions} options\n     */\n    finish(options) {\n      dicts.forEach(dict => dict.finish(options));\n    }\n  };\n}\n\n/**\n * Builder helper for creating dictionary values.\n * @param {DictionaryType} type\n *  The dictionary data type.\n * @param {ReturnType<builderContext>} ctx\n *  The builder context.\n */\nexport function dictionaryValues(type, ctx) {\n  const keys = Object.create(null);\n  const values = ctx.builder(type.dictionary);\n  const batches = [];\n\n  values.init();\n  let index = -1;\n\n  return {\n    type,\n    values,\n\n    add(batch) {\n      batches.push(batch);\n      return batch;\n    },\n\n    key(value) {\n      const v = keyString(value);\n      let k = keys[v];\n      if (k === undefined) {\n        keys[v] = k = ++index;\n        values.set(value, k);\n      }\n      return k;\n    },\n\n    finish(options) {\n      const valueType = type.dictionary;\n      const batch = new (batchType(valueType, options))(values.done());\n      const dictionary = new Column([batch]);\n      batches.forEach(batch => batch.setDictionary(dictionary));\n    }\n  };\n}\n\n/**\n * Builder for dictionary-typed data batches.\n */\nexport class DictionaryBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.dict = ctx.dictionary(type);\n  }\n\n  init() {\n    this.values = buffer(this.type.indices.values);\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.set(this.dict.key(value), index);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array(this.index + 1)\n    };\n  }\n\n  batch() {\n    // register batch with dictionary\n    // batch will be updated when the dictionary is finished\n    return this.dict.add(super.batch());\n  }\n}\n","/**\n * @import { DataType, IntType, UnionType } from '../types.js'\n */\nimport { bool, dateDay, dictionary, field, fixedSizeList, float64, int16, int32, int64, int8, list, nullType, struct, timestamp, utf8 } from '../data-types.js';\nimport { isArray } from '../util/arrays.js';\n\n/**\n * Infer the data type for a given input array.\n * @param {(visitor: (value: any) => void) => void} visit\n *  A function that applies a callback to successive data values.\n * @returns {DataType} The data type.\n */\nexport function inferType(visit) {\n  const profile = profiler();\n  visit(value => profile.add(value));\n  return profile.type();\n}\n\nfunction profiler() {\n  let length = 0;\n  let nullCount = 0;\n  let boolCount = 0;\n  let numberCount = 0;\n  let intCount = 0;\n  let bigintCount = 0;\n  let dateCount = 0;\n  let dayCount = 0;\n  let stringCount = 0;\n  let arrayCount = 0;\n  let structCount = 0;\n  let min = Infinity;\n  let max = -Infinity;\n  let minLength = Infinity;\n  let maxLength = -Infinity;\n  let minBigInt;\n  let maxBigInt;\n  let arrayProfile;\n  let structProfiles = {};\n\n  return {\n    add(value) {\n      length++;\n      if (value == null) {\n        nullCount++;\n        return;\n      }\n      switch (typeof value) {\n        case 'string':\n          stringCount++;\n          break;\n        case 'number':\n          numberCount++;\n          if (value < min) min = value;\n          if (value > max) max = value;\n          if (Number.isInteger(value)) intCount++;\n          break;\n        case 'bigint':\n          bigintCount++;\n          if (minBigInt === undefined) {\n            minBigInt = maxBigInt = value;\n          } else {\n            if (value < minBigInt) minBigInt = value;\n            if (value > maxBigInt) maxBigInt = value;\n          }\n          break;\n        case 'boolean':\n          boolCount++;\n          break;\n        case 'object':\n          if (value instanceof Date) {\n            dateCount++;\n            // 1 day = 1000ms * 60s * 60min * 24hr = 86400000\n            if ((+value % 864e5) === 0) dayCount++;\n          } else if (isArray(value)) {\n            arrayCount++;\n            const len = value.length;\n            if (len < minLength) minLength = len;\n            if (len > maxLength) maxLength = len;\n            arrayProfile ??= profiler();\n            value.forEach(arrayProfile.add);\n          } else {\n            structCount++;\n            for (const key in value) {\n              const fieldProfiler = structProfiles[key]\n                ?? (structProfiles[key] = profiler());\n              fieldProfiler.add(value[key]);\n            }\n          }\n      }\n    },\n    type() {\n      const valid = length - nullCount;\n      return valid === 0 ? nullType()\n        : intCount === valid ? intType(min, max)\n        : numberCount === valid ? float64()\n        : bigintCount === valid ? bigintType(minBigInt, maxBigInt)\n        : boolCount === valid ? bool()\n        : dayCount === valid ? dateDay()\n        : dateCount === valid ? timestamp()\n        : stringCount === valid ? dictionary(utf8())\n        : arrayCount === valid ? arrayType(arrayProfile.type(), minLength, maxLength)\n        : structCount === valid ? struct(\n            Object.entries(structProfiles).map(_ => field(_[0], _[1].type()))\n          )\n        : unionType();\n    }\n  };\n}\n\n/**\n * Return a list or fixed list type.\n * @param {DataType} type The child data type.\n * @param {number} minLength The minumum list length.\n * @param {number} maxLength The maximum list length.\n * @returns {DataType} The data type.\n */\nfunction arrayType(type, minLength, maxLength) {\n  return maxLength === minLength\n    ? fixedSizeList(type, minLength)\n    : list(type);\n}\n\n/**\n * @param {number} min\n * @param {number} max\n * @returns {DataType}\n */\nfunction intType(min, max) {\n  const v = Math.max(Math.abs(min) - 1, max);\n  return v < (1 << 7) ? int8()\n    : v < (1 << 15) ? int16()\n    : v < (2 ** 31) ? int32()\n    : float64();\n}\n\n/**\n * @param {bigint} min\n * @param {bigint} max\n * @returns {IntType}\n */\nfunction bigintType(min, max) {\n  const v = -min > max ? -min - 1n : max;\n  if (v >= 2 ** 63) {\n    throw new Error(`BigInt exceeds 64 bits: ${v}`);\n  }\n  return int64();\n}\n\n/**\n * @returns {UnionType}\n */\nfunction unionType() {\n  throw new Error('Mixed types detected, please define a union type.');\n}\n","import { toOffset } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for batches of binary-typed data.\n */\nexport class BinaryBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.toOffset = toOffset(type.offsets);\n  }\n\n  init() {\n    this.offsets = buffer(this.type.offsets);\n    this.values = buffer();\n    this.pos = 0;\n    return super.init();\n  }\n\n  set(value, index) {\n    const { offsets, values, toOffset } = this;\n    if (super.set(value, index)) {\n      values.write(value, this.pos);\n      this.pos += value.length;\n    }\n    offsets.set(toOffset(this.pos), index + 1);\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      offsets: this.offsets.array(this.index + 2),\n      values: this.values.array(this.pos + 1)\n    };\n  }\n}\n","import { bitmap } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for batches of bool-typed data.\n */\nexport class BoolBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n  }\n\n  init() {\n    this.values = bitmap();\n    return super.init();\n  }\n\n  set(value, index) {\n    super.set(value, index);\n    if (value) this.values.set(index);\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array((this.index >> 3) + 1)\n    }\n  }\n}\n","import { toDecimal } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for batches of decimal-typed data (64-bits or more).\n */\nexport class DecimalBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.scale = 10 ** type.scale;\n    this.stride = type.bitWidth >> 6;\n  }\n\n  init() {\n    this.values = buffer(this.type.values);\n    return super.init();\n  }\n\n  set(value, index) {\n    const { scale, stride, values } = this;\n    if (super.set(value, index)) {\n      values.prep((index + 1) * stride);\n      // @ts-ignore\n      toDecimal(value, values.buf, index * stride, stride, scale);\n    }\n  }\n\n  done() {\n    const { index, stride, values } = this;\n    return {\n      ...super.done(),\n      values: values.array((index + 1) * stride)\n    };\n  }\n}\n","import { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for fixed-size-binary-typed data batches.\n */\nexport class FixedSizeBinaryBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.stride = type.stride;\n  }\n\n  init() {\n    this.values = buffer();\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.write(value, index * this.stride);\n    }\n  }\n\n  done() {\n    const { stride, values } = this;\n    return {\n      ...super.done(),\n      values: values.array(stride * (this.index + 1))\n    };\n  }\n}\n","import { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for fixed-size-list-typed data batches.\n */\nexport class FixedSizeListBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.child = ctx.builder(this.type.children[0].type);\n    this.stride = type.stride;\n  }\n\n  init() {\n    this.child.init();\n    return super.init();\n  }\n\n  set(value, index) {\n    const { child, stride } = this;\n    const base = index * stride;\n    if (super.set(value, index)) {\n      for (let i = 0; i < stride; ++i) {\n        child.set(value[i], base + i);\n      }\n    } else {\n      child.index = base + stride;\n    }\n  }\n\n  done() {\n    const { child } = this;\n    return {\n      ...super.done(),\n      children: [ child.batch() ]\n    };\n  }\n}\n","import { toMonthDayNanoBytes } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for day/time interval-typed data batches.\n */\nexport class IntervalDayTimeBuilder extends ValidityBuilder {\n  init() {\n    this.values = buffer(this.type.values);\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      const i = index << 1;\n      this.values.set(value[0], i);\n      this.values.set(value[1], i + 1);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array((this.index + 1) << 1)\n    }\n  }\n}\n\n/**\n * Builder for month/day/nano interval-typed data batches.\n */\nexport class IntervalMonthDayNanoBuilder extends ValidityBuilder {\n  init() {\n    this.values = buffer();\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.write(toMonthDayNanoBytes(value), index << 4);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array((this.index + 1) << 4)\n    }\n  }\n}\n","import { toOffset } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Abstract class for building list data batches.\n */\nexport class AbstractListBuilder extends ValidityBuilder {\n  constructor(type, ctx, child) {\n    super(type, ctx);\n    this.child = child;\n  }\n\n  init() {\n    this.child.init();\n    const offsetType = this.type.offsets;\n    this.offsets = buffer(offsetType);\n    this.toOffset = toOffset(offsetType);\n    this.pos = 0;\n    return super.init();\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      offsets: this.offsets.array(this.index + 2),\n      children: [ this.child.batch() ]\n    };\n  }\n}\n\n/**\n * Builder for list-typed data batches.\n */\nexport class ListBuilder extends AbstractListBuilder {\n  constructor(type, ctx) {\n    super(type, ctx, ctx.builder(type.children[0].type));\n  }\n\n  set(value, index) {\n    const { child, offsets, toOffset } = this;\n    if (super.set(value, index)) {\n      value.forEach(v => child.set(v, this.pos++));\n    }\n    offsets.set(toOffset(this.pos), index + 1);\n  }\n}\n","import { ValidityBuilder } from './validity.js';\n\n/**\n * Abstract class for building list-typed data batches.\n */\nexport class AbstractStructBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.children = type.children.map(c => ctx.builder(c.type));\n  }\n\n  init() {\n    this.children.forEach(c => c.init());\n    return super.init();\n  }\n\n  done() {\n    const { children } = this;\n    children.forEach(c => c.index = this.index);\n    return {\n      ...super.done(),\n      children: children.map(c => c.batch())\n    };\n  }\n}\n\n/**\n * Builder for struct-typed data batches.\n */\nexport class StructBuilder extends AbstractStructBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.setters = this.children.map((child, i) => {\n      const name = type.children[i].name;\n      return (value, index) => child.set(value?.[name], index);\n    });\n  }\n\n  set(value, index) {\n    super.set(value, index);\n    const setters = this.setters;\n    for (let i = 0; i < setters.length; ++i) {\n      setters[i](value, index);\n    }\n  }\n}\n","import { AbstractListBuilder } from './list.js';\nimport { AbstractStructBuilder } from './struct.js';\n\n/**\n * Builder for map-typed data batches.\n */\nexport class MapBuilder extends AbstractListBuilder {\n  constructor(type, ctx) {\n    super(type, ctx, new MapStructBuilder(type.children[0].type, ctx));\n  }\n\n  set(value, index) {\n    const { child, offsets, toOffset } = this;\n    if (super.set(value, index)) {\n      for (const keyValuePair of value) {\n        child.set(keyValuePair, this.pos++);\n      }\n    }\n    offsets.set(toOffset(this.pos), index + 1);\n  }\n}\n\n/**\n * Builder for key-value struct batches within a map.\n */\nclass MapStructBuilder extends AbstractStructBuilder {\n  set(value, index) {\n    super.set(value, index);\n    const [key, val] = this.children;\n    key.set(value[0], index);\n    val.set(value[1], index);\n  }\n}\n","import { keyString } from '../../util/strings.js';\nimport { BatchBuilder } from './batch.js';\n\nconst NO_VALUE = {}; // empty object that fails strict equality\n\n/**\n * Builder for run-end-encoded-typed data batches.\n */\nexport class RunEndEncodedBuilder extends BatchBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.children = type.children.map(c => ctx.builder(c.type));\n  }\n\n  init() {\n    this.pos = 0;\n    this.key = null;\n    this.value = NO_VALUE;\n    this.children.forEach(c => c.init());\n    return super.init();\n  }\n\n  next() {\n    const [runs, vals] = this.children;\n    runs.set(this.index + 1, this.pos);\n    vals.set(this.value, this.pos++);\n  }\n\n  set(value, index) {\n    // perform fast strict equality test\n    if (value !== this.value) {\n      // if no match, fallback to key string test\n      const key = keyString(value);\n      if (key !== this.key) {\n        // if key doesn't match, write prior run and update\n        if (this.key) this.next();\n        this.key = key;\n        this.value = value;\n      }\n    }\n    this.index = index;\n  }\n\n  done() {\n    this.next();\n    const { children, index, type } = this;\n    return {\n      length: index + 1,\n      nullCount: 0,\n      type,\n      children: children.map(c => c.batch())\n    };\n  }\n}\n","import { int8Array } from '../../util/arrays.js';\nimport { BatchBuilder } from './batch.js';\nimport { buffer } from '../buffer.js';\n\n/**\n * Abstract class for building union-typed data batches.\n */\nexport class AbstractUnionBuilder extends BatchBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.children = type.children.map(c => ctx.builder(c.type));\n    this.typeMap = type.typeMap;\n    this.lookup = type.typeIdForValue;\n  }\n\n  init() {\n    this.nullCount = 0;\n    this.typeIds = buffer(int8Array);\n    this.children.forEach(c => c.init());\n    return super.init();\n  }\n\n  set(value, index) {\n    const { children, lookup, typeMap, typeIds } = this;\n    this.index = index;\n    const typeId = lookup(value, index);\n    const child = children[typeMap[typeId]];\n    typeIds.set(typeId, index);\n    if (value == null) ++this.nullCount;\n    // @ts-ignore\n    this.update(value, index, child);\n  }\n\n  done() {\n    const { children, nullCount, type, typeIds } = this;\n    const length = this.index + 1;\n    return {\n      length,\n      nullCount,\n      type,\n      typeIds: typeIds.array(length),\n      children: children.map(c => c.batch())\n    };\n  }\n}\n\n/**\n * Builder for sparse union-typed data batches.\n */\nexport class SparseUnionBuilder extends AbstractUnionBuilder {\n  update(value, index, child) {\n    // update selected child with value\n    // then set all other children to null\n    child.set(value, index);\n    this.children.forEach(c => { if (c !== child) c.set(null, index) });\n  }\n}\n\n/**\n * Builder for dense union-typed data batches.\n */\nexport class DenseUnionBuilder extends AbstractUnionBuilder {\n  init() {\n    this.offsets = buffer(this.type.offsets);\n    return super.init();\n  }\n\n  update(value, index, child) {\n    const offset = child.index + 1;\n    child.set(value, offset);\n    this.offsets.set(offset, index);\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      offsets: this.offsets.array(this.index + 1)\n    };\n  }\n}\n","import { encodeUtf8 } from '../../util/strings.js';\nimport { BinaryBuilder } from './binary.js';\n\n/**\n * Builder for utf8-typed data batches.\n */\nexport class Utf8Builder extends BinaryBuilder {\n  set(value, index) {\n    super.set(value && encodeUtf8(value), index);\n  }\n}\n","import { toBigInt } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for data batches that can be accessed directly as typed arrays.\n */\nexport class DirectBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.values = buffer(type.values);\n  }\n\n  init() {\n    this.values = buffer(this.type.values);\n    return super.init();\n  }\n\n  /**\n   * @param {*} value\n   * @param {number} index\n   * @returns {boolean | void}\n   */\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.set(value, index);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array(this.index + 1)\n    };\n  }\n}\n\n/**\n * Builder for int64/uint64 data batches written as bigints.\n */\nexport class Int64Builder extends DirectBuilder {\n  set(value, index) {\n    super.set(value == null ? value : toBigInt(value), index);\n  }\n}\n\n/**\n * Builder for data batches whose values must pass through a transform\n * function prior to be written to a backing buffer.\n */\nexport class TransformBuilder extends DirectBuilder {\n  constructor(type, ctx, transform) {\n    super(type, ctx);\n    this.transform = transform;\n  }\n  set(value, index) {\n    super.set(value == null ? value : this.transform(value), index);\n  }\n}\n","/**\n * @import { DataType, ExtractionOptions } from '../types.js'\n * @import { BatchBuilder } from './builders/batch.js'\n */\nimport { batchType } from '../batch-type.js';\nimport { IntervalUnit, Type } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { isInt64ArrayType } from '../util/arrays.js';\nimport { toBigInt, toDateDay, toDecimal32, toFloat16, toTimestamp } from '../util/numbers.js';\nimport { BinaryBuilder } from './builders/binary.js';\nimport { BoolBuilder } from './builders/bool.js';\nimport { DecimalBuilder } from './builders/decimal.js';\nimport { DictionaryBuilder, dictionaryContext } from './builders/dictionary.js';\nimport { FixedSizeBinaryBuilder } from './builders/fixed-size-binary.js';\nimport { FixedSizeListBuilder } from './builders/fixed-size-list.js';\nimport { IntervalDayTimeBuilder, IntervalMonthDayNanoBuilder } from './builders/interval.js';\nimport { ListBuilder } from './builders/list.js';\nimport { MapBuilder } from './builders/map.js';\nimport { RunEndEncodedBuilder } from './builders/run-end-encoded.js';\nimport { StructBuilder } from './builders/struct.js';\nimport { DenseUnionBuilder, SparseUnionBuilder } from './builders/union.js';\nimport { Utf8Builder } from './builders/utf8.js';\nimport { DirectBuilder, Int64Builder, TransformBuilder } from './builders/values.js';\n\n/**\n * Create a context object for shared builder state.\n * @param {ExtractionOptions} [options]  Batch extraction options.\n* @param {ReturnType<dictionaryContext>} [dictionaries]\n *  Context object for tracking dictionaries.\n */\nexport function builderContext(\n  options = {},\n  dictionaries = dictionaryContext()\n) {\n  return {\n    batchType: type => batchType(type, options),\n    builder(type) { return builder(type, this); },\n    dictionary(type) { return dictionaries.get(type, this); },\n    finish: () => dictionaries.finish(options)\n  };\n}\n\n/**\n * Returns a batch builder for the given type and builder context.\n * @param {DataType} type A data type.\n * @param {ReturnType<builderContext>} [ctx] A builder context.\n * @returns {BatchBuilder}\n */\nexport function builder(type, ctx = builderContext()) {\n  const { typeId } = type;\n  switch (typeId) {\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n      return isInt64ArrayType(type.values)\n        ? new Int64Builder(type, ctx)\n        : new DirectBuilder(type, ctx);\n    case Type.Float:\n      return type.precision\n        ? new DirectBuilder(type, ctx)\n        : new TransformBuilder(type, ctx, toFloat16)\n    case Type.Binary:\n    case Type.LargeBinary:\n      return new BinaryBuilder(type, ctx);\n    case Type.Utf8:\n    case Type.LargeUtf8:\n      return new Utf8Builder(type, ctx);\n    case Type.Bool:\n      return new BoolBuilder(type, ctx);\n    case Type.Decimal:\n      return type.bitWidth === 32\n        ? new TransformBuilder(type, ctx, toDecimal32(type.scale))\n        : new DecimalBuilder(type, ctx);\n    case Type.Date:\n      return new TransformBuilder(type, ctx, type.unit ? toBigInt : toDateDay);\n    case Type.Timestamp:\n      return new TransformBuilder(type, ctx, toTimestamp(type.unit));\n    case Type.Interval:\n      switch (type.unit) {\n        case IntervalUnit.DAY_TIME:\n          return new IntervalDayTimeBuilder(type, ctx);\n        case IntervalUnit.MONTH_DAY_NANO:\n          return new IntervalMonthDayNanoBuilder(type, ctx);\n      }\n      // case IntervalUnit.YEAR_MONTH:\n      return new DirectBuilder(type, ctx);\n    case Type.List:\n    case Type.LargeList:\n      return new ListBuilder(type, ctx);\n    case Type.Struct:\n      return new StructBuilder(type, ctx);\n    case Type.Union:\n      return type.mode\n        ? new DenseUnionBuilder(type, ctx)\n        : new SparseUnionBuilder(type, ctx);\n    case Type.FixedSizeBinary:\n      return new FixedSizeBinaryBuilder(type, ctx);\n    case Type.FixedSizeList:\n      return new FixedSizeListBuilder(type, ctx);\n    case Type.Map:\n      return new MapBuilder(type, ctx);\n    case Type.RunEndEncoded:\n      return new RunEndEncodedBuilder(type, ctx);\n\n    case Type.Dictionary:\n      return new DictionaryBuilder(type, ctx);\n  }\n  // case Type.BinaryView:\n  // case Type.Utf8View:\n  // case Type.ListView:\n  // case Type.LargeListView:\n  throw new Error(invalidDataType(typeId));\n}\n","/**\n * @import { ColumnBuilderOptions, DataType, NullType } from '../types.js'\n * @import { dictionaryContext } from './builders/dictionary.js'\n */\nimport { NullBatch } from '../batch.js';\nimport { Column } from '../column.js';\nimport { inferType } from './infer-type.js';\nimport { builder, builderContext } from './builder.js';\nimport { Type } from '../constants.js';\nimport { isIterable } from '../util/objects.js';\n\n/**\n * Create a new column by iterating over provided values.\n * @template T\n * @param {Iterable | ((callback: (value: any) => void) => void)} values\n *  Either an iterable object or a visitor function that applies a callback\n *  to successive data values (akin to Array.forEach).\n * @param {DataType} [type] The data type.\n * @param {ColumnBuilderOptions} [options]\n *  Builder options for the generated column.\n * @param {ReturnType<dictionaryContext>} [dicts]\n *  Dictionary context object, for internal use only.\n * @returns {Column<T>} The generated column.\n */\nexport function columnFromValues(values, type, options = {}, dicts) {\n  const visit = isIterable(values)\n    ? callback => { for (const value of values) callback(value); }\n    : values;\n\n  type ??= inferType(visit);\n  const { maxBatchRows = Infinity, ...opt } = options;\n  let data;\n\n  if (type.typeId === Type.Null) {\n    let length = 0;\n    visit(() => ++length);\n    data = nullBatches(type, length, maxBatchRows);\n  } else {\n    const ctx = builderContext(opt, dicts);\n    const b = builder(type, ctx).init();\n    const next = b => data.push(b.batch());\n    data = [];\n\n    let row = 0;\n    visit(value => {\n      b.set(value, row++);\n      if (row >= maxBatchRows) {\n        next(b);\n        row = 0;\n      }\n    });\n    if (row) next(b);\n\n    // resolve dictionaries\n    ctx.finish();\n  }\n\n  return new Column(data, type);\n}\n\n/**\n * Create null batches with the given batch size limit.\n * @param {NullType} type The null data type.\n * @param {number} length The total column length.\n * @param {number} limit The maximum batch size.\n * @returns {NullBatch[]} The null batches.\n */\nfunction nullBatches(type, length, limit) {\n  const data = [];\n  const batch = length => new NullBatch({ length, nullCount: length, type });\n  const numBatches = Math.floor(length / limit);\n  for (let i = 0; i < numBatches; ++i) {\n    data.push(batch(limit));\n  }\n  const rem = length % limit;\n  if (rem) data.push(batch(rem));\n  return data;\n}\n","/**\n * @import { ColumnBuilderOptions, DataType, TypedArray, TypedArrayConstructor } from '../types.js'\n * @import { dictionaryContext } from './builders/dictionary.js'\n */\nimport { float32Array, float64Array, int16Array, int32Array, int64Array, int8Array, isInt64ArrayType, isTypedArray, uint16Array, uint32Array, uint64Array, uint8Array } from '../util/arrays.js';\nimport { DirectBatch, Int64Batch } from '../batch.js';\nimport { Column } from '../column.js';\nimport { float32, float64, int16, int32, int64, int8, uint16, uint32, uint64, uint8 } from '../data-types.js';\nimport { columnFromValues } from './column-from-values.js';\n\n/**\n * Create a new column from a provided data array.\n * @template T\n * @param {Array | TypedArray} array The input data.\n * @param {DataType} [type] The data type.\n *  If not specified, type inference is attempted.\n * @param {ColumnBuilderOptions} [options]\n *  Builder options for the generated column.\n * @param {ReturnType<dictionaryContext>} [dicts]\n *  Builder context object, for internal use only.\n * @returns {Column<T>} The generated column.\n */\nexport function columnFromArray(array, type, options = {}, dicts) {\n  return !type && isTypedArray(array)\n    ? columnFromTypedArray(array, options)\n    : columnFromValues(v => array.forEach(v), type, options, dicts);\n}\n\n/**\n * Create a new column from a typed array input.\n * @template T\n * @param {TypedArray} values The input data.\n * @param {ColumnBuilderOptions} options\n *  Builder options for the generated column.\n * @returns {Column<T>} The generated column.\n */\nfunction columnFromTypedArray(values, { maxBatchRows, useBigInt }) {\n  const arrayType = /** @type {TypedArrayConstructor} */ (\n    values.constructor\n  );\n  const type = typeForTypedArray(arrayType);\n  const length = values.length;\n  const limit = Math.min(maxBatchRows || Infinity, length);\n  const numBatches = Math.floor(length / limit);\n\n  const batches = [];\n  const batchType = isInt64ArrayType(arrayType) && !useBigInt ? Int64Batch : DirectBatch;\n  const add = (start, end) => batches.push(new batchType({\n    length: end - start,\n    nullCount: 0,\n    type,\n    validity: new uint8Array(0),\n    values: values.subarray(start, end)\n  }));\n\n  let idx = 0;\n  for (let i = 0; i < numBatches; ++i) add(idx, idx += limit);\n  if (idx < length) add(idx, length);\n\n  return new Column(batches);\n}\n\n/**\n * Return an Arrow data type for a given typed array type.\n * @param {TypedArrayConstructor} arrayType The typed array type.\n * @returns {DataType} The data type.\n */\nfunction typeForTypedArray(arrayType) {\n  switch (arrayType) {\n    case float32Array: return float32();\n    case float64Array: return float64();\n    case int8Array: return int8();\n    case int16Array: return int16();\n    case int32Array: return int32();\n    case int64Array: return int64();\n    case uint8Array: return uint8();\n    case uint16Array: return uint16();\n    case uint32Array: return uint32();\n    case uint64Array: return uint64();\n  }\n}\n","/**\n * @import { Column } from '../column.js'\n */\nimport { Endianness, Version } from '../constants.js';\nimport { field } from '../data-types.js';\nimport { Table } from '../table.js';\n\n/**\n * Create a new table from a collection of columns. Columns are assumed\n * to have the same record batch sizes.\n * @param {[string, Column][] | Record<string, Column>} data The columns,\n *  as an object with name keys, or an array of [name, column] pairs.\n * @param {boolean} [useProxy] Flag indicating if row proxy\n *  objects should be used to represent table rows (default `false`).\n * @returns {Table} The new table.\n */\nexport function tableFromColumns(data, useProxy) {\n  const fields = [];\n  const entries = Array.isArray(data) ? data : Object.entries(data);\n  const length = entries[0]?.[1].length;\n\n  const columns = entries.map(([name, col]) => {\n    if (col.length !== length) {\n      throw new Error('All columns must have the same length.');\n    }\n    fields.push(field(name, col.type));\n    return col;\n  });\n\n  const schema = {\n    version: Version.V5,\n    endianness: Endianness.Little,\n    fields,\n    metadata: null\n  };\n\n  return new Table(schema, columns, useProxy);\n}\n","/**\n * @import { Column } from '../column.js'\n * @import { TableBuilderOptions, TypedArray } from '../types.js'\n * @import { Table } from '../table.js'\n */\nimport { dictionaryContext } from './builders/dictionary.js';\nimport { columnFromArray } from './column-from-array.js';\nimport { tableFromColumns } from './table-from-columns.js';\n\n/**\n * Create a new table from the provided arrays.\n * @param {[string, Array | TypedArray][]\n *  | Record<string, Array | TypedArray>} data\n *  The input data as a collection of named arrays.\n * @param {TableBuilderOptions} options\n *  Table builder options, including an optional type map.\n * @returns {Table} The new table.\n */\nexport function tableFromArrays(data, options = {}) {\n  const { types = {}, ...opt } = options;\n  const dicts = dictionaryContext();\n  const entries = Array.isArray(data) ? data : Object.entries(data);\n  const columns = entries.map(([name, array]) =>\n    /** @type {[string, Column]} */ (\n    [ name, columnFromArray(array, types[name], opt, dicts)]\n  ));\n  return tableFromColumns(columns, options.useProxy);\n}\n"],"names":["MAGIC","Uint8Array","of","EOS","Version","V1","V2","V3","V4","V5","Endianness","Little","Big","MessageHeader","NONE","Schema","DictionaryBatch","RecordBatch","Tensor","SparseTensor","Type","Dictionary","Null","Int","Float","Binary","Utf8","Bool","Decimal","Date","Time","Timestamp","Interval","List","Struct","Union","FixedSizeBinary","FixedSizeList","Map","Duration","LargeBinary","LargeUtf8","LargeList","RunEndEncoded","BinaryView","Utf8View","ListView","LargeListView","Precision","HALF","SINGLE","DOUBLE","DateUnit","DAY","MILLISECOND","TimeUnit","SECOND","MICROSECOND","NANOSECOND","IntervalUnit","YEAR_MONTH","DAY_TIME","MONTH_DAY_NANO","UnionMode","Sparse","Dense","uint8Array","uint16Array","Uint16Array","uint32Array","Uint32Array","uint64Array","BigUint64Array","int8Array","Int8Array","int16Array","Int16Array","int32Array","Int32Array","int64Array","BigInt64Array","float32Array","Float32Array","float64Array","Float64Array","intArrayType","bitWidth","signed","i","Math","log2","TypedArray","Object","getPrototypeOf","isTypedArray","value","isArray","Array","isInt64ArrayType","bisect","offsets","index","a","b","length","mid","trunc","resize","array","newLength","offset","newArray","constructor","set","grow","shift","check","test","message","Error","checkOneOf","values","includes","keyFor","object","key","val","entries","invalidDataType","typeId","field","name","type","nullable","metadata","isField","hasOwn","isDataType","asField","defaultName","defaultNullable","basicType","dictionary","indexType","ordered","id","indices","int32","nullType","int","int8","int16","int64","uint8","uint16","uint32","uint64","float","precision","float32","float64","binary","utf8","bool","decimal","scale","date","unit","dateDay","time","timestamp","timezone","interval","undefined","list","child","children","struct","map","union","mode","typeIds","typeIdForValue","v","typeMap","reduce","m","fixedSizeBinary","stride","fixedSizeList","mapType","keysSorted","duration","largeBinary","largeUtf8","largeList","runEndEncoded","runsField","valuesField","listView","largeListView","f64","buf","buffer","i64","u32","i32","u8","identity","toBigInt","BigInt","toOffset","toDateDay","toNumber","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","divide","num","div","asUint64","asUintN","fromDecimal64","asIntN","fromDecimal128","x","fromDecimal256","toFloat16","sign","expo","sigf","textDecoder","TextDecoder","textEncoder","TextEncoder","decodeUtf8","decode","encodeUtf8","str","encode","keyString","isDate","s","k","objectKey","decodeBit","bitmap","readObject","pos","readInt32","vtable","size","readInt16","read","fallback","off","readOffset","readBoolean","readUint8","readInt8","readUint16","readUint32","readInt64","readString","subarray","readVector","extract","base","from","_","RowIndex","Symbol","proxyFactory","names","batches","RowObject","this","toJSON","structObject","proto","prototype","batch","defineProperty","get","at","enumerable","objectFactory","obj","Batch","static","nullCount","validity","sizes","toStringTag","isValid","slice","start","end","n","iterator","DirectBatch","options","super","NumberBatch","ArrayBatch","NullBatch","Int64Batch","Float16Batch","NaN","BoolBatch","Decimal32NumberBatch","DecimalBatch","DecimalNumberBatch","DecimalBigIntBatch","DateBatch","source","DateDayBatch","DateDayMillisecondBatch","TimestampSecondBatch","TimestampMillisecondBatch","TimestampMicrosecondBatch","TimestampNanosecondBatch","IntervalDayTimeBatch","IntervalMonthDayNanoBatch","offset32","offset64","BinaryBatch","LargeBinaryBatch","Utf8Batch","LargeUtf8Batch","ListBatch","LargeListBatch","ListViewBatch","LargeListViewBatch","FixedBatch","FixedBinaryBatch","FixedListBatch","pairs","keys","vals","push","MapEntryBatch","MapBatch","SparseUnionBatch","DenseUnionBatch","StructBatch","factory","StructProxyBatch","RunEndEncodedBatch","runs","setDictionary","cache","ViewBatch","data","view","BinaryViewBatch","Utf8ViewBatch","columnBuilder","add","clear","done","Column","c","iter","next","batchedIterator","toArray","copy","ArrayType","copyArray","j","extractArray","_cache","Table","schema","useProxy","fields","f","gen","getFactory","numCols","numRows","getChildAt","getChild","findIndex","selectAt","as","renameField","select","all","indexOf","toColumns","cols","forEach","output","row","batchType","useBigInt","useDate","useDecimalInt","useMap","wrap","BaseClass","WrapperClass","decodeBlock","metadataLength","bodyLength","decodeBlocks","decodeRecordBatch","version","nodes","regions","variadic","decodeDictionaryBatch","isDelta","decodeDataType","decodeMetadata","decodeSchema","endianness","decodeSchemaFields","fieldsOffset","decodeField","typeOffset","dict","decodeDictionary","fieldOffset","decodeFieldChildren","decodeInt","decodeMessage","head","byteLength","expected","actual","content","decoder","invalidMessageType","body","invalidMessageBodyLength","decodeIPC","ArrayBuffer","SharedArrayBuffer","isArrayBufferLike","isArrowFileFormat","dicts","recs","dictionaries","records","decodeIPCFile","stream","flat","decodeIPCStream","visit","ctx","node","BatchType","writeInt32","INIT_SIZE","Builder","sink","minalign","space","vtables","outputBytes","writeInt8","writeInt16","writeInt64","addInt8","prep","addInt16","addInt32","addInt64","addOffset","addObject","numFields","addFields","builder","fill","startOffset","slot","defaultValue","finish","vtableOffset","standardFields","len","existingTable","vt1","outer_loop","vt2","objectBuilder","addVector","items","itemSize","alignment","writeItem","addOffsetVector","addString","rootOffset","flush","bytes","write","addBuffer","pad","addPadding","byteCount","additionalBytes","bufSize","used","alignSize","encodeRecordBatch","nodeVector","regionVector","region","variadicVector","count","encodeDictionaryBatch","dictionaryBatch","dataOffset","encodeMetadata","encodeDataType","encodeDictionary","encodeInt","encodeFloat","encodeDecimal","encodeDate","encodeTime","timezoneOffset","encodeTimestamp","encodeInterval","encodeDuration","encodeFixedSize","encodeMap","typeIdsOffset","encodeUnion","isLittleEndian","encodeSchema","fieldOffsets","encodeField","fieldsVectorOffset","metadataOffset","dictionaryOffset","childOffsets","childrenVectorOffset","nameOffset","encodeBlock","writeMessage","headerType","headerOffset","blocks","messageSize","alignedSize","Sink","MemorySink","buffers","bufs","sum","STREAM","FILE","encodeIPC","format","file","dictBlocks","recordBlocks","writeBuffers","recsOffset","dictsOffset","schemaOffset","writeFooter","visitDictionaries","visitor","assembleRecordBatch","columns","batchIndex","byteOffset","assembleContext","column","arrayType","Buffer","alignedLength","bpe","align64","BYTES_PER_ELEMENT","align","Bitmap","BatchBuilder","batchClass","init","ValidityBuilder","dictionaryContext","idMap","Set","has","create","dictionaryValues","DictionaryBuilder","inferType","profile","profiler","minBigInt","maxBigInt","arrayProfile","boolCount","numberCount","intCount","bigintCount","dateCount","dayCount","stringCount","arrayCount","structCount","min","Infinity","max","minLength","maxLength","structProfiles","isInteger","valid","abs","intType","bigintType","unionType","BinaryBuilder","BoolBuilder","DecimalBuilder","toDecimal","FixedSizeBinaryBuilder","FixedSizeListBuilder","IntervalDayTimeBuilder","IntervalMonthDayNanoBuilder","d","toMonthDayNanoBytes","AbstractListBuilder","offsetType","ListBuilder","AbstractStructBuilder","StructBuilder","setters","MapBuilder","MapStructBuilder","keyValuePair","NO_VALUE","RunEndEncodedBuilder","AbstractUnionBuilder","lookup","update","SparseUnionBuilder","DenseUnionBuilder","Utf8Builder","DirectBuilder","Int64Builder","TransformBuilder","transform","builderContext","columnFromValues","callback","maxBatchRows","opt","limit","numBatches","floor","rem","nullBatches","columnFromArray","typeForTypedArray","idx","columnFromTypedArray","tableFromColumns","col","keyField","valueField","types","dictionaryMap","context","nodeIndex","bufferIndex","variadicIndex","contextGenerator","dictionaryTypes","visitField","visitSchemaFields","createTable","table","some","checkBatchLengths","dictMap","dictionaryColumn","assembleDictionaryBatches","assembleRecordBatches","visitDictType","visitFields","parentType","assembleSchema"],"mappings":"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"}